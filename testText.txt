Qt 5.15
Qt Core
C++ Classes
QString
Qt 5.15.1 Reference Documentation 
Contents
Public Types
Public Functions
Static Public Members
Related Non-Members
Macros
Detailed Description
Initializing a String
Manipulating String Data
Querying String Data
Converting Between 8-Bit Strings and Unicode Strings
Distinction Between Null and Empty Strings
Argument Formats
More Efficient String Construction
Maximum size and out-of-memory conditions
QString Class
The QString class provides a Unicode character string. More...

Header:
#include <QString> 
qmake:
QT += core

List of all members, including inherited members
Obsolete members
Note: All functions in this class are reentrant. 
Public Types

typedef 
ConstIterator
typedef 
Iterator
enum 
NormalizationForm { NormalizationForm_D, NormalizationForm_C, NormalizationForm_KD, NormalizationForm_KC }
enum 
SectionFlag { SectionDefault, SectionSkipEmpty, SectionIncludeLeadingSep, SectionIncludeTrailingSep, SectionCaseInsensitiveSeps }
flags 
SectionFlags
typedef 
const_iterator
typedef 
const_pointer
typedef 
const_reference
typedef 
const_reverse_iterator
typedef 
difference_type
typedef 
iterator
typedef 
pointer
typedef 
reference
typedef 
reverse_iterator
typedef 
size_type
typedef 
value_type

Public Functions


QString(const QByteArray &ba)

QString(const char *str)

QString(QString &&other)

QString(const QString &other)

QString(QLatin1String str)

QString(int size, QChar ch)

QString(QChar ch)

QString(const QChar *unicode, int size = -1)

QString()
QString &
operator=(const QByteArray &ba)
QString &
operator=(QString &&other)
QString &
operator=(const QString &other)

~QString()
QString &
append(const QString &str)
QString &
append(QChar ch)
QString &
append(const QChar *str, int len)
QString &
append(const QStringRef &reference)
QString &
append(QLatin1String str)
QString &
append(const char *str)
QString &
append(const QByteArray &ba)
QString 
arg(const QString &a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(qlonglong a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(qulonglong a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(long a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(ulong a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(int a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(uint a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(short a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(ushort a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(double a, int fieldWidth = 0, char format = 'g', int precision = -1, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(char a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(QChar a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(QStringView a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(QLatin1String a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const
QString 
arg(const QString &a1, const QString &a2) const
QString 
arg(const QString &a1, const QString &a2, const QString &a3) const
QString 
arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4) const
QString 
arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5) const
QString 
arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5, const QString &a6) const
QString 
arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5, const QString &a6, const QString &a7) const
QString 
arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5, const QString &a6, const QString &a7, const QString &a8) const
QString 
arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5, const QString &a6, const QString &a7, const QString &a8, const QString &a9) const
QString 
arg(Args &&... args) const
const QChar 
at(int position) const
QChar 
back() const
QCharRef 
back()
QString::iterator 
begin()
QString::const_iterator 
begin() const
int 
capacity() const
QString::const_iterator 
cbegin() const
QString::const_iterator 
cend() const
void 
chop(int n)
QString 
chopped(int len) const
void 
clear()
int 
compare(const QString &other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
compare(const QStringRef &ref, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
compare(QLatin1String other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
compare(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
compare(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
QString::const_iterator 
constBegin() const
const QChar *
constData() const
QString::const_iterator 
constEnd() const
bool 
contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
contains(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
contains(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
contains(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
contains(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
contains(const QRegExp &rx) const
bool 
contains(QRegExp &rx) const
bool 
contains(const QRegularExpression &re) const
bool 
contains(const QRegularExpression &re, QRegularExpressionMatch *rmatch) const
int 
count(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
count() const
int 
count(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
count(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
count(const QRegExp &rx) const
int 
count(const QRegularExpression &re) const
QString::const_reverse_iterator 
crbegin() const
QString::const_reverse_iterator 
crend() const
QChar *
data()
const QChar *
data() const
QString::iterator 
end()
QString::const_iterator 
end() const
bool 
endsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
endsWith(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
endsWith(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
endsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
endsWith(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
QString &
fill(QChar ch, int size = -1)
QChar 
front() const
QCharRef 
front()
int 
indexOf(QLatin1String str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
indexOf(QChar ch, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
indexOf(const QString &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
indexOf(const QStringRef &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
indexOf(QStringView str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
indexOf(const QRegExp &rx, int from = 0) const
int 
indexOf(QRegExp &rx, int from = 0) const
int 
indexOf(const QRegularExpression &re, int from = 0) const
int 
indexOf(const QRegularExpression &re, int from, QRegularExpressionMatch *rmatch) const
QString &
insert(int position, const QString &str)
QString &
insert(int position, QChar ch)
QString &
insert(int position, const QChar *unicode, int size)
QString &
insert(int position, const QStringRef &str)
QString &
insert(int position, QLatin1String str)
QString &
insert(int position, const char *str)
QString &
insert(int position, const QByteArray &str)
bool 
isEmpty() const
bool 
isLower() const
bool 
isNull() const
bool 
isRightToLeft() const
bool 
isUpper() const
bool 
isValidUtf16() const
int 
lastIndexOf(const QString &str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
lastIndexOf(QChar ch, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
lastIndexOf(QLatin1String str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
lastIndexOf(const QStringRef &str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
lastIndexOf(QStringView str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
int 
lastIndexOf(const QRegExp &rx, int from = -1) const
int 
lastIndexOf(QRegExp &rx, int from = -1) const
int 
lastIndexOf(const QRegularExpression &re, int from = -1) const
int 
lastIndexOf(const QRegularExpression &re, int from, QRegularExpressionMatch *rmatch) const
QString 
left(int n) const
QString 
leftJustified(int width, QChar fill = QLatin1Char(' '), bool truncate = false) const
QStringRef 
leftRef(int n) const
int 
length() const
int 
localeAwareCompare(const QString &other) const
int 
localeAwareCompare(const QStringRef &other) const
QString 
mid(int position, int n = -1) const
QStringRef 
midRef(int position, int n = -1) const
QString 
normalized(QString::NormalizationForm mode, QChar::UnicodeVersion version = QChar::Unicode_Unassigned) const
QString &
prepend(const QString &str)
QString &
prepend(QChar ch)
QString &
prepend(const QChar *str, int len)
QString &
prepend(const QStringRef &str)
QString &
prepend(QLatin1String str)
QString &
prepend(const char *str)
QString &
prepend(const QByteArray &ba)
void 
push_back(const QString &other)
void 
push_back(QChar ch)
void 
push_front(const QString &other)
void 
push_front(QChar ch)
QString::reverse_iterator 
rbegin()
QString::const_reverse_iterator 
rbegin() const
QString &
remove(int position, int n)
QString &
remove(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QString &
remove(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QString &
remove(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QString &
remove(const QRegExp &rx)
QString &
remove(const QRegularExpression &re)
QString::reverse_iterator 
rend()
QString::const_reverse_iterator 
rend() const
QString 
repeated(int times) const
QString &
replace(int position, int n, const QString &after)
QString &
replace(int position, int n, QChar after)
QString &
replace(int position, int n, const QChar *unicode, int size)
QString &
replace(QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QString &
replace(const QChar *before, int blen, const QChar *after, int alen, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QString &
replace(QLatin1String before, QLatin1String after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QString &
replace(QLatin1String before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QString &
replace(const QString &before, QLatin1String after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QString &
replace(const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QString &
replace(QChar ch, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QString &
replace(QChar c, QLatin1String after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QString &
replace(const QRegExp &rx, const QString &after)
QString &
replace(const QRegularExpression &re, const QString &after)
void 
reserve(int size)
void 
resize(int size)
void 
resize(int size, QChar fillChar)
QString 
right(int n) const
QString 
rightJustified(int width, QChar fill = QLatin1Char(' '), bool truncate = false) const
QStringRef 
rightRef(int n) const
QString 
section(QChar sep, int start, int end = -1, QString::SectionFlags flags = SectionDefault) const
QString 
section(const QString &sep, int start, int end = -1, QString::SectionFlags flags = SectionDefault) const
QString 
section(const QRegExp &reg, int start, int end = -1, QString::SectionFlags flags = SectionDefault) const
QString 
section(const QRegularExpression &re, int start, int end = -1, QString::SectionFlags flags = SectionDefault) const
QString &
setNum(int n, int base = 10)
QString &
setNum(short n, int base = 10)
QString &
setNum(ushort n, int base = 10)
QString &
setNum(uint n, int base = 10)
QString &
setNum(long n, int base = 10)
QString &
setNum(ulong n, int base = 10)
QString &
setNum(qlonglong n, int base = 10)
QString &
setNum(qulonglong n, int base = 10)
QString &
setNum(float n, char format = 'g', int precision = 6)
QString &
setNum(double n, char format = 'g', int precision = 6)
QString &
setRawData(const QChar *unicode, int size)
QString &
setUnicode(const QChar *unicode, int size)
QString &
setUtf16(const ushort *unicode, int size)
void 
shrink_to_fit()
QString 
simplified() const
int 
size() const
QStringList 
split(const QString &sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
QStringList 
split(QChar sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
QStringList 
split(const QRegExp &rx, Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const
QStringList 
split(const QRegularExpression &re, Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const
QVector<QStringRef> 
splitRef(const QString &sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
QVector<QStringRef> 
splitRef(QChar sep, QString::SplitBehavior behavior, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
QVector<QStringRef> 
splitRef(QChar sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
QVector<QStringRef> 
splitRef(const QRegExp &rx, Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const
QVector<QStringRef> 
splitRef(const QRegularExpression &re, Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const
void 
squeeze()
bool 
startsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
startsWith(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
startsWith(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
startsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool 
startsWith(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
void 
swap(QString &other)
CFStringRef 
toCFString() const
QString 
toCaseFolded() const
double 
toDouble(bool *ok = nullptr) const
float 
toFloat(bool *ok = nullptr) const
QString 
toHtmlEscaped() const
int 
toInt(bool *ok = nullptr, int base = 10) const
QByteArray 
toLatin1() const
QByteArray 
toLocal8Bit() const
long 
toLong(bool *ok = nullptr, int base = 10) const
qlonglong 
toLongLong(bool *ok = nullptr, int base = 10) const
QString 
toLower() const
NSString *
toNSString() const
short 
toShort(bool *ok = nullptr, int base = 10) const
std::string 
toStdString() const
std::u16string 
toStdU16String() const
std::u32string 
toStdU32String() const
std::wstring 
toStdWString() const
uint 
toUInt(bool *ok = nullptr, int base = 10) const
ulong 
toULong(bool *ok = nullptr, int base = 10) const
qulonglong 
toULongLong(bool *ok = nullptr, int base = 10) const
ushort 
toUShort(bool *ok = nullptr, int base = 10) const
QVector<uint> 
toUcs4() const
QString 
toUpper() const
QByteArray 
toUtf8() const
int 
toWCharArray(wchar_t *array) const
QString 
trimmed() const
void 
truncate(int position)
const QChar *
unicode() const
const ushort *
utf16() const
bool 
operator!=(QLatin1String other) const
bool 
operator!=(const char *other) const
bool 
operator!=(const QByteArray &other) const
QString &
operator+=(QChar ch)
QString &
operator+=(const QString &other)
QString &
operator+=(const QStringRef &str)
QString &
operator+=(QLatin1String str)
QString &
operator+=(const char *str)
QString &
operator+=(const QByteArray &ba)
QString &
operator+=(char ch)
bool 
operator<(QLatin1String other) const
bool 
operator<(const char *other) const
bool 
operator<(const QByteArray &other) const
bool 
operator<=(QLatin1String other) const
bool 
operator<=(const char *other) const
bool 
operator<=(const QByteArray &other) const
QString &
operator=(QChar ch)
QString &
operator=(QLatin1String str)
QString &
operator=(const char *str)
QString &
operator=(char ch)
bool 
operator==(QLatin1String other) const
bool 
operator==(const char *other) const
bool 
operator==(const QByteArray &other) const
bool 
operator>(QLatin1String other) const
bool 
operator>(const char *other) const
bool 
operator>(const QByteArray &other) const
bool 
operator>=(QLatin1String other) const
bool 
operator>=(const char *other) const
bool 
operator>=(const QByteArray &other) const
QCharRef 
operator[](int position)
const QChar 
operator[](int position) const
const QChar 
operator[](uint position) const
QCharRef 
operator[](uint position)

Static Public Members

QString 
asprintf(const char *cformat, ...)
int 
compare(const QString &s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
int 
compare(const QString &s1, QLatin1String s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
int 
compare(QLatin1String s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
int 
compare(const QString &s1, const QStringRef &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
QString 
fromCFString(CFStringRef string)
QString 
fromLatin1(const char *str, int size = -1)
QString 
fromLatin1(const QByteArray &str)
QString 
fromLocal8Bit(const char *str, int size = -1)
QString 
fromLocal8Bit(const QByteArray &str)
QString 
fromNSString(const NSString *string)
QString 
fromRawData(const QChar *unicode, int size)
QString 
fromStdString(const std::string &str)
QString 
fromStdU16String(const std::u16string &str)
QString 
fromStdU32String(const std::u32string &str)
QString 
fromStdWString(const std::wstring &str)
QString 
fromUcs4(const uint *unicode, int size = -1)
QString 
fromUcs4(const char32_t *str, int size = -1)
QString 
fromUtf8(const char *str, int size = -1)
QString 
fromUtf8(const QByteArray &str)
QString 
fromUtf16(const ushort *unicode, int size = -1)
QString 
fromUtf16(const char16_t *str, int size = -1)
QString 
fromWCharArray(const wchar_t *string, int size = -1)
int 
localeAwareCompare(const QString &s1, const QString &s2)
int 
localeAwareCompare(const QString &s1, const QStringRef &s2)
QString 
number(long n, int base = 10)
QString 
number(int n, int base = 10)
QString 
number(uint n, int base = 10)
QString 
number(ulong n, int base = 10)
QString 
number(qlonglong n, int base = 10)
QString 
number(qulonglong n, int base = 10)
QString 
number(double n, char format = 'g', int precision = 6)
QString 
vasprintf(const char *cformat, va_list ap)

Related Non-Members

bool 
operator!=(const QString &s1, const QString &s2)
bool 
operator!=(const char *s1, const QString &s2)
const QString 
operator+(const QString &s1, const QString &s2)
const QString 
operator+(const QString &s1, const char *s2)
const QString 
operator+(const char *s1, const QString &s2)
const QString 
operator+(char ch, const QString &s)
const QString 
operator+(const QString &s, char ch)
bool 
operator<(const QString &s1, const QString &s2)
bool 
operator<(const char *s1, const QString &s2)
QDataStream &
operator<<(QDataStream &stream, const QString &string)
bool 
operator<=(const QString &s1, const QString &s2)
bool 
operator<=(const char *s1, const QString &s2)
bool 
operator==(const QString &s1, const QString &s2)
bool 
operator==(const char *s1, const QString &s2)
bool 
operator>(const QString &s1, const QString &s2)
bool 
operator>(const char *s1, const QString &s2)
bool 
operator>=(const QString &s1, const QString &s2)
bool 
operator>=(const char *s1, const QString &s2)
QDataStream &
operator>>(QDataStream &stream, QString &string)

Macros


QStringLiteral(str)

QT_NO_CAST_FROM_ASCII

QT_NO_CAST_TO_ASCII

QT_RESTRICTED_CAST_FROM_ASCII

Detailed Description
QString stores a string of 16-bit QChars, where each QChar corresponds to one UTF-16 code unit. (Unicode characters with code values above 65535 are stored using surrogate pairs, i.e., two consecutive QChars.)
Unicode is an international standard that supports most of the writing systems in use today. It is a superset of US-ASCII (ANSI X3.4-1986) and Latin-1 (ISO 8859-1), and all the US-ASCII/Latin-1 characters are available at the same code positions.
Behind the scenes, QString uses implicit sharing (copy-on-write) to reduce memory usage and to avoid the needless copying of data. This also helps reduce the inherent overhead of storing 16-bit characters instead of 8-bit characters.
In addition to QString, Qt also provides the QByteArray class to store raw bytes and traditional 8-bit '\0'-terminated strings. For most purposes, QString is the class you want to use. It is used throughout the Qt API, and the Unicode support ensures that your applications will be easy to translate if you want to expand your application's market at some point. The two main cases where QByteArray is appropriate are when you need to store raw binary data, and when memory conservation is critical (like in embedded systems). 
Initializing a String
One way to initialize a QString is simply to pass a const char * to its constructor. For example, the following code creates a QString of size 5 containing the data "Hello":
 QString str = "Hello";
QString converts the const char * data into Unicode using the fromUtf8() function.
In all of the QString functions that take const char * parameters, the const char * is interpreted as a classic C-style '\0'-terminated string encoded in UTF-8. It is legal for the const char * parameter to be nullptr.
You can also provide string data as an array of QChars:
 static const QChar data[4] = { 0x0055, 0x006e, 0x10e3, 0x03a3 };
 QString str(data, 4);
QString makes a deep copy of the QChar data, so you can modify it later without experiencing side effects. (If for performance reasons you don't want to take a deep copy of the character data, use QString::fromRawData() instead.)
Another approach is to set the size of the string using resize() and to initialize the data character per character. QString uses 0-based indexes, just like C++ arrays. To access the character at a particular index position, you can use operator[](). On non-const strings, operator[]() returns a reference to a character that can be used on the left side of an assignment. For example:
 QString str;
 str.resize(4);

 str[0] = QChar('U');
 str[1] = QChar('n');
 str[2] = QChar(0x10e3);
 str[3] = QChar(0x03a3);
For read-only access, an alternative syntax is to use the at() function:
 QString str;

 for (int i = 0; i < str.size(); ++i) {
     if (str.at(i) >= QChar('a') && str.at(i) <= QChar('f'))
         qDebug() << "Found character in range [a-f]";
 }
The at() function can be faster than operator[](), because it never causes a deep copy to occur. Alternatively, use the left(), right(), or mid() functions to extract several characters at a time.
A QString can embed '\0' characters (QChar::Null). The size() function always returns the size of the whole string, including embedded '\0' characters.
After a call to the resize() function, newly allocated characters have undefined values. To set all the characters in the string to a particular value, use the fill() function.
QString provides dozens of overloads designed to simplify string usage. For example, if you want to compare a QString with a string literal, you can write code like this and it will work as expected:
 QString str;

 if (str == "auto" || str == "extern"
         || str == "static" || str == "register") {
     // ...
 }
You can also pass string literals to functions that take QStrings as arguments, invoking the QString(const char *) constructor. Similarly, you can pass a QString to a function that takes a const char * argument using the qPrintable() macro which returns the given QString as a const char *. This is equivalent to calling <QString>.toLocal8Bit().constData(). 
Manipulating String Data
QString provides the following basic functions for modifying the character data: append(), prepend(), insert(), replace(), and remove(). For example:
 QString str = "and";
 str.prepend("rock ");     // str == "rock and"
 str.append(" roll");        // str == "rock and roll"
 str.replace(5, 3, "&");   // str == "rock & roll"
If you are building a QString gradually and know in advance approximately how many characters the QString will contain, you can call reserve(), asking QString to preallocate a certain amount of memory. You can also call capacity() to find out how much memory QString actually allocated.
The replace() and remove() functions' first two arguments are the position from which to start erasing and the number of characters that should be erased. If you want to replace all occurrences of a particular substring with another, use one of the two-parameter replace() overloads.
A frequent requirement is to remove whitespace characters from a string ('\n', '\t', ' ', etc.). If you want to remove whitespace from both ends of a QString, use the trimmed() function. If you want to remove whitespace from both ends and replace multiple consecutive whitespaces with a single space character within the string, use simplified().
If you want to find all occurrences of a particular character or substring in a QString, use the indexOf() or lastIndexOf() functions. The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here is a typical loop that finds all occurrences of a particular substring:
 QString str = "We must be <b>bold</b>, very <b>bold</b>";
 int j = 0;

 while ((j = str.indexOf("<b>", j)) != -1) {
     qDebug() << "Found <b> tag at index position" << j;
     ++j;
 }
QString provides many functions for converting numbers into strings and strings into numbers. See the arg() functions, the setNum() functions, the number() static functions, and the toInt(), toDouble(), and similar functions.
To get an upper- or lowercase version of a string use toUpper() or toLower().
Lists of strings are handled by the QStringList class. You can split a string into a list of strings using the split() function, and join a list of strings into a single string with an optional separator using QStringList::join(). You can obtain a list of strings from a string list that contain a particular substring or that match a particular QRegExp using the QStringList::filter() function. 
Querying String Data
If you want to see if a QString starts or ends with a particular substring use startsWith() or endsWith(). If you simply want to check whether a QString contains a particular character or substring, use the contains() function. If you want to find out how many times a particular character or substring occurs in the string, use count().
To obtain a pointer to the actual character data, call data() or constData(). These functions return a pointer to the beginning of the QChar data. The pointer is guaranteed to remain valid until a non-const function is called on the QString. 
Comparing Strings
QStrings can be compared using overloaded operators such as operator<(), operator<=(), operator==(), operator>=(), and so on. Note that the comparison is based exclusively on the numeric Unicode values of the characters. It is very fast, but is not what a human would expect; the QString::localeAwareCompare() function is usually a better choice for sorting user-interface strings, when such a comparison is available.
On Unix-like platforms (including Linux, macOS and iOS), when Qt is linked with the ICU library (which it usually is), its locale-aware sorting is used. Otherwise, on macOS and iOS, localeAwareCompare() compares according the "Order for sorted lists" setting in the International preferences panel. On other Unix-like systems without ICU, the comparison falls back to the system library's strcoll(), falling back when it considers strings equal to QString's (locale-unaware) comparison, described above, 
Converting Between 8-Bit Strings and Unicode Strings
QString provides the following three functions that return a const char * version of the string as QByteArray: toUtf8(), toLatin1(), and toLocal8Bit().
toLatin1() returns a Latin-1 (ISO 8859-1) encoded 8-bit string.
toUtf8() returns a UTF-8 encoded 8-bit string. UTF-8 is a superset of US-ASCII (ANSI X3.4-1986) that supports the entire Unicode character set through multibyte sequences.
toLocal8Bit() returns an 8-bit string using the system's local encoding.
To convert from one of these encodings, QString provides fromLatin1(), fromUtf8(), and fromLocal8Bit(). Other encodings are supported through the QTextCodec class.
As mentioned above, QString provides a lot of functions and operators that make it easy to interoperate with const char * strings. But this functionality is a double-edged sword: It makes QString more convenient to use if all strings are US-ASCII or Latin-1, but there is always the risk that an implicit conversion from or to const char * is done using the wrong 8-bit encoding. To minimize these risks, you can turn off these implicit conversions by defining the following two preprocessor symbols:
QT_NO_CAST_FROM_ASCII disables automatic conversions from C string literals and pointers to Unicode.
QT_RESTRICTED_CAST_FROM_ASCII allows automatic conversions from C characters and character arrays, but disables automatic conversions from character pointers to Unicode.
QT_NO_CAST_TO_ASCII disables automatic conversion from QString to C strings.
One way to define these preprocessor symbols globally for your application is to add the following entry to your qmake project file:
 DEFINES += QT_NO_CAST_FROM_ASCII \
            QT_NO_CAST_TO_ASCII
You then need to explicitly call fromUtf8(), fromLatin1(), or fromLocal8Bit() to construct a QString from an 8-bit string, or use the lightweight QLatin1String class, for example:
 QString url = QLatin1String("http://www.unicode.org/");
Similarly, you must call toLatin1(), toUtf8(), or toLocal8Bit() explicitly to convert the QString to an 8-bit string. (Other encodings are supported through the QTextCodec class.)

Note for C Programmers
Due to C++'s type system and the fact that QString is implicitly shared, QStrings may be treated like ints or other basic types. For example:
 QString Widget::boolToString(bool b)
 {
     QString result;
     if (b)
         result = "True";
     else
         result = "False";
     return result;
 }
The result variable, is a normal variable allocated on the stack. When return is called, and because we're returning by value, the copy constructor is called and a copy of the string is returned. No actual copying takes place thanks to the implicit sharing.

Distinction Between Null and Empty Strings
For historical reasons, QString distinguishes between a null string and an empty string. A null string is a string that is initialized using QString's default constructor or by passing (const char *)0 to the constructor. An empty string is any string with size 0. A null string is always empty, but an empty string isn't necessarily null:
 QString().isNull();               // returns true
 QString().isEmpty();              // returns true

 QString("").isNull();             // returns false
 QString("").isEmpty();            // returns true

 QString("abc").isNull();          // returns false
 QString("abc").isEmpty();         // returns false
All functions except isNull() treat null strings the same as empty strings. For example, toUtf8().constData() returns a valid pointer (not nullptr) to a '\0' character for a null string. We recommend that you always use the isEmpty() function and avoid isNull(). 
Argument Formats
In member functions where an argument format can be specified (e.g., arg(), number()), the argument format can be one of the following:

Format
Meaning
e
format as [-]9.9e[+|-]999
E
format as [-]9.9E[+|-]999
f
format as [-]9.9
g
use e or f format, whichever is the most concise
G
use E or f format, whichever is the most concise

A precision is also specified with the argument format. For the 'e', 'E', and 'f' formats, the precision represents the number of digits after the decimal point. For the 'g' and 'G' formats, the precision represents the maximum number of significant digits (trailing zeroes are omitted). 
More Efficient String Construction
Many strings are known at compile time. But the trivial constructor QString("Hello"), will copy the contents of the string, treating the contents as Latin-1. To avoid this one can use the QStringLiteral macro to directly create the required data at compile time. Constructing a QString out of the literal does then not cause any overhead at runtime.
A slightly less efficient way is to use QLatin1String. This class wraps a C string literal, precalculates it length at compile time and can then be used for faster comparison with QStrings and conversion to QStrings than a regular C string literal.
Using the QString '+' operator, it is easy to construct a complex string from multiple substrings. You will often write code like this:
     QString foo;
     QString type = "long";

     foo->setText(QLatin1String("vector<") + type + QLatin1String(">::iterator"));

     if (foo.startsWith("(" + type + ") 0x"))
         ...
There is nothing wrong with either of these string constructions, but there are a few hidden inefficiencies. Beginning with Qt 4.6, you can eliminate them.
First, multiple uses of the '+' operator usually means multiple memory allocations. When concatenating n substrings, where n > 2, there can be as many as n - 1 calls to the memory allocator.
In 4.6, an internal template class QStringBuilder has been added along with a few helper functions. This class is marked internal and does not appear in the documentation, because you aren't meant to instantiate it in your code. Its use will be automatic, as described below. The class is found in src/corelib/tools/qstringbuilder.cpp if you want to have a look at it.
QStringBuilder uses expression templates and reimplements the '%' operator so that when you use '%' for string concatenation instead of '+', multiple substring concatenations will be postponed until the final result is about to be assigned to a QString. At this point, the amount of memory required for the final result is known. The memory allocator is then called once to get the required space, and the substrings are copied into it one by one.
Additional efficiency is gained by inlining and reduced reference counting (the QString created from a QStringBuilder typically has a ref count of 1, whereas QString::append() needs an extra test).
There are two ways you can access this improved method of string construction. The straightforward way is to include QStringBuilder wherever you want to use it, and use the '%' operator instead of '+' when concatenating strings:
     #include <QStringBuilder>

     QString hello("hello");
     QStringRef el(&hello, 2, 3);
     QLatin1String world("world");
     QString message =  hello % el % world % QChar('!');
A more global approach which is the most convenient but not entirely source compatible, is to this define in your .pro file:
     DEFINES *= QT_USE_QSTRINGBUILDER
and the '+' will automatically be performed as the QStringBuilder '%' everywhere. 
Maximum size and out-of-memory conditions
The current version of QString is limited to just under 2 GB (2^31 bytes) in size. The exact value is architecture-dependent, since it depends on the overhead required for managing the data block, but is no more than 32 bytes. Raw data blocks are also limited by the use of int type in the current version to 2 GB minus 1 byte. Since QString uses two bytes per character, that translates to just under 2^30 characters in one QString.
In case memory allocation fails, QString will throw a std::bad_alloc exception. Out of memory conditions in the Qt containers are the only case where Qt will throw exceptions.
Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the Qt API.
See also fromRawData(), QChar, QLatin1String, QByteArray, and QStringRef.
Member Type Documentation
typedef QString::ConstIterator
Qt-style synonym for QString::const_iterator.
typedef QString::Iterator
Qt-style synonym for QString::iterator.
enum QString::NormalizationForm
This enum describes the various normalized forms of Unicode text.

Constant
Value
Description
QString::NormalizationForm_D
0
Canonical Decomposition
QString::NormalizationForm_C
1
Canonical Decomposition followed by Canonical Composition
QString::NormalizationForm_KD
2
Compatibility Decomposition
QString::NormalizationForm_KC
3
Compatibility Decomposition followed by Canonical Composition

See also normalized() and Unicode Standard Annex #15.
enum QString::SectionFlag
flags QString::SectionFlags
This enum specifies flags that can be used to affect various aspects of the section() function's behavior with respect to separators and empty fields.

Constant
Value
Description
QString::SectionDefault
0x00
Empty fields are counted, leading and trailing separators are not included, and the separator is compared case sensitively.
QString::SectionSkipEmpty
0x01
Treat empty fields as if they don't exist, i.e. they are not considered as far as start and end are concerned.
QString::SectionIncludeLeadingSep
0x02
Include the leading separator (if any) in the result string.
QString::SectionIncludeTrailingSep
0x04
Include the trailing separator (if any) in the result string.
QString::SectionCaseInsensitiveSeps
0x08
Compare the separator case-insensitively.

The SectionFlags type is a typedef for QFlags<SectionFlag>. It stores an OR combination of SectionFlag values.
See also section().
typedef QString::const_iterator
See also QString::iterator.
typedef QString::const_pointer
The QString::const_pointer typedef provides an STL-style const pointer to a QString element (QChar).
typedef QString::const_reference
typedef QString::const_reverse_iterator
This typedef was introduced in Qt 5.6.
See also QString::reverse_iterator and QString::const_iterator.
typedef QString::difference_type
typedef QString::iterator
See also QString::const_iterator.
typedef QString::pointer
The QString::const_pointer typedef provides an STL-style pointer to a QString element (QChar).
typedef QString::reference
typedef QString::reverse_iterator
This typedef was introduced in Qt 5.6.
See also QString::const_reverse_iterator and QString::iterator.
typedef QString::size_type
typedef QString::value_type
Member Function Documentation
template <typename Args> QString QString::arg(Args &&... args) const
Replaces occurrences of %N in this string with the corresponding argument from args. The arguments are not positional: the first of the args replaces the %N with the lowest N (all of them), the second of the args the %N with the next-lowest N etc.
Args can consist of anything that implicitly converts to QString, QStringView or QLatin1String.
In addition, the following types are also supported: QChar, QLatin1Char.
This function was introduced in Qt 5.14.
See also QString::arg().
QString::QString(const QByteArray &ba)
Constructs a string initialized with the byte array ba. The given byte array is converted to Unicode using fromUtf8(). Stops copying at the first 0 character, otherwise copies the entire byte array.
You can disable this constructor by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also fromLatin1(), fromLocal8Bit(), fromUtf8(), and QT_NO_CAST_FROM_ASCII.
QString::QString(const char *str)
Constructs a string initialized with the 8-bit string str. The given const char pointer is converted to Unicode using the fromUtf8() function.
You can disable this constructor by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
Note: Defining QT_RESTRICTED_CAST_FROM_ASCII also disables this constructor, but enables a QString(const char (&ch)[N]) constructor instead. Using non-literal input, or input with embedded NUL characters, or non-7-bit characters is undefined in this case.
See also fromLatin1(), fromLocal8Bit(), fromUtf8(), QT_NO_CAST_FROM_ASCII, and QT_RESTRICTED_CAST_FROM_ASCII.
QString::QString(QString &&other)
Move-constructs a QString instance, making it point at the same object that other was pointing to.
This function was introduced in Qt 5.2.
QString::QString(const QString &other)
Constructs a copy of other.
This operation takes constant time, because QString is implicitly shared. This makes returning a QString from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes linear time.
See also operator=().
QString::QString(QLatin1String str)
Constructs a copy of the Latin-1 string str.
See also fromLatin1().
QString::QString(int size, QChar ch)
Constructs a string of the given size with every character set to ch.
See also fill().
QString::QString(QChar ch)
Constructs a string of size 1 containing the character ch.
QString::QString(const QChar *unicode, int size = -1)
Constructs a string initialized with the first size characters of the QChar array unicode.
If unicode is 0, a null string is constructed.
If size is negative, unicode is assumed to point to a \0'-terminated array and its length is determined dynamically. The terminating null character is not considered part of the string.
QString makes a deep copy of the string data. The unicode data is copied as is and the Byte Order Mark is preserved if present.
See also fromRawData().
QString::QString()
Constructs a null string. Null strings are also empty.
See also isEmpty().
QString &QString::operator=(const QByteArray &ba)
This function overloads operator=().
Assigns ba to this string. The byte array is converted to Unicode using the fromUtf8() function. This function stops conversion at the first NUL character found, or the end of the ba byte array.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
QString &QString::operator=(QString &&other)
Move-assigns other to this QString instance.
This function was introduced in Qt 5.2.
QString &QString::operator=(const QString &other)
Assigns other to this string and returns a reference to this string.
QString::~QString()
Destroys the string.
QString &QString::append(const QString &str)
Appends the string str onto the end of this string.
Example:
 QString x = "free";
 QString y = "dom";

 x.append(y);
 // x == "freedom"
This is the same as using the insert() function:
 x.insert(x.size(), y);
The append() function is typically very fast (constant time), because QString preallocates extra space at the end of the string data so it can grow without reallocating the entire string each time.
See also operator+=(), prepend(), and insert().
QString &QString::append(QChar ch)
This function overloads append().
Appends the character ch to this string.
QString &QString::append(const QChar *str, int len)
This function overloads append().
Appends len characters from the QChar array str to this string.
This function was introduced in Qt 5.0.
QString &QString::append(const QStringRef &reference)
Appends the given string reference to this string and returns the result.
This function was introduced in Qt 4.4.
QString &QString::append(QLatin1String str)
This function overloads append().
Appends the Latin-1 string str to this string.
QString &QString::append(const char *str)
This function overloads append().
Appends the string str to this string. The given const char pointer is converted to Unicode using the fromUtf8() function.
You can disable this function by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
QString &QString::append(const QByteArray &ba)
This function overloads append().
Appends the byte array ba to this string. The given byte array is converted to Unicode using the fromUtf8() function.
You can disable this function by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
QString QString::arg(const QString &a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const
Returns a copy of this string with the lowest numbered place marker replaced by string a, i.e., %1, %2, ..., %99.
fieldWidth specifies the minimum amount of space that argument a shall occupy. If a requires less space than fieldWidth, it is padded to fieldWidth with character fillChar. A positive fieldWidth produces right-aligned text. A negative fieldWidth produces left-aligned text.
This example shows how we might create a status string for reporting progress while processing a list of files:
 QString i;           // current file's number
 QString total;       // number of files to process
 QString fileName;    // current file's name

 QString status = QString("Processing file %1 of %2: %3")
                 .arg(i).arg(total).arg(fileName);
First, arg(i) replaces %1. Then arg(total) replaces %2. Finally, arg(fileName) replaces %3.
One advantage of using arg() over asprintf() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest numbered unreplaced place marker, no matter where it appears. Also, if place marker %i appears more than once in the string, the arg() replaces all of them.
If there is no unreplaced place marker remaining, a warning message is output and the result is undefined. Place marker numbers must be in the range 1 to 99.
QString QString::arg(qlonglong a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
This function overloads arg().
fieldWidth specifies the minimum amount of space that a is padded to and filled with the character fillChar. A positive value produces right-aligned text; a negative value produces left-aligned text.
The base argument specifies the base to use when converting the integer a into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
If fillChar is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.
QString QString::arg(qulonglong a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
This function overloads arg().
fieldWidth specifies the minimum amount of space that a is padded to and filled with the character fillChar. A positive value produces right-aligned text; a negative value produces left-aligned text.
The base argument specifies the base to use when converting the integer a into a string. base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
If fillChar is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.
QString QString::arg(long a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
This function overloads arg().
fieldWidth specifies the minimum amount of space that a is padded to and filled with the character fillChar. A positive value produces right-aligned text; a negative value produces left-aligned text.
The a argument is expressed in the given base, which is 10 by default and must be between 2 and 36.
The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of a. The conversion uses the default locale. The default locale is determined from the system's locale settings at application startup. It can be changed using QLocale::setDefault(). The 'L' flag is ignored if base is not 10.
 QString str;
 str = QString("Decimal 63 is %1 in hexadecimal")
         .arg(63, 0, 16);
 // str == "Decimal 63 is 3f in hexadecimal"

 QLocale::setDefault(QLocale(QLocale::English, QLocale::UnitedStates));
 str = QString("%1 %L2 %L3")
         .arg(12345)
         .arg(12345)
         .arg(12345, 0, 16);
 // str == "12345 12,345 3039"
If fillChar is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.
QString QString::arg(ulong a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
This function overloads arg().
fieldWidth specifies the minimum amount of space that a is padded to and filled with the character fillChar. A positive value produces right-aligned text; a negative value produces left-aligned text.
The base argument specifies the base to use when converting the integer a to a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
If fillChar is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.
QString QString::arg(int a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
This function overloads arg().
The a argument is expressed in base base, which is 10 by default and must be between 2 and 36. For bases other than 10, a is treated as an unsigned integer.
fieldWidth specifies the minimum amount of space that a is padded to and filled with the character fillChar. A positive value produces right-aligned text; a negative value produces left-aligned text.
The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of a. The conversion uses the default locale, set by QLocale::setDefault(). If no default locale was specified, the "C" locale is used. The 'L' flag is ignored if base is not 10.
 QString str;
 str = QString("Decimal 63 is %1 in hexadecimal")
         .arg(63, 0, 16);
 // str == "Decimal 63 is 3f in hexadecimal"

 QLocale::setDefault(QLocale(QLocale::English, QLocale::UnitedStates));
 str = QString("%1 %L2 %L3")
         .arg(12345)
         .arg(12345)
         .arg(12345, 0, 16);
 // str == "12345 12,345 3039"
If fillChar is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.
QString QString::arg(uint a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
This function overloads arg().
The base argument specifies the base to use when converting the integer a into a string. The base must be between 2 and 36.
If fillChar is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.
QString QString::arg(short a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
This function overloads arg().
fieldWidth specifies the minimum amount of space that a is padded to and filled with the character fillChar. A positive value produces right-aligned text; a negative value produces left-aligned text.
The base argument specifies the base to use when converting the integer a into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
If fillChar is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.
QString QString::arg(ushort a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char(' ')) const
This function overloads arg().
fieldWidth specifies the minimum amount of space that a is padded to and filled with the character fillChar. A positive value produces right-aligned text; a negative value produces left-aligned text.
The base argument specifies the base to use when converting the integer a into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
If fillChar is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.
QString QString::arg(double a, int fieldWidth = 0, char format = 'g', int precision = -1, QChar fillChar = QLatin1Char(' ')) const
This function overloads arg().
Argument a is formatted according to the specified format and precision. See Argument Formats for details.
fieldWidth specifies the minimum amount of space that a is padded to and filled with the character fillChar. A positive value produces right-aligned text; a negative value produces left-aligned text.
 double d = 12.34;
 QString str = QString("delta: %1").arg(d, 0, 'E', 3);
 // str == "delta: 1.234E+01"
The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of a. The conversion uses the default locale, set by QLocale::setDefault(). If no default locale was specified, the "C" locale is used.
If fillChar is '0' (the number 0, ASCII 48), this function will use the locale's zero to pad. For negative numbers, the zero padding will probably appear before the minus sign.
See also QLocale::toString().
QString QString::arg(char a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const
This function overloads arg().
The a argument is interpreted as a Latin-1 character.
QString QString::arg(QChar a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const
This function overloads arg().
QString QString::arg(QStringView a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const
This is an overloaded function.
Returns a copy of this string with the lowest-numbered place-marker replaced by string a, i.e., %1, %2, ..., %99.
fieldWidth specifies the minimum amount of space that a shall occupy. If a requires less space than fieldWidth, it is padded to fieldWidth with character fillChar. A positive fieldWidth produces right-aligned text. A negative fieldWidth produces left-aligned text.
This example shows how we might create a status string for reporting progress while processing a list of files:
 int i;                // current file's number
 int total;            // number of files to process
 QStringView fileName; // current file's name

 QString status = QString("Processing file %1 of %2: %3")
                 .arg(i).arg(total).arg(fileName);
First, arg(i) replaces %1. Then arg(total) replaces %2. Finally, arg(fileName) replaces %3.
One advantage of using arg() over asprintf() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest-numbered unreplaced place-marker, no matter where it appears. Also, if place-marker %i appears more than once in the string, arg() replaces all of them.
If there is no unreplaced place-marker remaining, a warning message is printed and the result is undefined. Place-marker numbers must be in the range 1 to 99.
This function was introduced in Qt 5.10.
QString QString::arg(QLatin1String a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const
This is an overloaded function.
Returns a copy of this string with the lowest-numbered place-marker replaced by string a, i.e., %1, %2, ..., %99.
fieldWidth specifies the minimum amount of space that a shall occupy. If a requires less space than fieldWidth, it is padded to fieldWidth with character fillChar. A positive fieldWidth produces right-aligned text. A negative fieldWidth produces left-aligned text.
One advantage of using arg() over asprintf() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest-numbered unreplaced place-marker, no matter where it appears. Also, if place-marker %i appears more than once in the string, arg() replaces all of them.
If there is no unreplaced place-marker remaining, a warning message is printed and the result is undefined. Place-marker numbers must be in the range 1 to 99.
This function was introduced in Qt 5.10.
QString QString::arg(const QString &a1, const QString &a2) const
This function overloads arg().
This is the same as str.arg(a1).arg(a2), except that the strings a1 and a2 are replaced in one pass. This can make a difference if a1 contains e.g. %1:
 QString str;
 str = "%1 %2";

 str.arg("%1f", "Hello");        // returns "%1f Hello"
 str.arg("%1f").arg("Hello");    // returns "Hellof %2"
A similar problem occurs when the numbered place markers are not white space separated:
 QString str;
 str = "%1%3%2";
 str.arg("Hello").arg(20).arg(50); // returns "Hello500"

 str = "%1%2%3";
 str.arg("Hello").arg(50).arg(20); // returns "Hello5020"
Let's look at the substitutions:
First, Hello replaces %1 so the string becomes "Hello%3%2".
Then, 20 replaces %2 so the string becomes "Hello%320".
Since the maximum numbered place marker value is 99, 50 replaces %32.
Thus the string finally becomes "Hello500".
In such cases, the following yields the expected results:
 QString str;
 str = "%1%3%2";
 str.arg("Hello", QString::number(20), QString::number(50)); // returns "Hello5020"
QString QString::arg(const QString &a1, const QString &a2, const QString &a3) const
This function overloads arg().
This is the same as calling str.arg(a1).arg(a2).arg(a3), except that the strings a1, a2 and a3 are replaced in one pass.
QString QString::arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4) const
This function overloads arg().
This is the same as calling str.arg(a1).arg(a2).arg(a3).arg(a4), except that the strings a1, a2, a3 and a4 are replaced in one pass.
QString QString::arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5) const
This function overloads arg().
This is the same as calling str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5), except that the strings a1, a2, a3, a4, and a5 are replaced in one pass.
QString QString::arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5, const QString &a6) const
This function overloads arg().
This is the same as calling str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6)), except that the strings a1, a2, a3, a4, a5, and a6 are replaced in one pass.
QString QString::arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5, const QString &a6, const QString &a7) const
This function overloads arg().
This is the same as calling str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7), except that the strings a1, a2, a3, a4, a5, a6, and a7 are replaced in one pass.
QString QString::arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5, const QString &a6, const QString &a7, const QString &a8) const
This function overloads arg().
This is the same as calling str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8), except that the strings a1, a2, a3, a4, a5, a6, a7, and a8 are replaced in one pass.
QString QString::arg(const QString &a1, const QString &a2, const QString &a3, const QString &a4, const QString &a5, const QString &a6, const QString &a7, const QString &a8, const QString &a9) const
This function overloads arg().
This is the same as calling str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9), except that the strings a1, a2, a3, a4, a5, a6, a7, a8, and a9 are replaced in one pass.
[static] QString QString::asprintf(const char *cformat, ...)
Safely builds a formatted string from the format string cformat and an arbitrary list of arguments.
The format string supports the conversion specifiers, length modifiers, and flags provided by printf() in the standard C++ library. The cformat string and %s arguments must be UTF-8 encoded.
Note: The %lc escape sequence expects a unicode character of type char16_t, or ushort (as returned by QChar::unicode()). The %ls escape sequence expects a pointer to a zero-terminated array of unicode characters of type char16_t, or ushort (as returned by QString::utf16()). This is at odds with the printf() in the standard C++ library, which defines %lc to print a wchar_t and %ls to print a wchar_t*, and might also produce compiler warnings on platforms where the size of wchar_t is not 16 bits.
Warning: We do not recommend using QString::asprintf() in new Qt code. Instead, consider using QTextStream or arg(), both of which support Unicode strings seamlessly and are type-safe. Here is an example that uses QTextStream:
 QString result;
 QTextStream(&result) << "pi = " << 3.14;
 // result == "pi = 3.14"
For translations, especially if the strings contains more than one escape sequence, you should consider using the arg() function instead. This allows the order of the replacements to be controlled by the translator.
This function was introduced in Qt 5.5.
See also arg().
const QChar QString::at(int position) const
Returns the character at the given index position in the string.
The position must be a valid index position in the string (i.e., 0 <= position < size()).
See also operator[]().
QChar QString::back() const
Returns the last character in the string. Same as at(size() - 1).
This function is provided for STL compatibility.
Warning: Calling this function on an empty string constitutes undefined behavior.
This function was introduced in Qt 5.10.
See also front(), at(), and operator[]().
QCharRef QString::back()
Returns a reference to the last character in the string. Same as operator[](size() - 1).
This function is provided for STL compatibility.
Warning: Calling this function on an empty string constitutes undefined behavior.
This function was introduced in Qt 5.10.
See also front(), at(), and operator[]().
QString::iterator QString::begin()
Returns an STL-style iterator pointing to the first character in the string.
See also constBegin() and end().
QString::const_iterator QString::begin() const
This function overloads begin().
int QString::capacity() const
Returns the maximum number of characters that can be stored in the string without forcing a reallocation.
The sole purpose of this function is to provide a means of fine tuning QString's memory usage. In general, you will rarely ever need to call this function. If you want to know how many characters are in the string, call size().
See also reserve() and squeeze().
QString::const_iterator QString::cbegin() const
Returns a const STL-style iterator pointing to the first character in the string.
This function was introduced in Qt 5.0.
See also begin() and cend().
QString::const_iterator QString::cend() const
Returns a const STL-style iterator pointing to the imaginary character after the last character in the list.
This function was introduced in Qt 5.0.
See also cbegin() and end().
void QString::chop(int n)
Removes n characters from the end of the string.
If n is greater than or equal to size(), the result is an empty string; if n is negative, it is equivalent to passing zero.
Example:
 QString str("LOGOUT\r\n");
 str.chop(2);
 // str == "LOGOUT"
If you want to remove characters from the beginning of the string, use remove() instead.
See also truncate(), resize(), remove(), and QStringRef::chop().
QString QString::chopped(int len) const
Returns a substring that contains the size() - len leftmost characters of this string.
Note: The behavior is undefined if len is negative or greater than size().
This function was introduced in Qt 5.10.
See also endsWith(), left(), right(), mid(), chop(), and truncate().
void QString::clear()
Clears the contents of the string and makes it null.
See also resize() and isNull().
[static] int QString::compare(const QString &s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
Compares s1 with s2 and returns an integer less than, equal to, or greater than zero if s1 is less than, equal to, or greater than s2.
If cs is Qt::CaseSensitive, the comparison is case sensitive; otherwise the comparison is case insensitive.
Case sensitive comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-visible strings with localeAwareCompare().
 int x = QString::compare("aUtO", "AuTo", Qt::CaseInsensitive);  // x == 0
 int y = QString::compare("auto", "Car", Qt::CaseSensitive);     // y > 0
 int z = QString::compare("auto", "Car", Qt::CaseInsensitive);   // z < 0
This function was introduced in Qt 4.2.
See also operator==(), operator<(), operator>(), and Comparing Strings.
int QString::compare(const QString &other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads compare().
Lexically compares this string with the other string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the other string.
Same as compare(*this, other, cs).
This function was introduced in Qt 4.2.
int QString::compare(const QStringRef &ref, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads compare().
Compares the string reference, ref, with the string and returns an integer less than, equal to, or greater than zero if the string is less than, equal to, or greater than ref.
int QString::compare(QLatin1String other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads compare().
Same as compare(*this, other, cs).
This function was introduced in Qt 4.2.
int QString::compare(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads compare().
Performs a comparison of this with s, using the case sensitivity setting cs.
This function was introduced in Qt 5.12.
int QString::compare(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads compare().
Performs a comparison of this with ch, using the case sensitivity setting cs.
This function was introduced in Qt 5.14.
[static] int QString::compare(const QString &s1, QLatin1String s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
This function overloads compare().
Performs a comparison of s1 and s2, using the case sensitivity setting cs.
This function was introduced in Qt 4.2.
[static] int QString::compare(QLatin1String s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
This function overloads compare().
Performs a comparison of s1 and s2, using the case sensitivity setting cs.
This function was introduced in Qt 4.2.
[static] int QString::compare(const QString &s1, const QStringRef &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
This function overloads compare().
QString::const_iterator QString::constBegin() const
Returns a const STL-style iterator pointing to the first character in the string.
See also begin() and constEnd().
const QChar *QString::constData() const
Returns a pointer to the data stored in the QString. The pointer can be used to access the characters that compose the string.
Note that the pointer remains valid only as long as the string is not modified.
Note: The returned string may not be '\0'-terminated. Use size() to determine the length of the array.
See also data(), operator[](), and fromRawData().
QString::const_iterator QString::constEnd() const
Returns a const STL-style iterator pointing to the imaginary character after the last character in the list.
See also constBegin() and end().
bool QString::contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
Returns true if this string contains an occurrence of the string str; otherwise returns false.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
Example:
 QString str = "Peter Pan";
 str.contains("peter", Qt::CaseInsensitive);    // returns true
See also indexOf() and count().
bool QString::contains(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads contains().
Returns true if this string contains an occurrence of the character ch; otherwise returns false.
bool QString::contains(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
Returns true if this string contains an occurrence of the string reference str; otherwise returns false.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
This function was introduced in Qt 4.8.
See also indexOf() and count().
bool QString::contains(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads contains().
Returns true if this string contains an occurrence of the latin-1 string str; otherwise returns false.
This function was introduced in Qt 5.3.
bool QString::contains(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads contains().
Returns true if this string contains an occurrence of the string view str; otherwise returns false.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
This function was introduced in Qt 5.14.
See also indexOf() and count().
bool QString::contains(const QRegExp &rx) const
This function overloads contains().
Returns true if the regular expression rx matches somewhere in this string; otherwise returns false.
bool QString::contains(QRegExp &rx) const
This function overloads contains().
Returns true if the regular expression rx matches somewhere in this string; otherwise returns false.
If there is a match, the rx regular expression will contain the matched captures (see QRegExp::matchedLength, QRegExp::cap).
This function was introduced in Qt 4.5.
bool QString::contains(const QRegularExpression &re) const
This function overloads contains().
Returns true if the regular expression re matches somewhere in this string; otherwise returns false.
This function was introduced in Qt 5.0.
bool QString::contains(const QRegularExpression &re, QRegularExpressionMatch *rmatch) const
This function overloads contains().
Returns true if the regular expression re matches somewhere in this string; otherwise returns false.
If the match is successful and rmatch is not nullptr, it also writes the results of the match into the QRegularExpressionMatch object pointed to by rmatch.
This function was introduced in Qt 5.1.
See also QRegularExpression::match().
int QString::count(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
Returns the number of (potentially overlapping) occurrences of the string str in this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
See also contains() and indexOf().
int QString::count() const
This function overloads count().
Same as size().
int QString::count(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads count().
Returns the number of occurrences of character ch in the string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
See also contains() and indexOf().
int QString::count(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads count().
Returns the number of (potentially overlapping) occurrences of the string reference str in this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
This function was introduced in Qt 4.8.
See also contains() and indexOf().
int QString::count(const QRegExp &rx) const
This function overloads count().
Returns the number of times the regular expression rx matches in the string.
This function counts overlapping matches, so in the example below, there are four instances of "ana" or "ama":
 QString str = "banana and panama";
 str.count(QRegExp("a[nm]a"));    // returns 4
int QString::count(const QRegularExpression &re) const
This function overloads count().
Returns the number of times the regular expression re matches in the string.
This function counts overlapping matches, so in the example below, there are four instances of "ana" or "ama":
 QString str = "banana and panama";
 str.count(QRegularExpression("a[nm]a"));    // returns 4
This function was introduced in Qt 5.0.
QString::const_reverse_iterator QString::crbegin() const
Returns a const STL-style reverse iterator pointing to the first character in the string, in reverse order.
This function was introduced in Qt 5.6.
See also begin(), rbegin(), and rend().
QString::const_reverse_iterator QString::crend() const
Returns a const STL-style reverse iterator pointing to one past the last character in the string, in reverse order.
This function was introduced in Qt 5.6.
See also end(), rend(), and rbegin().
QChar *QString::data()
Returns a pointer to the data stored in the QString. The pointer can be used to access and modify the characters that compose the string.
Unlike constData() and unicode(), the returned data is always '\0'-terminated.
Example:
 QString str = "Hello world";
 QChar *data = str.data();
 while (!data->isNull()) {
     qDebug() << data->unicode();
     ++data;
 }
Note that the pointer remains valid only as long as the string is not modified by other means. For read-only access, constData() is faster because it never causes a deep copy to occur.
See also constData() and operator[]().
const QChar *QString::data() const
This is an overloaded function.
Note: The returned string may not be '\0'-terminated. Use size() to determine the length of the array.
See also fromRawData().
QString::iterator QString::end()
Returns an STL-style iterator pointing to the imaginary character after the last character in the string.
See also begin() and constEnd().
QString::const_iterator QString::end() const
This function overloads end().
bool QString::endsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
Returns true if the string ends with s; otherwise returns false.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
 QString str = "Bananas";
 str.endsWith("anas");         // returns true
 str.endsWith("pple");         // returns false
See also startsWith().
bool QString::endsWith(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads endsWith().
Returns true if the string ends with the string reference s; otherwise returns false.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
This function was introduced in Qt 4.8.
See also startsWith().
bool QString::endsWith(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads endsWith().
Returns true if the string ends with the string view str; otherwise returns false.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
This function was introduced in Qt 5.10.
See also startsWith().
bool QString::endsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads endsWith().
bool QString::endsWith(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
Returns true if the string ends with c; otherwise returns false.
This function overloads endsWith().
QString &QString::fill(QChar ch, int size = -1)
Sets every character in the string to character ch. If size is different from -1 (default), the string is resized to size beforehand.
Example:
 QString str = "Berlin";
 str.fill('z');
 // str == "zzzzzz"

 str.fill('A', 2);
 // str == "AA"
See also resize().
[static] QString QString::fromCFString(CFStringRef string)
Constructs a new QString containing a copy of the string CFString.
Note: this function is only available on OS X and iOS.
This function was introduced in Qt 5.2.
[static] QString QString::fromLatin1(const char *str, int size = -1)
Returns a QString initialized with the first size characters of the Latin-1 string str.
If size is -1 (default), it is taken to be strlen(str).
See also toLatin1(), fromUtf8(), and fromLocal8Bit().
[static] QString QString::fromLatin1(const QByteArray &str)
This is an overloaded function.
Returns a QString initialized with the Latin-1 string str.
This function was introduced in Qt 5.0.
[static] QString QString::fromLocal8Bit(const char *str, int size = -1)
Returns a QString initialized with the first size characters of the 8-bit string str.
If size is -1 (default), it is taken to be strlen(str).
QTextCodec::codecForLocale() is used to perform the conversion.
See also toLocal8Bit(), fromLatin1(), and fromUtf8().
[static] QString QString::fromLocal8Bit(const QByteArray &str)
This is an overloaded function.
Returns a QString initialized with the 8-bit string str.
This function was introduced in Qt 5.0.
[static] QString QString::fromNSString(const NSString *string)
Constructs a new QString containing a copy of the string NSString.
Note: this function is only available on OS X and iOS.
This function was introduced in Qt 5.2.
[static] QString QString::fromRawData(const QChar *unicode, int size)
Constructs a QString that uses the first size Unicode characters in the array unicode. The data in unicode is not copied. The caller must be able to guarantee that unicode will not be deleted or modified as long as the QString (or an unmodified copy of it) exists.
Any attempts to modify the QString or copies of it will cause it to create a deep copy of the data, ensuring that the raw data isn't modified.
Here is an example of how we can use a QRegularExpression on raw data in memory without requiring to copy the data into a QString:
 QRegularExpression pattern("\u00A4");
 static const QChar unicode[] = {
         0x005A, 0x007F, 0x00A4, 0x0060,
         0x1009, 0x0020, 0x0020};
 int size = sizeof(unicode) / sizeof(QChar);

 QString str = QString::fromRawData(unicode, size);
 if (str.contains(pattern) {
     // ...
 }
Warning: A string created with fromRawData() is not '\0'-terminated, unless the raw data contains a '\0' character at position size. This means unicode() will not return a '\0'-terminated string (although utf16() does, at the cost of copying the raw data).
See also fromUtf16() and setRawData().
[static] QString QString::fromStdString(const std::string &str)
Returns a copy of the str string. The given string is converted to Unicode using the fromUtf8() function.
See also fromLatin1(), fromLocal8Bit(), fromUtf8(), and QByteArray::fromStdString().
[static] QString QString::fromStdU16String(const std::u16string &str)
Returns a copy of the str string. The given string is assumed to be encoded in UTF-16.
This function was introduced in Qt 5.5.
See also fromUtf16(), fromStdWString(), and fromStdU32String().
[static] QString QString::fromStdU32String(const std::u32string &str)
Returns a copy of the str string. The given string is assumed to be encoded in UCS-4.
This function was introduced in Qt 5.5.
See also fromUcs4(), fromStdWString(), and fromStdU16String().
[static] QString QString::fromStdWString(const std::wstring &str)
Returns a copy of the str string. The given string is assumed to be encoded in utf16 if the size of wchar_t is 2 bytes (e.g. on windows) and ucs4 if the size of wchar_t is 4 bytes (most Unix systems).
See also fromUtf16(), fromLatin1(), fromLocal8Bit(), fromUtf8(), fromUcs4(), fromStdU16String(), and fromStdU32String().
[static] QString QString::fromUcs4(const uint *unicode, int size = -1)
Returns a QString initialized with the first size characters of the Unicode string unicode (ISO-10646-UCS-4 encoded).
If size is -1 (default), unicode must be \0'-terminated.
This function was introduced in Qt 4.2.
See also toUcs4(), fromUtf16(), utf16(), setUtf16(), fromWCharArray(), and fromStdU32String().
[static] QString QString::fromUcs4(const char32_t *str, int size = -1)
Returns a QString initialized with the first size characters of the Unicode string str (ISO-10646-UCS-4 encoded).
If size is -1 (default), str must be \0'-terminated.
This function was introduced in Qt 5.3.
See also toUcs4(), fromUtf16(), utf16(), setUtf16(), fromWCharArray(), and fromStdU32String().
[static] QString QString::fromUtf8(const char *str, int size = -1)
Returns a QString initialized with the first size bytes of the UTF-8 string str.
If size is -1 (default), it is taken to be strlen(str).
UTF-8 is a Unicode codec and can represent all characters in a Unicode string like QString. However, invalid sequences are possible with UTF-8 and, if any such are found, they will be replaced with one or more "replacement characters", or suppressed. These include non-Unicode sequences, non-characters, overlong sequences or surrogate codepoints encoded into UTF-8.
This function can be used to process incoming data incrementally as long as all UTF-8 characters are terminated within the incoming data. Any unterminated characters at the end of the string will be replaced or suppressed. In order to do stateful decoding, please use QTextDecoder.
See also toUtf8(), fromLatin1(), and fromLocal8Bit().
[static] QString QString::fromUtf8(const QByteArray &str)
This is an overloaded function.
Returns a QString initialized with the UTF-8 string str.
This function was introduced in Qt 5.0.
[static] QString QString::fromUtf16(const ushort *unicode, int size = -1)
Returns a QString initialized with the first size characters of the Unicode string unicode (ISO-10646-UTF-16 encoded).
If size is -1 (default), unicode must be \0'-terminated.
This function checks for a Byte Order Mark (BOM). If it is missing, host byte order is assumed.
This function is slow compared to the other Unicode conversions. Use QString(const QChar *, int) or QString(const QChar *) if possible.
QString makes a deep copy of the Unicode data.
See also utf16(), setUtf16(), and fromStdU16String().
[static] QString QString::fromUtf16(const char16_t *str, int size = -1)
Returns a QString initialized with the first size characters of the Unicode string str (ISO-10646-UTF-16 encoded).
If size is -1 (default), str must be \0'-terminated.
This function checks for a Byte Order Mark (BOM). If it is missing, host byte order is assumed.
This function is slow compared to the other Unicode conversions. Use QString(const QChar *, int) or QString(const QChar *) if possible.
QString makes a deep copy of the Unicode data.
This function was introduced in Qt 5.3.
See also utf16(), setUtf16(), and fromStdU16String().
[static] QString QString::fromWCharArray(const wchar_t *string, int size = -1)
Returns a copy of the string, where the encoding of string depends on the size of wchar. If wchar is 4 bytes, the string is interpreted as UCS-4, if wchar is 2 bytes it is interpreted as UTF-16.
If size is -1 (default), the string has to be \0'-terminated.
This function was introduced in Qt 4.2.
See also fromUtf16(), fromLatin1(), fromLocal8Bit(), fromUtf8(), fromUcs4(), and fromStdWString().
QChar QString::front() const
Returns the first character in the string. Same as at(0).
This function is provided for STL compatibility.
Warning: Calling this function on an empty string constitutes undefined behavior.
This function was introduced in Qt 5.10.
See also back(), at(), and operator[]().
QCharRef QString::front()
Returns a reference to the first character in the string. Same as operator[](0).
This function is provided for STL compatibility.
Warning: Calling this function on an empty string constitutes undefined behavior.
This function was introduced in Qt 5.10.
See also back(), at(), and operator[]().
int QString::indexOf(QLatin1String str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
Returns the index position of the first occurrence of the string str in this string, searching forward from index position from. Returns -1 if str is not found.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
Example:
 QString x = "sticky question";
 QString y = "sti";
 x.indexOf(y);               // returns 0
 x.indexOf(y, 1);            // returns 10
 x.indexOf(y, 10);           // returns 10
 x.indexOf(y, 11);           // returns -1
If from is -1, the search starts at the last character; if it is -2, at the next to last character and so on.
This function was introduced in Qt 4.5.
See also lastIndexOf(), contains(), and count().
int QString::indexOf(QChar ch, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads indexOf().
Returns the index position of the first occurrence of the character ch in the string, searching forward from index position from. Returns -1 if ch could not be found.
int QString::indexOf(const QString &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
Returns the index position of the first occurrence of the string str in this string, searching forward from index position from. Returns -1 if str is not found.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
Example:
 QString x = "sticky question";
 QString y = "sti";
 x.indexOf(y);               // returns 0
 x.indexOf(y, 1);            // returns 10
 x.indexOf(y, 10);           // returns 10
 x.indexOf(y, 11);           // returns -1
If from is -1, the search starts at the last character; if it is -2, at the next to last character and so on.
See also lastIndexOf(), contains(), and count().
int QString::indexOf(const QStringRef &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads indexOf().
Returns the index position of the first occurrence of the string reference str in this string, searching forward from index position from. Returns -1 if str is not found.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
This function was introduced in Qt 4.8.
int QString::indexOf(QStringView str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads indexOf().
Returns the index position of the first occurrence of the string view str in this string, searching forward from index position from. Returns -1 if str is not found.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
If from is -1, the search starts at the last character; if it is -2, at the next to last character and so on.
This function was introduced in Qt 5.14.
See also QStringView::indexOf(), lastIndexOf(), contains(), and count().
int QString::indexOf(const QRegExp &rx, int from = 0) const
This function overloads indexOf().
Returns the index position of the first match of the regular expression rx in the string, searching forward from index position from. Returns -1 if rx didn't match anywhere.
Example:
 QString str = "the minimum";
 str.indexOf(QRegExp("m[aeiou]"), 0);       // returns 4
int QString::indexOf(QRegExp &rx, int from = 0) const
This function overloads indexOf().
Returns the index position of the first match of the regular expression rx in the string, searching forward from index position from. Returns -1 if rx didn't match anywhere.
If there is a match, the rx regular expression will contain the matched captures (see QRegExp::matchedLength, QRegExp::cap).
Example:
 QString str = "the minimum";
 str.indexOf(QRegExp("m[aeiou]"), 0);       // returns 4
This function was introduced in Qt 4.5.
int QString::indexOf(const QRegularExpression &re, int from = 0) const
This function overloads indexOf().
Returns the index position of the first match of the regular expression re in the string, searching forward from index position from. Returns -1 if re didn't match anywhere.
Example:
 QString str = "the minimum";
 str.indexOf(QRegularExpression("m[aeiou]"), 0);       // returns 4
This function was introduced in Qt 5.0.
int QString::indexOf(const QRegularExpression &re, int from, QRegularExpressionMatch *rmatch) const
This is an overloaded function.
Returns the index position of the first match of the regular expression re in the string, searching forward from index position from. Returns -1 if re didn't match anywhere.
If the match is successful and rmatch is not nullptr, it also writes the results of the match into the QRegularExpressionMatch object pointed to by rmatch.
Example:
 QString str = "the minimum";
 QRegularExpressionMatch match;
 str.indexOf(QRegularExpression("m[aeiou]"), 0, &match);       // returns 4
 // match.captured() == mi
This function was introduced in Qt 5.5.
QString &QString::insert(int position, const QString &str)
Inserts the string str at the given index position and returns a reference to this string.
Example:
 QString str = "Meal";
 str.insert(1, QString("ontr"));
 // str == "Montreal"
If the given position is greater than size(), the array is first extended using resize().
See also append(), prepend(), replace(), and remove().
QString &QString::insert(int position, QChar ch)
This function overloads insert().
Inserts ch at the given index position in the string.
QString &QString::insert(int position, const QChar *unicode, int size)
This function overloads insert().
Inserts the first size characters of the QChar array unicode at the given index position in the string.
QString &QString::insert(int position, const QStringRef &str)
This function overloads insert().
Inserts the string reference str at the given index position and returns a reference to this string.
If the given position is greater than size(), the array is first extended using resize().
This function was introduced in Qt 5.5.
QString &QString::insert(int position, QLatin1String str)
This function overloads insert().
Inserts the Latin-1 string str at the given index position.
QString &QString::insert(int position, const char *str)
This function overloads insert().
Inserts the C string str at the given index position and returns a reference to this string.
If the given position is greater than size(), the array is first extended using resize().
This function is not available when QT_NO_CAST_FROM_ASCII is defined.
This function was introduced in Qt 5.5.
See also QT_NO_CAST_FROM_ASCII.
QString &QString::insert(int position, const QByteArray &str)
This function overloads insert().
Inserts the byte array str at the given index position and returns a reference to this string.
If the given position is greater than size(), the array is first extended using resize().
This function is not available when QT_NO_CAST_FROM_ASCII is defined.
This function was introduced in Qt 5.5.
See also QT_NO_CAST_FROM_ASCII.
bool QString::isEmpty() const
Returns true if the string has no characters; otherwise returns false.
Example:
 QString().isEmpty();            // returns true
 QString("").isEmpty();          // returns true
 QString("x").isEmpty();         // returns false
 QString("abc").isEmpty();       // returns false
See also size().
bool QString::isLower() const
Returns true if the string is lowercase, that is, it's identical to its toLower() folding.
Note that this does not mean that the string does not contain uppercase letters (some uppercase letters do not have a lowercase folding; they are left unchanged by toLower()). For more information, refer to the Unicode standard, section 3.13.
This function was introduced in Qt 5.12.
See also QChar::toLower() and isUpper().
bool QString::isNull() const
Returns true if this string is null; otherwise returns false.
Example:
 QString().isNull();             // returns true
 QString("").isNull();           // returns false
 QString("abc").isNull();        // returns false
Qt makes a distinction between null strings and empty strings for historical reasons. For most applications, what matters is whether or not a string contains any data, and this can be determined using the isEmpty() function.
See also isEmpty().
bool QString::isRightToLeft() const
Returns true if the string is read right to left.
See also QStringRef::isRightToLeft().
bool QString::isUpper() const
Returns true if the string is uppercase, that is, it's identical to its toUpper() folding.
Note that this does not mean that the string does not contain lowercase letters (some lowercase letters do not have a uppercase folding; they are left unchanged by toUpper()). For more information, refer to the Unicode standard, section 3.13.
This function was introduced in Qt 5.12.
See also QChar::toUpper() and isLower().
bool QString::isValidUtf16() const
Returns true if the string contains valid UTF-16 encoded data, or false otherwise.
Note that this function does not perform any special validation of the data; it merely checks if it can be successfully decoded from UTF-16. The data is assumed to be in host byte order; the presence of a BOM is meaningless.
This function was introduced in Qt 5.15.
See also QStringView::isValidUtf16().
int QString::lastIndexOf(const QString &str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
Returns the index position of the last occurrence of the string str in this string, searching backward from index position from. If from is -1 (default), the search starts at the last character; if from is -2, at the next to last character and so on. Returns -1 if str is not found.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
Example:
 QString x = "crazy azimuths";
 QString y = "az";
 x.lastIndexOf(y);           // returns 6
 x.lastIndexOf(y, 6);        // returns 6
 x.lastIndexOf(y, 5);        // returns 2
 x.lastIndexOf(y, 1);        // returns -1
See also indexOf(), contains(), and count().
int QString::lastIndexOf(QChar ch, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads lastIndexOf().
Returns the index position of the last occurrence of the character ch, searching backward from position from.
int QString::lastIndexOf(QLatin1String str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads lastIndexOf().
Returns the index position of the last occurrence of the string str in this string, searching backward from index position from. If from is -1 (default), the search starts at the last character; if from is -2, at the next to last character and so on. Returns -1 if str is not found.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
Example:
 QString x = "crazy azimuths";
 QString y = "az";
 x.lastIndexOf(y);           // returns 6
 x.lastIndexOf(y, 6);        // returns 6
 x.lastIndexOf(y, 5);        // returns 2
 x.lastIndexOf(y, 1);        // returns -1
This function was introduced in Qt 4.5.
See also indexOf(), contains(), and count().
int QString::lastIndexOf(const QStringRef &str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads lastIndexOf().
Returns the index position of the last occurrence of the string reference str in this string, searching backward from index position from. If from is -1 (default), the search starts at the last character; if from is -2, at the next to last character and so on. Returns -1 if str is not found.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
This function was introduced in Qt 4.8.
See also indexOf(), contains(), and count().
int QString::lastIndexOf(QStringView str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads lastIndexOf().
Returns the index position of the last occurrence of the string view str in this string, searching backward from index position from. If from is -1 (default), the search starts at the last character; if from is -2, at the next to last character and so on. Returns -1 if str is not found.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
This function was introduced in Qt 5.14.
See also indexOf(), contains(), and count().
int QString::lastIndexOf(const QRegExp &rx, int from = -1) const
This function overloads lastIndexOf().
Returns the index position of the last match of the regular expression rx in the string, searching backward from index position from. Returns -1 if rx didn't match anywhere.
Example:
 QString str = "the minimum";
 str.lastIndexOf(QRegExp("m[aeiou]"));      // returns 8
int QString::lastIndexOf(QRegExp &rx, int from = -1) const
This function overloads lastIndexOf().
Returns the index position of the last match of the regular expression rx in the string, searching backward from index position from. Returns -1 if rx didn't match anywhere.
If there is a match, the rx regular expression will contain the matched captures (see QRegExp::matchedLength, QRegExp::cap).
Example:
 QString str = "the minimum";
 str.lastIndexOf(QRegExp("m[aeiou]"));      // returns 8
This function was introduced in Qt 4.5.
int QString::lastIndexOf(const QRegularExpression &re, int from = -1) const
This function overloads lastIndexOf().
Returns the index position of the last match of the regular expression re in the string, which starts before the index position from. Returns -1 if re didn't match anywhere.
Example:
 QString str = "the minimum";
 str.lastIndexOf(QRegularExpression("m[aeiou]"));      // returns 8
This function was introduced in Qt 5.0.
int QString::lastIndexOf(const QRegularExpression &re, int from, QRegularExpressionMatch *rmatch) const
This is an overloaded function.
Returns the index position of the last match of the regular expression re in the string, which starts before the index position from. Returns -1 if re didn't match anywhere.
If the match is successful and rmatch is not nullptr, it also writes the results of the match into the QRegularExpressionMatch object pointed to by rmatch.
Example:
 QString str = "the minimum";
 QRegularExpressionMatch match;
 str.lastIndexOf(QRegularExpression("m[aeiou]"), -1, &match);      // returns 8
 // match.captured() == mu
This function was introduced in Qt 5.5.
QString QString::left(int n) const
Returns a substring that contains the n leftmost characters of the string.
The entire string is returned if n is greater than or equal to size(), or less than zero.
 QString x = "Pineapple";
 QString y = x.left(4);      // y == "Pine"
See also right(), mid(), startsWith(), chopped(), chop(), and truncate().
QString QString::leftJustified(int width, QChar fill = QLatin1Char(' '), bool truncate = false) const
Returns a string of size width that contains this string padded by the fill character.
If truncate is false and the size() of the string is more than width, then the returned string is a copy of the string.
 QString s = "apple";
 QString t = s.leftJustified(8, '.');    // t == "apple..."
If truncate is true and the size() of the string is more than width, then any characters in a copy of the string after position width are removed, and the copy is returned.
 QString str = "Pineapple";
 str = str.leftJustified(5, '.', true);    // str == "Pinea"
See also rightJustified().
QStringRef QString::leftRef(int n) const
Returns a substring reference to the n leftmost characters of the string.
If n is greater than or equal to size(), or less than zero, a reference to the entire string is returned.
 QString x = "Pineapple";
 QStringRef y = x.leftRef(4);        // y == "Pine"
This function was introduced in Qt 4.4.
See also left(), rightRef(), midRef(), and startsWith().
int QString::length() const
Returns the number of characters in this string. Equivalent to size().
See also resize().
[static] int QString::localeAwareCompare(const QString &s1, const QString &s2)
Compares s1 with s2 and returns an integer less than, equal to, or greater than zero if s1 is less than, equal to, or greater than s2.
The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.
See also compare(), QLocale, and Comparing Strings.
int QString::localeAwareCompare(const QString &other) const
This function overloads localeAwareCompare().
Compares this string with the other string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the other string.
The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.
Same as localeAwareCompare(*this, other).
See also Comparing Strings.
int QString::localeAwareCompare(const QStringRef &other) const
This function overloads localeAwareCompare().
Compares this string with the other string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the other string.
The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.
Same as localeAwareCompare(*this, other).
This function was introduced in Qt 4.5.
See also Comparing Strings.
[static] int QString::localeAwareCompare(const QString &s1, const QStringRef &s2)
This function overloads localeAwareCompare().
Compares s1 with s2 and returns an integer less than, equal to, or greater than zero if s1 is less than, equal to, or greater than s2.
The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.
This function was introduced in Qt 4.5.
See also Comparing Strings.
QString QString::mid(int position, int n = -1) const
Returns a string that contains n characters of this string, starting at the specified position index.
Returns a null string if the position index exceeds the length of the string. If there are less than n characters available in the string starting at the given position, or if n is -1 (default), the function returns all characters that are available from the specified position.
Example:
 QString x = "Nine pineapples";
 QString y = x.mid(5, 4);            // y == "pine"
 QString z = x.mid(5);               // z == "pineapples"
See also left(), right(), chopped(), chop(), and truncate().
QStringRef QString::midRef(int position, int n = -1) const
Returns a substring reference to n characters of this string, starting at the specified position.
If the position exceeds the length of the string, a null reference is returned.
If there are less than n characters available in the string, starting at the given position, or if n is -1 (default), the function returns all characters from the specified position onwards.
Example:
 QString x = "Nine pineapples";
 QStringRef y = x.midRef(5, 4);      // y == "pine"
 QStringRef z = x.midRef(5);         // z == "pineapples"
This function was introduced in Qt 4.4.
See also mid(), leftRef(), and rightRef().
QString QString::normalized(QString::NormalizationForm mode, QChar::UnicodeVersion version = QChar::Unicode_Unassigned) const
Returns the string in the given Unicode normalization mode, according to the given version of the Unicode standard.
[static] QString QString::number(long n, int base = 10)
Returns a string equivalent of the number n according to the specified base.
The base is 10 by default and must be between 2 and 36. For bases other than 10, n is treated as an unsigned integer.
The formatting always uses QLocale::C, i.e., English/UnitedStates. To get a localized string representation of a number, use QLocale::toString() with the appropriate locale.
 long a = 63;
 QString s = QString::number(a, 16);             // s == "3f"
 QString t = QString::number(a, 16).toUpper();     // t == "3F"
See also setNum().
[static] QString QString::number(int n, int base = 10)
This is an overloaded function.
[static] QString QString::number(uint n, int base = 10)
This is an overloaded function.
[static] QString QString::number(ulong n, int base = 10)
This is an overloaded function.
[static] QString QString::number(qlonglong n, int base = 10)
This is an overloaded function.
[static] QString QString::number(qulonglong n, int base = 10)
This is an overloaded function.
[static] QString QString::number(double n, char format = 'g', int precision = 6)
Returns a string equivalent of the number n, formatted according to the specified format and precision. See Argument Formats for details.
Unlike QLocale::toString(), this function does not honor the user's locale settings.
See also setNum() and QLocale::toString().
QString &QString::prepend(const QString &str)
Prepends the string str to the beginning of this string and returns a reference to this string.
Example:
 QString x = "ship";
 QString y = "air";
 x.prepend(y);
 // x == "airship"
See also append() and insert().
QString &QString::prepend(QChar ch)
This function overloads prepend().
Prepends the character ch to this string.
QString &QString::prepend(const QChar *str, int len)
This function overloads prepend().
Prepends len characters from the QChar array str to this string and returns a reference to this string.
This function was introduced in Qt 5.5.
QString &QString::prepend(const QStringRef &str)
This function overloads prepend().
Prepends the string reference str to the beginning of this string and returns a reference to this string.
This function was introduced in Qt 5.5.
QString &QString::prepend(QLatin1String str)
This function overloads prepend().
Prepends the Latin-1 string str to this string.
QString &QString::prepend(const char *str)
This function overloads prepend().
Prepends the string str to this string. The const char pointer is converted to Unicode using the fromUtf8() function.
You can disable this function by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
QString &QString::prepend(const QByteArray &ba)
This function overloads prepend().
Prepends the byte array ba to this string. The byte array is converted to Unicode using the fromUtf8() function.
You can disable this function by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
void QString::push_back(const QString &other)
This function is provided for STL compatibility, appending the given other string onto the end of this string. It is equivalent to append(other).
See also append().
void QString::push_back(QChar ch)
This is an overloaded function.
Appends the given ch character onto the end of this string.
void QString::push_front(const QString &other)
This function is provided for STL compatibility, prepending the given other string to the beginning of this string. It is equivalent to prepend(other).
See also prepend().
void QString::push_front(QChar ch)
This is an overloaded function.
Prepends the given ch character to the beginning of this string.
QString::reverse_iterator QString::rbegin()
Returns a STL-style reverse iterator pointing to the first character in the string, in reverse order.
This function was introduced in Qt 5.6.
See also begin(), crbegin(), and rend().
QString::const_reverse_iterator QString::rbegin() const
This is an overloaded function.
This function was introduced in Qt 5.6.
QString &QString::remove(int position, int n)
Removes n characters from the string, starting at the given position index, and returns a reference to the string.
If the specified position index is within the string, but position + n is beyond the end of the string, the string is truncated at the specified position.
 QString s = "Montreal";
 s.remove(1, 4);
 // s == "Meal"
See also insert() and replace().
QString &QString::remove(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive)
Removes every occurrence of the character ch in this string, and returns a reference to this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
Example:
 QString t = "Ali Baba";
 t.remove(QChar('a'), Qt::CaseInsensitive);
 // t == "li Bb"
This is the same as replace(ch, "", cs).
See also replace().
QString &QString::remove(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive)
This is an overloaded function.
Removes every occurrence of the given str string in this string, and returns a reference to this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
This is the same as replace(str, "", cs).
This function was introduced in Qt 5.11.
See also replace().
QString &QString::remove(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive)
Removes every occurrence of the given str string in this string, and returns a reference to this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
This is the same as replace(str, "", cs).
See also replace().
QString &QString::remove(const QRegExp &rx)
Removes every occurrence of the regular expression rx in the string, and returns a reference to the string. For example:
 QString r = "Telephone";
 r.remove(QRegExp("[aeiou]."));
 // r == "The"
See also indexOf(), lastIndexOf(), and replace().
QString &QString::remove(const QRegularExpression &re)
Removes every occurrence of the regular expression re in the string, and returns a reference to the string. For example:
 QString r = "Telephone";
 r.remove(QRegularExpression("[aeiou]."));
 // r == "The"
This function was introduced in Qt 5.0.
See also indexOf(), lastIndexOf(), and replace().
QString::reverse_iterator QString::rend()
Returns a STL-style reverse iterator pointing to one past the last character in the string, in reverse order.
This function was introduced in Qt 5.6.
See also end(), crend(), and rbegin().
QString::const_reverse_iterator QString::rend() const
This is an overloaded function.
This function was introduced in Qt 5.6.
QString QString::repeated(int times) const
Returns a copy of this string repeated the specified number of times.
If times is less than 1, an empty string is returned.
Example:
 QString str("ab");
 str.repeated(4);            // returns "abababab"
This function was introduced in Qt 4.5.
QString &QString::replace(int position, int n, const QString &after)
Replaces n characters beginning at index position with the string after and returns a reference to this string.
Note: If the specified position index is within the string, but position + n goes outside the strings range, then n will be adjusted to stop at the end of the string.
Example:
 QString x = "Say yes!";
 QString y = "no";
 x.replace(4, 3, y);
 // x == "Say no!"
See also insert() and remove().
QString &QString::replace(int position, int n, QChar after)
This function overloads replace().
Replaces n characters beginning at index position with the character after and returns a reference to this string.
QString &QString::replace(int position, int n, const QChar *unicode, int size)
This function overloads replace().
Replaces n characters beginning at index position with the first size characters of the QChar array unicode and returns a reference to this string.
QString &QString::replace(QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
This function overloads replace().
Replaces every occurrence of the character before with the character after and returns a reference to this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
QString &QString::replace(const QChar *before, int blen, const QChar *after, int alen, Qt::CaseSensitivity cs = Qt::CaseSensitive)
This function overloads replace().
Replaces each occurrence in this string of the first blen characters of before with the first alen characters of after and returns a reference to this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
This function was introduced in Qt 4.5.
QString &QString::replace(QLatin1String before, QLatin1String after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
This function overloads replace().
Replaces every occurrence of the string before with the string after and returns a reference to this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
Note: The text is not rescanned after a replacement.
This function was introduced in Qt 4.5.
QString &QString::replace(QLatin1String before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
This function overloads replace().
Replaces every occurrence of the string before with the string after and returns a reference to this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
Note: The text is not rescanned after a replacement.
This function was introduced in Qt 4.5.
QString &QString::replace(const QString &before, QLatin1String after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
This function overloads replace().
Replaces every occurrence of the string before with the string after and returns a reference to this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
Note: The text is not rescanned after a replacement.
This function was introduced in Qt 4.5.
QString &QString::replace(const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
This function overloads replace().
Replaces every occurrence of the string before with the string after and returns a reference to this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
Example:
 QString str = "colour behaviour flavour neighbour";
 str.replace(QString("ou"), QString("o"));
 // str == "color behavior flavor neighbor"
Note: The replacement text is not rescanned after it is inserted.
Example:
 QString equis = "xxxxxx";
 equis.replace("xx", "x");
 // equis == "xxx"
QString &QString::replace(QChar ch, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
This function overloads replace().
Replaces every occurrence of the character ch in the string with after and returns a reference to this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
QString &QString::replace(QChar c, QLatin1String after, Qt::CaseSensitivity cs = Qt::CaseSensitive)
This function overloads replace().
Replaces every occurrence of the character c with the string after and returns a reference to this string.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
Note: The text is not rescanned after a replacement.
This function was introduced in Qt 4.5.
QString &QString::replace(const QRegExp &rx, const QString &after)
This function overloads replace().
Replaces every occurrence of the regular expression rx in the string with after. Returns a reference to the string. For example:
 QString s = "Banana";
 s.replace(QRegExp("a[mn]"), "ox");
 // s == "Boxoxa"
For regular expressions containing capturing parentheses, occurrences of \1, \2, ..., in after are replaced with rx.cap(1), cap(2), ...
 QString t = "A <i>bon mot</i>.";
 t.replace(QRegExp("<i>([^<]*)</i>"), "\\emph{\\1}");
 // t == "A \\emph{bon mot}."
See also indexOf(), lastIndexOf(), remove(), and QRegExp::cap().
QString &QString::replace(const QRegularExpression &re, const QString &after)
This function overloads replace().
Replaces every occurrence of the regular expression re in the string with after. Returns a reference to the string. For example:
 QString s = "Banana";
 s.replace(QRegularExpression("a[mn]"), "ox");
 // s == "Boxoxa"
For regular expressions containing capturing groups, occurrences of \1, \2, ..., in after are replaced with the string captured by the corresponding capturing group.
 QString t = "A <i>bon mot</i>.";
 t.replace(QRegularExpression("<i>([^<]*)</i>"), "\\emph{\\1}");
 // t == "A \\emph{bon mot}."
This function was introduced in Qt 5.0.
See also indexOf(), lastIndexOf(), remove(), QRegularExpression, and QRegularExpressionMatch.
void QString::reserve(int size)
Attempts to allocate memory for at least size characters. If you know in advance how large the string will be, you can call this function, and if you resize the string often you are likely to get better performance. If size is an underestimate, the worst that will happen is that the QString will be a bit slower.
The sole purpose of this function is to provide a means of fine tuning QString's memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the string, call resize().
This function is useful for code that needs to build up a long string and wants to avoid repeated reallocation. In this example, we want to add to the string until some condition is true, and we're fairly sure that size is large enough to make a call to reserve() worthwhile:
 QString result;
 int maxSize;
 bool condition;
 QChar nextChar;

 result.reserve(maxSize);

 while (condition)
     result.append(nextChar);

 result.squeeze();
See also squeeze() and capacity().
void QString::resize(int size)
Sets the size of the string to size characters.
If size is greater than the current size, the string is extended to make it size characters long with the extra characters added to the end. The new characters are uninitialized.
If size is less than the current size, characters are removed from the end.
Example:
 QString s = "Hello world";
 s.resize(5);
 // s == "Hello"

 s.resize(8);
 // s == "Hello???" (where ? stands for any character)
If you want to append a certain number of identical characters to the string, use the resize(int, QChar) overload.
If you want to expand the string so that it reaches a certain width and fill the new positions with a particular character, use the leftJustified() function:
If size is negative, it is equivalent to passing zero.
 QString r = "Hello";
 r = r.leftJustified(10, ' ');
 // r == "Hello     "
See also truncate() and reserve().
void QString::resize(int size, QChar fillChar)
This is an overloaded function.
Unlike resize(int), this overload initializes the new characters to fillChar:
 QString t = "Hello";
 r.resize(t.size() + 10, 'X');
 // t == "HelloXXXXXXXXXX"
This function was introduced in Qt 5.7.
QString QString::right(int n) const
Returns a substring that contains the n rightmost characters of the string.
The entire string is returned if n is greater than or equal to size(), or less than zero.
 QString x = "Pineapple";
 QString y = x.right(5);      // y == "apple"
See also left(), mid(), endsWith(), chopped(), chop(), and truncate().
QString QString::rightJustified(int width, QChar fill = QLatin1Char(' '), bool truncate = false) const
Returns a string of size() width that contains the fill character followed by the string. For example:
 QString s = "apple";
 QString t = s.rightJustified(8, '.');    // t == "...apple"
If truncate is false and the size() of the string is more than width, then the returned string is a copy of the string.
If truncate is true and the size() of the string is more than width, then the resulting string is truncated at position width.
 QString str = "Pineapple";
 str = str.rightJustified(5, '.', true);    // str == "Pinea"
See also leftJustified().
QStringRef QString::rightRef(int n) const
Returns a substring reference to the n rightmost characters of the string.
If n is greater than or equal to size(), or less than zero, a reference to the entire string is returned.
 QString x = "Pineapple";
 QStringRef y = x.rightRef(5);       // y == "apple"
This function was introduced in Qt 4.4.
See also right(), leftRef(), midRef(), and endsWith().
QString QString::section(QChar sep, int start, int end = -1, QString::SectionFlags flags = SectionDefault) const
This function returns a section of the string.
This string is treated as a sequence of fields separated by the character, sep. The returned string consists of the fields from position start to position end inclusive. If end is not specified, all fields from position start to the end of the string are included. Fields are numbered 0, 1, 2, etc., counting from the left, and -1, -2, etc., counting from right to left.
The flags argument can be used to affect some aspects of the function's behavior, e.g. whether to be case sensitive, whether to skip empty fields and how to deal with leading and trailing separators; see SectionFlags.
 QString str;
 QString csv = "forename,middlename,surname,phone";
 QString path = "/usr/local/bin/myapp"; // First field is empty
 QString::SectionFlag flag = QString::SectionSkipEmpty;

 str = csv.section(',', 2, 2);   // str == "surname"
 str = path.section('/', 3, 4);  // str == "bin/myapp"
 str = path.section('/', 3, 3, flag); // str == "myapp"
If start or end is negative, we count fields from the right of the string, the right-most field being -1, the one from right-most field being -2, and so on.
 str = csv.section(',', -3, -2);  // str == "middlename,surname"
 str = path.section('/', -1); // str == "myapp"
See also split().
QString QString::section(const QString &sep, int start, int end = -1, QString::SectionFlags flags = SectionDefault) const
This function overloads section().
 QString str;
 QString data = "forename**middlename**surname**phone";

 str = data.section("**", 2, 2); // str == "surname"
 str = data.section("**", -3, -2); // str == "middlename**surname"
See also split().
QString QString::section(const QRegExp &reg, int start, int end = -1, QString::SectionFlags flags = SectionDefault) const
This function overloads section().
This string is treated as a sequence of fields separated by the regular expression, reg.
 QString line = "forename\tmiddlename  surname \t \t phone";
 QRegExp sep("\\s+");
 str = line.section(sep, 2, 2); // str == "surname"
 str = line.section(sep, -3, -2); // str == "middlename  surname"
Warning: Using this QRegExp version is much more expensive than the overloaded string and character versions.
See also split() and simplified().
QString QString::section(const QRegularExpression &re, int start, int end = -1, QString::SectionFlags flags = SectionDefault) const
This function overloads section().
This string is treated as a sequence of fields separated by the regular expression, re.
 QString line = "forename\tmiddlename  surname \t \t phone";
 QRegularExpression sep("\\s+");
 str = line.section(sep, 2, 2); // str == "surname"
 str = line.section(sep, -3, -2); // str == "middlename  surname"
Warning: Using this QRegularExpression version is much more expensive than the overloaded string and character versions.
This function was introduced in Qt 5.0.
See also split() and simplified().
QString &QString::setNum(int n, int base = 10)
Sets the string to the printed value of n in the specified base, and returns a reference to the string.
The base is 10 by default and must be between 2 and 36. For bases other than 10, n is treated as an unsigned integer.
 QString str;
 str.setNum(1234);       // str == "1234"
The formatting always uses QLocale::C, i.e., English/UnitedStates. To get a localized string representation of a number, use QLocale::toString() with the appropriate locale.
See also number().
QString &QString::setNum(short n, int base = 10)
This is an overloaded function.
QString &QString::setNum(ushort n, int base = 10)
This is an overloaded function.
QString &QString::setNum(uint n, int base = 10)
This is an overloaded function.
QString &QString::setNum(long n, int base = 10)
This is an overloaded function.
QString &QString::setNum(ulong n, int base = 10)
This is an overloaded function.
QString &QString::setNum(qlonglong n, int base = 10)
This is an overloaded function.
QString &QString::setNum(qulonglong n, int base = 10)
This is an overloaded function.
QString &QString::setNum(float n, char format = 'g', int precision = 6)
This is an overloaded function.
Sets the string to the printed value of n, formatted according to the given format and precision, and returns a reference to the string.
The formatting always uses QLocale::C, i.e., English/UnitedStates. To get a localized string representation of a number, use QLocale::toString() with the appropriate locale.
See also number().
QString &QString::setNum(double n, char format = 'g', int precision = 6)
This is an overloaded function.
Sets the string to the printed value of n, formatted according to the given format and precision, and returns a reference to the string.
The format can be 'e', 'E', 'f', 'g' or 'G' (see Argument Formats for an explanation of the formats).
The formatting always uses QLocale::C, i.e., English/UnitedStates. To get a localized string representation of a number, use QLocale::toString() with the appropriate locale.
See also number().
QString &QString::setRawData(const QChar *unicode, int size)
Resets the QString to use the first size Unicode characters in the array unicode. The data in unicode is not copied. The caller must be able to guarantee that unicode will not be deleted or modified as long as the QString (or an unmodified copy of it) exists.
This function can be used instead of fromRawData() to re-use existings QString objects to save memory re-allocations.
This function was introduced in Qt 4.7.
See also fromRawData().
QString &QString::setUnicode(const QChar *unicode, int size)
Resizes the string to size characters and copies unicode into the string.
If unicode is 0, nothing is copied, but the string is still resized to size.
See also unicode() and setUtf16().
QString &QString::setUtf16(const ushort *unicode, int size)
Resizes the string to size characters and copies unicode into the string.
If unicode is 0, nothing is copied, but the string is still resized to size.
Note that unlike fromUtf16(), this function does not consider BOMs and possibly differing byte ordering.
See also utf16() and setUnicode().
void QString::shrink_to_fit()
This function is provided for STL compatibility. It is equivalent to squeeze().
This function was introduced in Qt 5.10.
See also squeeze().
QString QString::simplified() const
Returns a string that has whitespace removed from the start and the end, and that has each sequence of internal whitespace replaced with a single space.
Whitespace means any character for which QChar::isSpace() returns true. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.
Example:
 QString str = "  lots\t of\nwhitespace\r\n ";
 str = str.simplified();
 // str == "lots of whitespace";
See also trimmed().
int QString::size() const
Returns the number of characters in this string.
The last character in the string is at position size() - 1.
Example:
 QString str = "World";
 int n = str.size();         // n == 5
 str.data()[0];              // returns 'W'
 str.data()[4];              // returns 'd'
See also isEmpty() and resize().
QStringList QString::split(const QString &sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
Splits the string into substrings wherever sep occurs, and returns the list of those strings. If sep does not match anywhere in the string, split() returns a single-element list containing this string.
cs specifies whether sep should be matched case sensitively or case insensitively.
If behavior is QString::SkipEmptyParts, empty entries don't appear in the result. By default, empty entries are kept.
Example:
 QString str = QStringLiteral("a,,b,c");

 QStringList list1 = str.split(QLatin1Char(','));
 // list1: [ "a", "", "b", "c" ]

 QStringList list2 = str.split(QLatin1Char(','), Qt::SkipEmptyParts);
 // list2: [ "a", "b", "c" ]
If sep is empty, split() returns an empty string, followed by each of the string's characters, followed by another empty string:
 QString str = "abc";
 auto parts = str.split(QString());
 // parts: {"", "a", "b", "c", ""}
To understand this behavior, recall that the empty string matches everywhere, so the above is qualitatively the same as:
 QString str = "/a/b/c/";
 auto parts = str.split(QLatin1Char('/'));
 // parts: {"", "a", "b", "c", ""}
This function was introduced in Qt 5.14.
See also QStringList::join() and section().
QStringList QString::split(QChar sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This is an overloaded function.
This function was introduced in Qt 5.14.
QStringList QString::split(const QRegExp &rx, Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const
This is an overloaded function.
Splits the string into substrings wherever the regular expression rx matches, and returns the list of those strings. If rx does not match anywhere in the string, split() returns a single-element list containing this string.
Here is an example where we extract the words in a sentence using one or more whitespace characters as the separator:
 QString str;
 QStringList list;

 str = "Some  text\n\twith  strange whitespace.";
 list = str.split(QRegExp("\\s+"));
 // list: [ "Some", "text", "with", "strange", "whitespace." ]
Here is a similar example, but this time we use any sequence of non-word characters as the separator:
 str = "This time, a normal English sentence.";
 list = str.split(QRegExp("\\W+"), Qt::SkipEmptyParts);
 // list: [ "This", "time", "a", "normal", "English", "sentence" ]
Here is a third example where we use a zero-length assertion, \b (word boundary), to split the string into an alternating sequence of non-word and word tokens:
 str = "Now: this sentence fragment.";
 list = str.split(QRegExp("\\b"));
 // list: [ "", "Now", ": ", "this", " ", "sentence", " ", "fragment", "." ]
This function was introduced in Qt 5.14.
See also QStringList::join() and section().
QStringList QString::split(const QRegularExpression &re, Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const
This is an overloaded function.
Splits the string into substrings wherever the regular expression re matches, and returns the list of those strings. If re does not match anywhere in the string, split() returns a single-element list containing this string.
Here is an example where we extract the words in a sentence using one or more whitespace characters as the separator:
 QString str;
 QStringList list;

 str = "Some  text\n\twith  strange whitespace.";
 list = str.split(QRegularExpression("\\s+"));
 // list: [ "Some", "text", "with", "strange", "whitespace." ]
Here is a similar example, but this time we use any sequence of non-word characters as the separator:
 str = "This time, a normal English sentence.";
 list = str.split(QRegularExpression("\\W+"), Qt::SkipEmptyParts);
 // list: [ "This", "time", "a", "normal", "English", "sentence" ]
Here is a third example where we use a zero-length assertion, \b (word boundary), to split the string into an alternating sequence of non-word and word tokens:
 str = "Now: this sentence fragment.";
 list = str.split(QRegularExpression("\\b"));
 // list: [ "", "Now", ": ", "this", " ", "sentence", " ", "fragment", "." ]
This function was introduced in Qt 5.14.
See also QStringList::join() and section().
QVector<QStringRef> QString::splitRef(const QString &sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
Splits the string into substring references wherever sep occurs, and returns the list of those strings.
See QString::split() for how sep, behavior and cs interact to form the result.
Note: All references are valid as long this string is alive. Destroying this string will cause all references to be dangling pointers.
This function was introduced in Qt 5.14.
See also QStringRef and split().
QVector<QStringRef> QString::splitRef(QChar sep, QString::SplitBehavior behavior, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This is an overloaded function.
This function was introduced in Qt 5.4.
QVector<QStringRef> QString::splitRef(QChar sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This is an overloaded function.
This function was introduced in Qt 5.14.
QVector<QStringRef> QString::splitRef(const QRegExp &rx, Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const
This is an overloaded function.
Splits the string into substring references wherever the regular expression rx matches, and returns the list of those strings. If rx does not match anywhere in the string, splitRef() returns a single-element vector containing this string reference.
Note: All references are valid as long this string is alive. Destroying this string will cause all references to be dangling pointers.
This function was introduced in Qt 5.14.
See also QStringRef and split().
QVector<QStringRef> QString::splitRef(const QRegularExpression &re, Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const
This is an overloaded function.
Splits the string into substring references wherever the regular expression re matches, and returns the list of those strings. If re does not match anywhere in the string, splitRef() returns a single-element vector containing this string reference.
Note: All references are valid as long this string is alive. Destroying this string will cause all references to be dangling pointers.
This function was introduced in Qt 5.14.
See also split() and QStringRef.
void QString::squeeze()
Releases any memory not required to store the character data.
The sole purpose of this function is to provide a means of fine tuning QString's memory usage. In general, you will rarely ever need to call this function.
See also reserve() and capacity().
bool QString::startsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
Returns true if the string starts with s; otherwise returns false.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
 QString str = "Bananas";
 str.startsWith("Ban");     // returns true
 str.startsWith("Car");     // returns false
See also endsWith().
bool QString::startsWith(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This is an overloaded function.
Returns true if the string starts with the string reference s; otherwise returns false.
If cs is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.
This function was introduced in Qt 4.8.
See also endsWith().
bool QString::startsWith(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This is an overloaded function.
Returns true if the string starts with the string-view str; otherwise returns false.
If cs is Qt::CaseSensitive (default), the search is case-sensitive; otherwise the search is case insensitive.
This function was introduced in Qt 5.10.
See also endsWith().
bool QString::startsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads startsWith().
bool QString::startsWith(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
This function overloads startsWith().
Returns true if the string starts with c; otherwise returns false.
void QString::swap(QString &other)
Swaps string other with this string. This operation is very fast and never fails.
This function was introduced in Qt 4.8.
CFStringRef QString::toCFString() const
Creates a CFString from a QString. The caller owns the CFString and is responsible for releasing it.
Note: this function is only available on OS X and iOS.
This function was introduced in Qt 5.2.
QString QString::toCaseFolded() const
Returns the case folded equivalent of the string. For most Unicode characters this is the same as toLower().
double QString::toDouble(bool *ok = nullptr) const
Returns the string converted to a double value.
Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).
If ok is not nullptr, failure is reported by setting *ok to false, and success by setting *ok to true.
 QString str = "1234.56";
 double val = str.toDouble();   // val == 1234.56
Warning: The QString content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.
 bool ok;
 double d;

 d = QString( "1234.56e-02" ).toDouble(&ok); // ok == true, d == 12.3456

 d = QString( "1234.56e-02 Volt" ).toDouble(&ok); // ok == false, d == 0
The string conversion will always happen in the 'C' locale. For locale dependent conversion use QLocale::toDouble()
 d = QString( "1234,56" ).toDouble(&ok); // ok == false
 d = QString( "1234.56" ).toDouble(&ok); // ok == true, d == 1234.56
For historical reasons, this function does not handle thousands group separators. If you need to convert such numbers, use QLocale::toDouble().
 d = QString( "1,234,567.89" ).toDouble(&ok); // ok == false
 d = QString( "1234567.89" ).toDouble(&ok); // ok == true
This function ignores leading and trailing whitespace.
See also number(), QLocale::setDefault(), QLocale::toDouble(), and trimmed().
float QString::toFloat(bool *ok = nullptr) const
Returns the string converted to a float value.
Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).
If ok is not nullptr, failure is reported by setting *ok to false, and success by setting *ok to true.
Warning: The QString content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.
The string conversion will always happen in the 'C' locale. For locale dependent conversion use QLocale::toFloat()
For historical reasons, this function does not handle thousands group separators. If you need to convert such numbers, use QLocale::toFloat().
Example:
 QString str1 = "1234.56";
 str1.toFloat();             // returns 1234.56

 bool ok;
 QString str2 = "R2D2";
 str2.toFloat(&ok);          // returns 0.0, sets ok to false

 QString str3 = "1234.56 Volt";
 str3.toFloat(&ok);          // returns 0.0, sets ok to false
This function ignores leading and trailing whitespace.
See also number(), toDouble(), toInt(), QLocale::toFloat(), and trimmed().
QString QString::toHtmlEscaped() const
Converts a plain text string to an HTML string with HTML metacharacters <, >, &, and " replaced by HTML entities.
Example:
 QString plain = "#include <QtCore>"
 QString html = plain.toHtmlEscaped();
 // html == "#include &lt;QtCore&gt;"
This function was introduced in Qt 5.0.
int QString::toInt(bool *ok = nullptr, int base = 10) const
Returns the string converted to an int using base base, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.
If ok is not nullptr, failure is reported by setting *ok to false, and success by setting *ok to true.
If base is 0, the C language convention is used: If the string begins with "0x", base 16 is used; if the string begins with "0", base 8 is used; otherwise, base 10 is used.
The string conversion will always happen in the 'C' locale. For locale dependent conversion use QLocale::toInt()
Example:
 QString str = "FF";
 bool ok;
 int hex = str.toInt(&ok, 16);       // hex == 255, ok == true
 int dec = str.toInt(&ok, 10);       // dec == 0, ok == false
This function ignores leading and trailing whitespace.
See also number(), toUInt(), toDouble(), and QLocale::toInt().
QByteArray QString::toLatin1() const
Returns a Latin-1 representation of the string as a QByteArray.
The returned byte array is undefined if the string contains non-Latin1 characters. Those characters may be suppressed or replaced with a question mark.
See also fromLatin1(), toUtf8(), toLocal8Bit(), and QTextCodec.
QByteArray QString::toLocal8Bit() const
Returns the local 8-bit representation of the string as a QByteArray. The returned byte array is undefined if the string contains characters not supported by the local 8-bit encoding.
QTextCodec::codecForLocale() is used to perform the conversion from Unicode. If the locale encoding could not be determined, this function does the same as toLatin1().
If this string contains any characters that cannot be encoded in the locale, the returned byte array is undefined. Those characters may be suppressed or replaced by another.
See also fromLocal8Bit(), toLatin1(), toUtf8(), and QTextCodec.
long QString::toLong(bool *ok = nullptr, int base = 10) const
Returns the string converted to a long using base base, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.
If ok is not nullptr, failure is reported by setting *ok to false, and success by setting *ok to true.
If base is 0, the C language convention is used: If the string begins with "0x", base 16 is used; if the string begins with "0", base 8 is used; otherwise, base 10 is used.
The string conversion will always happen in the 'C' locale. For locale dependent conversion use QLocale::toLongLong()
Example:
 QString str = "FF";
 bool ok;

 long hex = str.toLong(&ok, 16);     // hex == 255, ok == true
 long dec = str.toLong(&ok, 10);     // dec == 0, ok == false
This function ignores leading and trailing whitespace.
See also number(), toULong(), toInt(), and QLocale::toInt().
qlonglong QString::toLongLong(bool *ok = nullptr, int base = 10) const
Returns the string converted to a long long using base base, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.
If ok is not nullptr, failure is reported by setting *ok to false, and success by setting *ok to true.
If base is 0, the C language convention is used: If the string begins with "0x", base 16 is used; if the string begins with "0", base 8 is used; otherwise, base 10 is used.
The string conversion will always happen in the 'C' locale. For locale dependent conversion use QLocale::toLongLong()
Example:
 QString str = "FF";
 bool ok;

 qint64 hex = str.toLongLong(&ok, 16);      // hex == 255, ok == true
 qint64 dec = str.toLongLong(&ok, 10);      // dec == 0, ok == false
This function ignores leading and trailing whitespace.
See also number(), toULongLong(), toInt(), and QLocale::toLongLong().
QString QString::toLower() const
Returns a lowercase copy of the string.
 QString str = "The Qt PROJECT";
 str = str.toLower();        // str == "the qt project"
The case conversion will always happen in the 'C' locale. For locale dependent case folding use QLocale::toLower()
See also toUpper() and QLocale::toLower().
NSString *QString::toNSString() const
Creates a NSString from a QString. The NSString is autoreleased.
Note: this function is only available on OS X and iOS.
This function was introduced in Qt 5.2.
short QString::toShort(bool *ok = nullptr, int base = 10) const
Returns the string converted to a short using base base, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.
If ok is not nullptr, failure is reported by setting *ok to false, and success by setting *ok to true.
If base is 0, the C language convention is used: If the string begins with "0x", base 16 is used; if the string begins with "0", base 8 is used; otherwise, base 10 is used.
The string conversion will always happen in the 'C' locale. For locale dependent conversion use QLocale::toShort()
Example:
 QString str = "FF";
 bool ok;

 short hex = str.toShort(&ok, 16);   // hex == 255, ok == true
 short dec = str.toShort(&ok, 10);   // dec == 0, ok == false
This function ignores leading and trailing whitespace.
See also number(), toUShort(), toInt(), and QLocale::toShort().
std::string QString::toStdString() const
Returns a std::string object with the data contained in this QString. The Unicode data is converted into 8-bit characters using the toUtf8() function.
This method is mostly useful to pass a QString to a function that accepts a std::string object.
See also toLatin1(), toUtf8(), toLocal8Bit(), and QByteArray::toStdString().
std::u16string QString::toStdU16String() const
Returns a std::u16string object with the data contained in this QString. The Unicode data is the same as returned by the utf16() method.
This function was introduced in Qt 5.5.
See also utf16(), toStdWString(), and toStdU32String().
std::u32string QString::toStdU32String() const
Returns a std::u32string object with the data contained in this QString. The Unicode data is the same as returned by the toUcs4() method.
This function was introduced in Qt 5.5.
See also toUcs4(), toStdWString(), and toStdU16String().
std::wstring QString::toStdWString() const
Returns a std::wstring object with the data contained in this QString. The std::wstring is encoded in utf16 on platforms where wchar_t is 2 bytes wide (e.g. windows) and in ucs4 on platforms where wchar_t is 4 bytes wide (most Unix systems).
This method is mostly useful to pass a QString to a function that accepts a std::wstring object.
See also utf16(), toLatin1(), toUtf8(), toLocal8Bit(), toStdU16String(), and toStdU32String().
uint QString::toUInt(bool *ok = nullptr, int base = 10) const
Returns the string converted to an unsigned int using base base, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.
If ok is not nullptr, failure is reported by setting *ok to false, and success by setting *ok to true.
If base is 0, the C language convention is used: If the string begins with "0x", base 16 is used; if the string begins with "0", base 8 is used; otherwise, base 10 is used.
The string conversion will always happen in the 'C' locale. For locale dependent conversion use QLocale::toUInt()
Example:
 QString str = "FF";
 bool ok;

 uint hex = str.toUInt(&ok, 16);     // hex == 255, ok == true
 uint dec = str.toUInt(&ok, 10);     // dec == 0, ok == false
This function ignores leading and trailing whitespace.
See also number(), toInt(), and QLocale::toUInt().
ulong QString::toULong(bool *ok = nullptr, int base = 10) const
Returns the string converted to an unsigned long using base base, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.
If ok is not nullptr, failure is reported by setting *ok to false, and success by setting *ok to true.
If base is 0, the C language convention is used: If the string begins with "0x", base 16 is used; if the string begins with "0", base 8 is used; otherwise, base 10 is used.
The string conversion will always happen in the 'C' locale. For locale dependent conversion use QLocale::toULongLong()
Example:
 QString str = "FF";
 bool ok;

 ulong hex = str.toULong(&ok, 16);   // hex == 255, ok == true
 ulong dec = str.toULong(&ok, 10);   // dec == 0, ok == false
This function ignores leading and trailing whitespace.
See also number() and QLocale::toUInt().
qulonglong QString::toULongLong(bool *ok = nullptr, int base = 10) const
Returns the string converted to an unsigned long long using base base, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.
If ok is not nullptr, failure is reported by setting *ok to false, and success by setting *ok to true.
If base is 0, the C language convention is used: If the string begins with "0x", base 16 is used; if the string begins with "0", base 8 is used; otherwise, base 10 is used.
The string conversion will always happen in the 'C' locale. For locale dependent conversion use QLocale::toULongLong()
Example:
 QString str = "FF";
 bool ok;

 quint64 hex = str.toULongLong(&ok, 16);    // hex == 255, ok == true
 quint64 dec = str.toULongLong(&ok, 10);    // dec == 0, ok == false
This function ignores leading and trailing whitespace.
See also number(), toLongLong(), and QLocale::toULongLong().
ushort QString::toUShort(bool *ok = nullptr, int base = 10) const
Returns the string converted to an unsigned short using base base, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.
If ok is not nullptr, failure is reported by setting *ok to false, and success by setting *ok to true.
If base is 0, the C language convention is used: If the string begins with "0x", base 16 is used; if the string begins with "0", base 8 is used; otherwise, base 10 is used.
The string conversion will always happen in the 'C' locale. For locale dependent conversion use QLocale::toUShort()
Example:
 QString str = "FF";
 bool ok;

 ushort hex = str.toUShort(&ok, 16);     // hex == 255, ok == true
 ushort dec = str.toUShort(&ok, 10);     // dec == 0, ok == false
This function ignores leading and trailing whitespace.
See also number(), toShort(), and QLocale::toUShort().
QVector<uint> QString::toUcs4() const
Returns a UCS-4/UTF-32 representation of the string as a QVector<uint>.
UCS-4 is a Unicode codec and therefore it is lossless. All characters from this string will be encoded in UCS-4. Any invalid sequence of code units in this string is replaced by the Unicode's replacement character (QChar::ReplacementCharacter, which corresponds to U+FFFD).
The returned vector is not \0'-terminated.
This function was introduced in Qt 4.2.
See also fromUtf8(), toUtf8(), toLatin1(), toLocal8Bit(), QTextCodec, fromUcs4(), and toWCharArray().
QString QString::toUpper() const
Returns an uppercase copy of the string.
 QString str = "TeXt";
 str = str.toUpper();        // str == "TEXT"
The case conversion will always happen in the 'C' locale. For locale dependent case folding use QLocale::toUpper()
See also toLower() and QLocale::toLower().
QByteArray QString::toUtf8() const
Returns a UTF-8 representation of the string as a QByteArray.
UTF-8 is a Unicode codec and can represent all characters in a Unicode string like QString.
See also fromUtf8(), toLatin1(), toLocal8Bit(), and QTextCodec.
int QString::toWCharArray(wchar_t *array) const
Fills the array with the data contained in this QString object. The array is encoded in UTF-16 on platforms where wchar_t is 2 bytes wide (e.g. windows) and in UCS-4 on platforms where wchar_t is 4 bytes wide (most Unix systems).
array has to be allocated by the caller and contain enough space to hold the complete string (allocating the array with the same length as the string is always sufficient).
This function returns the actual length of the string in array.
Note: This function does not append a null character to the array.
This function was introduced in Qt 4.2.
See also utf16(), toUcs4(), toLatin1(), toUtf8(), toLocal8Bit(), toStdWString(), and QStringView::toWCharArray().
QString QString::trimmed() const
Returns a string that has whitespace removed from the start and the end.
Whitespace means any character for which QChar::isSpace() returns true. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.
Example:
 QString str = "  lots\t of\nwhitespace\r\n ";
 str = str.trimmed();
 // str == "lots\t of\nwhitespace"
Unlike simplified(), trimmed() leaves internal whitespace alone.
See also simplified().
void QString::truncate(int position)
Truncates the string at the given position index.
If the specified position index is beyond the end of the string, nothing happens.
Example:
 QString str = "Vladivostok";
 str.truncate(4);
 // str == "Vlad"
If position is negative, it is equivalent to passing zero.
See also chop(), resize(), left(), and QStringRef::truncate().
const QChar *QString::unicode() const
Returns a Unicode representation of the string. The result remains valid until the string is modified.
Note: The returned string may not be '\0'-terminated. Use size() to determine the length of the array.
See also setUnicode(), utf16(), and fromRawData().
const ushort *QString::utf16() const
Returns the QString as a '\0'-terminated array of unsigned shorts. The result remains valid until the string is modified.
The returned string is in host byte order.
See also setUtf16() and unicode().
[static] QString QString::vasprintf(const char *cformat, va_list ap)
Equivalent method to asprintf(), but takes a va_list ap instead a list of variable arguments. See the asprintf() documentation for an explanation of cformat.
This method does not call the va_end macro, the caller is responsible to call va_end on ap.
This function was introduced in Qt 5.5.
See also asprintf().
bool QString::operator!=(QLatin1String other) const
Returns true if this string is not equal to parameter string other. Otherwise returns false.
This function overloads operator!=().
bool QString::operator!=(const char *other) const
This function overloads operator!=().
The other const char pointer is converted to a QString using the fromUtf8() function.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
bool QString::operator!=(const QByteArray &other) const
This function overloads operator!=().
The other byte array is converted to a QString using the fromUtf8() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
QString &QString::operator+=(QChar ch)
This function overloads operator+=().
Appends the character ch to the string.
QString &QString::operator+=(const QString &other)
Appends the string other onto the end of this string and returns a reference to this string.
Example:
 QString x = "free";
 QString y = "dom";
 x += y;
 // x == "freedom"
This operation is typically very fast (constant time), because QString preallocates extra space at the end of the string data so it can grow without reallocating the entire string each time.
See also append() and prepend().
QString &QString::operator+=(const QStringRef &str)
This function overloads operator+=().
Appends the string section referenced by str to this string.
QString &QString::operator+=(QLatin1String str)
This function overloads operator+=().
Appends the Latin-1 string str to this string.
QString &QString::operator+=(const char *str)
This function overloads operator+=().
Appends the string str to this string. The const char pointer is converted to Unicode using the fromUtf8() function.
You can disable this function by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
QString &QString::operator+=(const QByteArray &ba)
This function overloads operator+=().
Appends the byte array ba to this string. The byte array is converted to Unicode using the fromUtf8() function. If any NUL characters ('\0') are embedded in the ba byte array, they will be included in the transformation.
You can disable this function by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
QString &QString::operator+=(char ch)
This function overloads operator+=().
Appends the character ch to this string. Note that the character is converted to Unicode using the fromLatin1() function, unlike other 8-bit functions that operate on UTF-8 data.
You can disable this function by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
bool QString::operator<(QLatin1String other) const
This function overloads operator<().
Returns true if this string is lexically less than the parameter string called other; otherwise returns false.
bool QString::operator<(const char *other) const
Returns true if this string is lexically less than string other. Otherwise returns false.
This function overloads operator<().
The other const char pointer is converted to a QString using the fromUtf8() function.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
bool QString::operator<(const QByteArray &other) const
This function overloads operator<().
The other byte array is converted to a QString using the fromUtf8() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
bool QString::operator<=(QLatin1String other) const
Returns true if this string is lexically less than or equal to parameter string other. Otherwise returns false.
This function overloads operator<=().
bool QString::operator<=(const char *other) const
This function overloads operator<=().
The other const char pointer is converted to a QString using the fromUtf8() function.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
bool QString::operator<=(const QByteArray &other) const
This function overloads operator<=().
The other byte array is converted to a QString using the fromUtf8() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
QString &QString::operator=(QChar ch)
This function overloads operator=().
Sets the string to contain the single character ch.
QString &QString::operator=(QLatin1String str)
This function overloads operator=().
Assigns the Latin-1 string str to this string.
QString &QString::operator=(const char *str)
This function overloads operator=().
Assigns str to this string. The const char pointer is converted to Unicode using the fromUtf8() function.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII or QT_RESTRICTED_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII and QT_RESTRICTED_CAST_FROM_ASCII.
QString &QString::operator=(char ch)
This function overloads operator=().
Assigns character ch to this string. Note that the character is converted to Unicode using the fromLatin1() function, unlike other 8-bit functions that operate on UTF-8 data.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
bool QString::operator==(QLatin1String other) const
This function overloads operator==().
Returns true if this string is equal to other; otherwise returns false.
bool QString::operator==(const char *other) const
This function overloads operator==().
The other const char pointer is converted to a QString using the fromUtf8() function.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
bool QString::operator==(const QByteArray &other) const
This function overloads operator==().
The other byte array is converted to a QString using the fromUtf8() function. This function stops conversion at the first NUL character found, or the end of the byte array.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
Returns true if this string is lexically equal to the parameter string other. Otherwise returns false.
See also QT_NO_CAST_FROM_ASCII.
bool QString::operator>(QLatin1String other) const
This function overloads operator>().
Returns true if this string is lexically greater than the parameter string other; otherwise returns false.
bool QString::operator>(const char *other) const
This function overloads operator>().
The other const char pointer is converted to a QString using the fromUtf8() function.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
bool QString::operator>(const QByteArray &other) const
This function overloads operator>().
The other byte array is converted to a QString using the fromUtf8() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
bool QString::operator>=(QLatin1String other) const
Returns true if this string is lexically greater than or equal to parameter string other. Otherwise returns false.
This function overloads operator>=().
bool QString::operator>=(const char *other) const
This function overloads operator>=().
The other const char pointer is converted to a QString using the fromUtf8() function.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
bool QString::operator>=(const QByteArray &other) const
This function overloads operator>=().
The other byte array is converted to a QString using the fromUtf8() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.
You can disable this operator by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.
See also QT_NO_CAST_FROM_ASCII.
QCharRef QString::operator[](int position)
Returns the character at the specified position in the string as a modifiable reference.
Example:
 QString str;

 if (str[0] == QChar('?'))
     str[0] = QChar('_');
The return value is of type QCharRef, a helper class for QString. When you get an object of type QCharRef, you can use it as if it were a reference to a QChar. If you assign to it, the assignment will apply to the character in the QString from which you got the reference.
Note: Before Qt 5.14 it was possible to use this operator to access a character at an out-of-bounds position in the string, and then assign to such a position, causing the string to be automatically resized. Furthermore, assigning a value to the returned QCharRef would cause a detach of the string, even if the string has been copied in the meanwhile (and the QCharRef kept alive while the copy was taken). These behaviors are deprecated, and will be changed in a future version of Qt.
See also at().
const QChar QString::operator[](int position) const
This function overloads operator[]().
const QChar QString::operator[](uint position) const
Equivalent to at(position). 
This function overloads operator[]().
QCharRef QString::operator[](uint position)
This function overloads operator[]().
Returns the character at the specified position in the string as a modifiable reference.
Related Non-Members
bool operator!=(const QString &s1, const QString &s2)
Returns true if string s1 is not equal to string s2; otherwise returns false.
See also Comparing Strings.
bool operator!=(const char *s1, const QString &s2)
Returns true if s1 is not equal to s2; otherwise returns false.
For s1 != 0, this is equivalent to compare( s1, s2 ) != 0. Note that no string is equal to s1 being 0.
const QString operator+(const QString &s1, const QString &s2)
Returns a string which is the result of concatenating s1 and s2.
const QString operator+(const QString &s1, const char *s2)
Returns a string which is the result of concatenating s1 and s2 (s2 is converted to Unicode using the QString::fromUtf8() function).
See also QString::fromUtf8().
const QString operator+(const char *s1, const QString &s2)
Returns a string which is the result of concatenating s1 and s2 (s1 is converted to Unicode using the QString::fromUtf8() function).
See also QString::fromUtf8().
const QString operator+(char ch, const QString &s)
Returns a string which is the result of concatenating the character ch and the string s.
const QString operator+(const QString &s, char ch)
Returns a string which is the result of concatenating the string s and the character ch.
bool operator<(const QString &s1, const QString &s2)
Returns true if string s1 is lexically less than string s2; otherwise returns false.
See also Comparing Strings.
bool operator<(const char *s1, const QString &s2)
Returns true if s1 is lexically less than s2; otherwise returns false. For s1 != 0, this is equivalent to compare(s1, s2) < 0.
See also Comparing Strings.
QDataStream &operator<<(QDataStream &stream, const QString &string)
Writes the given string to the specified stream.
See also Serializing Qt Data Types.
bool operator<=(const QString &s1, const QString &s2)
Returns true if string s1 is lexically less than or equal to string s2; otherwise returns false.
See also Comparing Strings.
bool operator<=(const char *s1, const QString &s2)
Returns true if s1 is lexically less than or equal to s2; otherwise returns false. For s1 != 0, this is equivalent to compare(s1, s2) <= 0.
See also Comparing Strings.
bool operator==(const QString &s1, const QString &s2)
Returns true if string s1 is equal to string s2; otherwise returns false.
See also Comparing Strings.
bool operator==(const char *s1, const QString &s2)
This function overloads operator==().
Returns true if s1 is equal to s2; otherwise returns false. Note that no string is equal to s1 being 0.
Equivalent to s1 != 0 && compare(s1, s2) == 0.
bool operator>(const QString &s1, const QString &s2)
Returns true if string s1 is lexically greater than string s2; otherwise returns false.
See also Comparing Strings.
bool operator>(const char *s1, const QString &s2)
Returns true if s1 is lexically greater than s2; otherwise returns false. Equivalent to compare(s1, s2) > 0.
See also Comparing Strings.
bool operator>=(const QString &s1, const QString &s2)
Returns true if string s1 is lexically greater than or equal to string s2; otherwise returns false.
See also Comparing Strings.
bool operator>=(const char *s1, const QString &s2)
Returns true if s1 is lexically greater than or equal to s2; otherwise returns false. For s1 != 0, this is equivalent to compare(s1, s2) >= 0.
See also Comparing Strings.
QDataStream &operator>>(QDataStream &stream, QString &string)
Reads a string from the specified stream into the given string.
See also Serializing Qt Data Types.
Macro Documentation
QStringLiteral(str)
The macro generates the data for a QString out of the string literal str at compile time. Creating a QString from it is free in this case, and the generated string data is stored in the read-only segment of the compiled object file.
If you have code that looks like this:
 // hasAttribute takes a QString argument
 if (node.hasAttribute("http-contents-length")) //...
then a temporary QString will be created to be passed as the hasAttribute function parameter. This can be quite expensive, as it involves a memory allocation and the copy/conversion of the data into QString's internal encoding.
This cost can be avoided by using QStringLiteral instead:
 if (node.hasAttribute(QStringLiteral(u"http-contents-length"))) //...
In this case, QString's internal data will be generated at compile time; no conversion or allocation will occur at runtime.
Using QStringLiteral instead of a double quoted plain C++ string literal can significantly speed up creation of QString instances from data known at compile time.
Note: QLatin1String can still be more efficient than QStringLiteral when the string is passed to a function that has an overload taking QLatin1String and this overload avoids conversion to QString. For instance, QString::operator==() can compare to a QLatin1String directly:
 if (attribute.name() == QLatin1String("http-contents-length")) //...
Note: Some compilers have bugs encoding strings containing characters outside the US-ASCII character set. Make sure you prefix your string with u in those cases. It is optional otherwise.
See also QByteArrayLiteral.
QT_NO_CAST_FROM_ASCII
Disables automatic conversions from 8-bit strings (char *) to unicode QStrings
See also QT_NO_CAST_TO_ASCII, QT_RESTRICTED_CAST_FROM_ASCII, and QT_NO_CAST_FROM_BYTEARRAY.
QT_NO_CAST_TO_ASCII
disables automatic conversion from QString to 8-bit strings (char *)
See also QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII, and QT_NO_CAST_FROM_BYTEARRAY.
QT_RESTRICTED_CAST_FROM_ASCII
Defining this macro disables most automatic conversions from source literals and 8-bit data to unicode QStrings, but allows the use of the QChar(char) and QString(const char (&ch)[N] constructors, and the QString::operator=(const char (&ch)[N]) assignment operator giving most of the type-safety benefits of QT_NO_CAST_FROM_ASCII but does not require user code to wrap character and string literals with QLatin1Char, QLatin1String or similar.
Using this macro together with source strings outside the 7-bit range, non-literals, or literals with embedded NUL characters is undefined.
See also QT_NO_CAST_FROM_ASCII and QT_NO_CAST_TO_ASCII. 
 2020 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners.
The documentation provided herein is licensed under the terms of the GNU Free Documentation License version 1.3 as published by the Free Software Foundation.
Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners. 

Qt 5.15
Qt Core
C++ Classes
QObject
Qt 5.15.1 Reference Documentation 
Contents
Properties
Public Functions
Public Slots
Signals
Static Public Members
Protected Functions
Related Non-Members
Macros
Detailed Description
Thread Affinity
No Copy Constructor or Assignment Operator
Auto-Connection
Dynamic Properties
Internationalization (I18n)
QObject Class
The QObject class is the base class of all Qt objects. More...

Header:
#include <QObject> 
qmake:
QT += core
Inherited By:
QAbstractAnimation, QAbstractEventDispatcher, QAbstractItemDelegate, QAbstractItemModel, QAbstractNetworkCache, QAbstractState, QAbstractTextDocumentLayout, QAbstractTransition, QAccessiblePlugin, QAction, QActionGroup, QAxFactory, QAxObject, QAxScript, QAxScriptManager, QButtonGroup, QClipboard, QCompleter, QCoreApplication, QDataWidgetMapper, QDBusAbstractAdaptor, QDBusAbstractInterface, QDBusPendingCallWatcher, QDBusServer, QDBusServiceWatcher, QDBusVirtualObject, QDesignerFormEditorInterface, QDesignerFormWindowManagerInterface, QDnsLookup, QDrag, QDtls, QDtlsClientVerifier, QEventLoop, QExtensionFactory, QExtensionManager, QFileSelector, QFileSystemWatcher, QFutureWatcher, QGenericPlugin, QGesture, QGraphicsAnchor, QGraphicsEffect, QGraphicsItemAnimation, QGraphicsObject, QGraphicsScene, QGraphicsTransform, QHttpMultiPart, QIconEnginePlugin, QImageIOPlugin, QInputMethod, QIODevice, QItemSelectionModel, QJSEngine, QLayout, QLibrary, QLocalServer, QMacToolBar, QMacToolBarItem, QMimeData, QMovie, QNetworkAccessManager, QNetworkConfigurationManager, QNetworkCookieJar, QNetworkSession, QObjectCleanupHandler, QOffscreenSurface, QOpenGLContext, QOpenGLContextGroup, QOpenGLDebugLogger, QOpenGLShader, QOpenGLShaderProgram, QOpenGLTimeMonitor, QOpenGLTimerQuery, QOpenGLVertexArrayObject, QPdfWriter, QPictureFormatPlugin, QPluginLoader, QQmlComponent, QQmlContext, QQmlEngineExtensionPlugin, QQmlExpression, QQmlFileSelector, QQmlPropertyMap, QQuickImageResponse, QQuickItem, QQuickItemGrabResult, QQuickRenderControl, QQuickTextDocument, QQuickTextureFactory, QScreen, QScroller, QSessionManager, QSettings, QSGAbstractRenderer, QSGEngine, QSGTexture, QSGTextureProvider, QSharedMemory, QShortcut, QSignalMapper, QSocketNotifier, QStyle, QStyleHints, QStylePlugin, QSyntaxHighlighter, QSystemTrayIcon, QTcpServer, QTextDocument, QTextObject, QThread, QThreadPool, QTimeLine, QTimer, QTranslator, QUndoGroup, QUndoStack, QValidator, QWidget, QWindow, QWinEventNotifier, QWinJumpList, QWinTaskbarButton, QWinTaskbarProgress, QWinThumbnailToolBar, and QWinThumbnailToolButton

List of all members, including inherited members
Obsolete members
Note: All functions in this class are reentrant.
Note: These functions are also thread-safe:
connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)
connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type) const
connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type)
connect(const QObject *sender, PointerToMemberFunction signal, Functor functor)
connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type)
disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)
disconnect(const char *signal, const QObject *receiver, const char *method) const
disconnect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method)
deleteLater() 
Properties
objectName : QString 
Public Functions


QObject(QObject *parent = nullptr)
virtual 
~QObject()
bool 
blockSignals(bool block)
const QObjectList &
children() const
QMetaObject::Connection 
connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type = Qt::AutoConnection) const
bool 
disconnect(const char *signal = nullptr, const QObject *receiver = nullptr, const char *method = nullptr) const
bool 
disconnect(const QObject *receiver, const char *method = nullptr) const
void 
dumpObjectInfo() const
void 
dumpObjectTree() const
QList<QByteArray> 
dynamicPropertyNames() const
virtual bool 
event(QEvent *e)
virtual bool 
eventFilter(QObject *watched, QEvent *event)
T 
findChild(const QString &name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
QList<T> 
findChildren(const QString &name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
QList<T> 
findChildren(const QRegularExpression &re, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
bool 
inherits(const char *className) const
void 
installEventFilter(QObject *filterObj)
bool 
isWidgetType() const
bool 
isWindowType() const
void 
killTimer(int id)
virtual const QMetaObject *
metaObject() const
void 
moveToThread(QThread *targetThread)
QString 
objectName() const
QObject *
parent() const
QVariant 
property(const char *name) const
void 
removeEventFilter(QObject *obj)
void 
setObjectName(const QString &name)
void 
setParent(QObject *parent)
bool 
setProperty(const char *name, const QVariant &value)
bool 
signalsBlocked() const
int 
startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer)
int 
startTimer(std::chrono::milliseconds time, Qt::TimerType timerType = Qt::CoarseTimer)
QThread *
thread() const

Public Slots

void 
deleteLater()

Signals

void 
destroyed(QObject *obj = nullptr)
void 
objectNameChanged(const QString &objectName)

Static Public Members

QMetaObject::Connection 
connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)
QMetaObject::Connection 
connect(const QObject *sender, const QMetaMethod &signal, const QObject *receiver, const QMetaMethod &method, Qt::ConnectionType type = Qt::AutoConnection)
QMetaObject::Connection 
connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type = Qt::AutoConnection)
QMetaObject::Connection 
connect(const QObject *sender, PointerToMemberFunction signal, Functor functor)
QMetaObject::Connection 
connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type = Qt::AutoConnection)
bool 
disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)
bool 
disconnect(const QObject *sender, const QMetaMethod &signal, const QObject *receiver, const QMetaMethod &method)
bool 
disconnect(const QMetaObject::Connection &connection)
bool 
disconnect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method)
const QMetaObject 
staticMetaObject
QString 
tr(const char *sourceText, const char *disambiguation = nullptr, int n = -1)

Protected Functions

virtual void 
childEvent(QChildEvent *event)
virtual void 
connectNotify(const QMetaMethod &signal)
virtual void 
customEvent(QEvent *event)
virtual void 
disconnectNotify(const QMetaMethod &signal)
bool 
isSignalConnected(const QMetaMethod &signal) const
int 
receivers(const char *signal) const
QObject *
sender() const
int 
senderSignalIndex() const
virtual void 
timerEvent(QTimerEvent *event)

Related Non-Members

typedef 
QObjectList
QList<T> 
qFindChildren(const QObject *obj, const QRegExp &regExp)
T 
qobject_cast(QObject *object)
T 
qobject_cast(const QObject *object)

Macros


QT_NO_NARROWING_CONVERSIONS_IN_CONNECT

Q_CLASSINFO(Name, Value)

Q_DISABLE_COPY(Class)

Q_DISABLE_COPY_MOVE(Class)

Q_DISABLE_MOVE(Class)

Q_EMIT

Q_ENUM(...)

Q_ENUM_NS(...)

Q_FLAG(...)

Q_FLAG_NS(...)

Q_GADGET

Q_INTERFACES(...)

Q_INVOKABLE

Q_NAMESPACE

Q_NAMESPACE_EXPORT(EXPORT_MACRO)

Q_OBJECT

Q_PROPERTY(...)

Q_REVISION

Q_SET_OBJECT_NAME(Object)

Q_SIGNAL

Q_SIGNALS

Q_SLOT

Q_SLOTS

Detailed Description
QObject is the heart of the Qt Object Model. The central feature in this model is a very powerful mechanism for seamless object communication called signals and slots. You can connect a signal to a slot with connect() and destroy the connection with disconnect(). To avoid never ending notification loops you can temporarily block signals with blockSignals(). The protected functions connectNotify() and disconnectNotify() make it possible to track connections.
QObjects organize themselves in object trees. When you create a QObject with another object as parent, the object will automatically add itself to the parent's children() list. The parent takes ownership of the object; i.e., it will automatically delete its children in its destructor. You can look for an object by name and optionally type using findChild() or findChildren().
Every object has an objectName() and its class name can be found via the corresponding metaObject() (see QMetaObject::className()). You can determine whether the object's class inherits another class in the QObject inheritance hierarchy by using the inherits() function.
When an object is deleted, it emits a destroyed() signal. You can catch this signal to avoid dangling references to QObjects.
QObjects can receive events through event() and filter the events of other objects. See installEventFilter() and eventFilter() for details. A convenience handler, childEvent(), can be reimplemented to catch child events.
Last but not least, QObject provides the basic timer support in Qt; see QTimer for high-level support for timers.
Notice that the Q_OBJECT macro is mandatory for any object that implements signals, slots or properties. You also need to run the Meta Object Compiler on the source file. We strongly recommend the use of this macro in all subclasses of QObject regardless of whether or not they actually use signals, slots and properties, since failure to do so may lead certain functions to exhibit strange behavior.
All Qt widgets inherit QObject. The convenience function isWidgetType() returns whether an object is actually a widget. It is much faster than qobject_cast<QWidget *>(obj) or obj->inherits("QWidget").
Some QObject functions, e.g. children(), return a QObjectList. QObjectList is a typedef for QList<QObject *>. 
Thread Affinity
A QObject instance is said to have a thread affinity, or that it lives in a certain thread. When a QObject receives a queued signal or a posted event, the slot or event handler will run in the thread that the object lives in.
Note: If a QObject has no thread affinity (that is, if thread() returns zero), or if it lives in a thread that has no running event loop, then it cannot receive queued signals or posted events.
By default, a QObject lives in the thread in which it is created. An object's thread affinity can be queried using thread() and changed using moveToThread().
All QObjects must live in the same thread as their parent. Consequently:
setParent() will fail if the two QObjects involved live in different threads.
When a QObject is moved to another thread, all its children will be automatically moved too.
moveToThread() will fail if the QObject has a parent.
If QObjects are created within QThread::run(), they cannot become children of the QThread object because the QThread does not live in the thread that calls QThread::run().
Note: A QObject's member variables do not automatically become its children. The parent-child relationship must be set by either passing a pointer to the child's constructor, or by calling setParent(). Without this step, the object's member variables will remain in the old thread when moveToThread() is called. 
No Copy Constructor or Assignment Operator
QObject has neither a copy constructor nor an assignment operator. This is by design. Actually, they are declared, but in a private section with the macro Q_DISABLE_COPY(). In fact, all Qt classes derived from QObject (direct or indirect) use this macro to declare their copy constructor and assignment operator to be private. The reasoning is found in the discussion on Identity vs Value on the Qt Object Model page.
The main consequence is that you should use pointers to QObject (or to your QObject subclass) where you might otherwise be tempted to use your QObject subclass as a value. For example, without a copy constructor, you can't use a subclass of QObject as the value to be stored in one of the container classes. You must store pointers. 
Auto-Connection
Qt's meta-object system provides a mechanism to automatically connect signals and slots between QObject subclasses and their children. As long as objects are defined with suitable object names, and slots follow a simple naming convention, this connection can be performed at run-time by the QMetaObject::connectSlotsByName() function.
uic generates code that invokes this function to enable auto-connection to be performed between widgets on forms created with Qt Designer. More information about using auto-connection with Qt Designer is given in the Using a Designer UI File in Your C++ Application section of the Qt Designer manual. 
Dynamic Properties
From Qt 4.2, dynamic properties can be added to and removed from QObject instances at run-time. Dynamic properties do not need to be declared at compile-time, yet they provide the same advantages as static properties and are manipulated using the same API - using property() to read them and setProperty() to write them.
From Qt 4.3, dynamic properties are supported by Qt Designer, and both standard Qt widgets and user-created forms can be given dynamic properties. 
Internationalization (I18n)
All QObject subclasses support Qt's translation features, making it possible to translate an application's user interface into different languages.
To make user-visible text translatable, it must be wrapped in calls to the tr() function. This is explained in detail in the Writing Source Code for Translation document.
See also QMetaObject, QPointer, QObjectCleanupHandler, Q_DISABLE_COPY(), and Object Trees & Ownership.
Property Documentation
objectName : QString
This property holds the name of this object
You can find an object by name (and type) using findChild(). You can find a set of objects with findChildren().
 qDebug("MyClass::setPrecision(): (%s) invalid precision %f",
        qPrintable(objectName()), newPrecision);
By default, this property contains an empty string.
Access functions:

QString 
objectName() const
void 
setObjectName(const QString &name)

Notifier signal:

void 
objectNameChanged(const QString &objectName)
[see note below]

Note: This is a private signal. It can be used in signal connections but cannot be emitted by the user.
See also metaObject() and QMetaObject::className().
Member Function Documentation
QObject::QObject(QObject *parent = nullptr)
Constructs an object with parent object parent.
The parent of an object may be viewed as the object's owner. For instance, a dialog box is the parent of the OK and Cancel buttons it contains.
The destructor of a parent object destroys all child objects.
Setting parent to nullptr constructs an object with no parent. If the object is a widget, it will become a top-level window.
Note: This function can be invoked via the meta-object system and from QML. See Q_INVOKABLE.
See also parent(), findChild(), and findChildren().
[slot] void QObject::deleteLater()
Schedules this object for deletion.
The object will be deleted when control returns to the event loop. If the event loop is not running when this function is called (e.g. deleteLater() is called on an object before QCoreApplication::exec()), the object will be deleted once the event loop is started. If deleteLater() is called after the main event loop has stopped, the object will not be deleted. Since Qt 4.8, if deleteLater() is called on an object that lives in a thread with no running event loop, the object will be destroyed when the thread finishes.
Note that entering and leaving a new event loop (e.g., by opening a modal dialog) will not perform the deferred deletion; for the object to be deleted, the control must return to the event loop from which deleteLater() was called. This does not apply to objects deleted while a previous, nested event loop was still running: the Qt event loop will delete those objects as soon as the new nested event loop starts.
Note: It is safe to call this function more than once; when the first deferred deletion event is delivered, any pending events for the object are removed from the event queue.
Note: This function is thread-safe.
See also destroyed() and QPointer.
[signal] void QObject::destroyed(QObject *obj = nullptr)
This signal is emitted immediately before the object obj is destroyed, after any instances of QPointer have been notified, and cannot be blocked.
All the objects's children are destroyed immediately after this signal is emitted.
See also deleteLater() and QPointer.
[signal] void QObject::objectNameChanged(const QString &objectName)
This signal is emitted after the object's name has been changed. The new object name is passed as objectName.
Note: This is a private signal. It can be used in signal connections but cannot be emitted by the user.
Note: Notifier signal for property objectName. 
See also QObject::objectName.
[virtual] QObject::~QObject()
Destroys the object, deleting all its child objects.
All signals to and from the object are automatically disconnected, and any pending posted events for the object are removed from the event queue. However, it is often safer to use deleteLater() rather than deleting a QObject subclass directly.
Warning: All child objects are deleted. If any of these objects are on the stack or global, sooner or later your program will crash. We do not recommend holding pointers to child objects from outside the parent. If you still do, the destroyed() signal gives you an opportunity to detect when an object is destroyed.
Warning: Deleting a QObject while pending events are waiting to be delivered can cause a crash. You must not delete the QObject directly if it exists in a different thread than the one currently executing. Use deleteLater() instead, which will cause the event loop to delete the object after all pending events have been delivered to it.
See also deleteLater().
bool QObject::blockSignals(bool block)
If block is true, signals emitted by this object are blocked (i.e., emitting a signal will not invoke anything connected to it). If block is false, no such blocking will occur.
The return value is the previous value of signalsBlocked().
Note that the destroyed() signal will be emitted even if the signals for this object have been blocked.
Signals emitted while being blocked are not buffered.
See also signalsBlocked() and QSignalBlocker.
[virtual protected] void QObject::childEvent(QChildEvent *event)
This event handler can be reimplemented in a subclass to receive child events. The event is passed in the event parameter.
QEvent::ChildAdded and QEvent::ChildRemoved events are sent to objects when children are added or removed. In both cases you can only rely on the child being a QObject, or if isWidgetType() returns true, a QWidget. (This is because, in the ChildAdded case, the child is not yet fully constructed, and in the ChildRemoved case it might have been destructed already).
QEvent::ChildPolished events are sent to widgets when children are polished, or when polished children are added. If you receive a child polished event, the child's construction is usually completed. However, this is not guaranteed, and multiple polish events may be delivered during the execution of a widget's constructor.
For every child widget, you receive one ChildAdded event, zero or more ChildPolished events, and one ChildRemoved event.
The ChildPolished event is omitted if a child is removed immediately after it is added. If a child is polished several times during construction and destruction, you may receive several child polished events for the same child, each time with a different virtual table.
See also event().
const QObjectList &QObject::children() const
Returns a list of child objects. The QObjectList class is defined in the <QObject> header file as the following:
 typedef QList<QObject*> QObjectList;
The first child added is the first object in the list and the last child added is the last object in the list, i.e. new children are appended at the end.
Note that the list order changes when QWidget children are raised or lowered. A widget that is raised becomes the last object in the list, and a widget that is lowered becomes the first object in the list.
See also findChild(), findChildren(), parent(), and setParent().
[static] QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)
Creates a connection of the given type from the signal in the sender object to the method in the receiver object. Returns a handle to the connection that can be used to disconnect it later.
You must use the SIGNAL() and SLOT() macros when specifying the signal and the method, for example:
 QLabel *label = new QLabel;
 QScrollBar *scrollBar = new QScrollBar;
 QObject::connect(scrollBar, SIGNAL(valueChanged(int)),
                  label,  SLOT(setNum(int)));
This example ensures that the label always displays the current scroll bar value. Note that the signal and slots parameters must not contain any variable names, only the type. E.g. the following would not work and return false:
 // WRONG
 QObject::connect(scrollBar, SIGNAL(valueChanged(int value)),
                  label, SLOT(setNum(int value)));
A signal can also be connected to another signal:
 class MyWidget : public QWidget
 {
     Q_OBJECT

 public:
     MyWidget();

 signals:
     void buttonClicked();

 private:
     QPushButton *myButton;
 };

 MyWidget::MyWidget()
 {
     myButton = new QPushButton(this);
     connect(myButton, SIGNAL(clicked()),
             this, SIGNAL(buttonClicked()));
 }
In this example, the MyWidget constructor relays a signal from a private member variable, and makes it available under a name that relates to MyWidget.
A signal can be connected to many slots and signals. Many signals can be connected to one slot.
If a signal is connected to several slots, the slots are activated in the same order in which the connections were made, when the signal is emitted.
The function returns a QMetaObject::Connection that represents a handle to a connection if it successfully connects the signal to the slot. The connection handle will be invalid if it cannot create the connection, for example, if QObject is unable to verify the existence of either signal or method, or if their signatures aren't compatible. You can check if the handle is valid by casting it to a bool.
By default, a signal is emitted for every connection you make; two signals are emitted for duplicate connections. You can break all of these connections with a single disconnect() call. If you pass the Qt::UniqueConnection type, the connection will only be made if it is not a duplicate. If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return an invalid QMetaObject::Connection.
Note: Qt::UniqueConnections do not work for lambdas, non-member functions and functors; they only apply to connecting to member functions.
The optional type parameter describes the type of connection to establish. In particular, it determines whether a particular signal is delivered to a slot immediately or queued for delivery at a later time. If the signal is queued, the parameters must be of types that are known to Qt's meta-object system, because Qt needs to copy the arguments to store them in an event behind the scenes. If you try to use a queued connection and get the error message
 QObject::connect: Cannot queue arguments of type 'MyType'
 (Make sure 'MyType' is registered using qRegisterMetaType().)
call qRegisterMetaType() to register the data type before you establish the connection.
Note: This function is thread-safe.
See also disconnect(), sender(), qRegisterMetaType(), Q_DECLARE_METATYPE(), and Differences between String-Based and Functor-Based Connections.
[static] QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &signal, const QObject *receiver, const QMetaMethod &method, Qt::ConnectionType type = Qt::AutoConnection)
Creates a connection of the given type from the signal in the sender object to the method in the receiver object. Returns a handle to the connection that can be used to disconnect it later.
The Connection handle will be invalid if it cannot create the connection, for example, the parameters were invalid. You can check if the QMetaObject::Connection is valid by casting it to a bool.
This function works in the same way as connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type) but it uses QMetaMethod to specify signal and method.
This function was introduced in Qt 4.8.
See also connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type).
QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type = Qt::AutoConnection) const
This function overloads connect().
Connects signal from the sender object to this object's method.
Equivalent to connect(sender, signal, this, method, type).
Every connection you make emits a signal, so duplicate connections emit two signals. You can break a connection using disconnect().
Note: This function is thread-safe.
See also disconnect().
[static] template <typename PointerToMemberFunction> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type = Qt::AutoConnection)
This function overloads connect().
Creates a connection of the given type from the signal in the sender object to the method in the receiver object. Returns a handle to the connection that can be used to disconnect it later.
The signal must be a function declared as a signal in the header. The slot function can be any member function that can be connected to the signal. A slot can be connected to a given signal if the signal has at least as many arguments as the slot, and there is an implicit conversion between the types of the corresponding arguments in the signal and the slot.
Example:
 QLabel *label = new QLabel;
 QLineEdit *lineEdit = new QLineEdit;
 QObject::connect(lineEdit, &QLineEdit::textChanged,
                  label,  &QLabel::setText);
This example ensures that the label always displays the current line edit text.
A signal can be connected to many slots and signals. Many signals can be connected to one slot.
If a signal is connected to several slots, the slots are activated in the same order as the order the connection was made, when the signal is emitted
The function returns an handle to a connection if it successfully connects the signal to the slot. The Connection handle will be invalid if it cannot create the connection, for example, if QObject is unable to verify the existence of signal (if it was not declared as a signal) You can check if the QMetaObject::Connection is valid by casting it to a bool.
By default, a signal is emitted for every connection you make; two signals are emitted for duplicate connections. You can break all of these connections with a single disconnect() call. If you pass the Qt::UniqueConnection type, the connection will only be made if it is not a duplicate. If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return an invalid QMetaObject::Connection.
The optional type parameter describes the type of connection to establish. In particular, it determines whether a particular signal is delivered to a slot immediately or queued for delivery at a later time. If the signal is queued, the parameters must be of types that are known to Qt's meta-object system, because Qt needs to copy the arguments to store them in an event behind the scenes. If you try to use a queued connection and get the error message
 QObject::connect: Cannot queue arguments of type 'MyType'
 (Make sure 'MyType' is registered using qRegisterMetaType().)
make sure to declare the argument type with Q_DECLARE_METATYPE
Overloaded functions can be resolved with help of qOverload.
Note: This function is thread-safe.
See also Differences between String-Based and Functor-Based Connections.
[static] template <typename PointerToMemberFunction, typename Functor> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, Functor functor)
This function overloads connect().
Creates a connection from signal in sender object to functor, and returns a handle to the connection
The signal must be a function declared as a signal in the header. The slot function can be any function or functor that can be connected to the signal. A function can be connected to a given signal if the signal has at least as many argument as the slot. A functor can be connected to a signal if they have exactly the same number of arguments. There must exist implicit conversion between the types of the corresponding arguments in the signal and the slot.
Example:
 void someFunction();
 QPushButton *button = new QPushButton;
 QObject::connect(button, &QPushButton::clicked, someFunction);
Lambda expressions can also be used:
 QByteArray page = ...;
 QTcpSocket *socket = new QTcpSocket;
 socket->connectToHost("qt-project.org", 80);
 QObject::connect(socket, &QTcpSocket::connected, [=] () {
         socket->write("GET " + page + "\r\n");
     });
The connection will automatically disconnect if the sender is destroyed. However, you should take care that any objects used within the functor are still alive when the signal is emitted.
Overloaded functions can be resolved with help of qOverload.
Note: This function is thread-safe.
[static] template <typename PointerToMemberFunction, typename Functor> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type = Qt::AutoConnection)
This function overloads connect().
Creates a connection of a given type from signal in sender object to functor to be placed in a specific event loop of context, and returns a handle to the connection.
Note: Qt::UniqueConnections do not work for lambdas, non-member functions and functors; they only apply to connecting to member functions.
The signal must be a function declared as a signal in the header. The slot function can be any function or functor that can be connected to the signal. A function can be connected to a given signal if the signal has at least as many argument as the slot. A functor can be connected to a signal if they have exactly the same number of arguments. There must exist implicit conversion between the types of the corresponding arguments in the signal and the slot.
Example:
 void someFunction();
 QPushButton *button = new QPushButton;
 QObject::connect(button, &QPushButton::clicked, this, someFunction, Qt::QueuedConnection);
Lambda expressions can also be used:
 QByteArray page = ...;
 QTcpSocket *socket = new QTcpSocket;
 socket->connectToHost("qt-project.org", 80);
 QObject::connect(socket, &QTcpSocket::connected, this, [=] () {
         socket->write("GET " + page + "\r\n");
     }, Qt::AutoConnection);
The connection will automatically disconnect if the sender or the context is destroyed. However, you should take care that any objects used within the functor are still alive when the signal is emitted.
Overloaded functions can be resolved with help of qOverload.
Note: This function is thread-safe.
This function was introduced in Qt 5.2.
[virtual protected] void QObject::connectNotify(const QMetaMethod &signal)
This virtual function is called when something has been connected to signal in this object.
If you want to compare signal with a specific signal, you can use QMetaMethod::fromSignal() as follows:
 if (signal == QMetaMethod::fromSignal(&MyObject::valueChanged)) {
     // signal is valueChanged
 }
Warning: This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.
Warning: This function is called from the thread which performs the connection, which may be a different thread from the thread in which this object lives.
This function was introduced in Qt 5.0.
See also connect() and disconnectNotify().
[virtual protected] void QObject::customEvent(QEvent *event)
This event handler can be reimplemented in a subclass to receive custom events. Custom events are user-defined events with a type value at least as large as the QEvent::User item of the QEvent::Type enum, and is typically a QEvent subclass. The event is passed in the event parameter.
See also event() and QEvent.
[static] bool QObject::disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)
Disconnects signal in object sender from method in object receiver. Returns true if the connection is successfully broken; otherwise returns false.
A signal-slot connection is removed when either of the objects involved are destroyed.
disconnect() is typically used in three ways, as the following examples demonstrate.
Disconnect everything connected to an object's signals:
 disconnect(myObject, nullptr, nullptr, nullptr);
equivalent to the non-static overloaded function
 myObject->disconnect();
Disconnect everything connected to a specific signal:
 disconnect(myObject, SIGNAL(mySignal()), nullptr, nullptr);
equivalent to the non-static overloaded function
 myObject->disconnect(SIGNAL(mySignal()));
Disconnect a specific receiver:
 disconnect(myObject, nullptr, myReceiver, nullptr);
equivalent to the non-static overloaded function
 myObject->disconnect(myReceiver);
nullptr may be used as a wildcard, meaning "any signal", "any receiving object", or "any slot in the receiving object", respectively.
The sender may never be nullptr. (You cannot disconnect signals from more than one object in a single call.)
If signal is nullptr, it disconnects receiver and method from any signal. If not, only the specified signal is disconnected.
If receiver is nullptr, it disconnects anything connected to signal. If not, slots in objects other than receiver are not disconnected.
If method is nullptr, it disconnects anything that is connected to receiver. If not, only slots named method will be disconnected, and all other slots are left alone. The method must be nullptr if receiver is left out, so you cannot disconnect a specifically-named slot on all objects.
Note: This function is thread-safe.
See also connect().
[static] bool QObject::disconnect(const QObject *sender, const QMetaMethod &signal, const QObject *receiver, const QMetaMethod &method)
Disconnects signal in object sender from method in object receiver. Returns true if the connection is successfully broken; otherwise returns false.
This function provides the same possibilities like disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method) but uses QMetaMethod to represent the signal and the method to be disconnected.
Additionally this function returns false and no signals and slots disconnected if:
signal is not a member of sender class or one of its parent classes.
method is not a member of receiver class or one of its parent classes.
signal instance represents not a signal.
QMetaMethod() may be used as wildcard in the meaning "any signal" or "any slot in receiving object". In the same way nullptr can be used for receiver in the meaning "any receiving object". In this case method should also be QMetaMethod(). sender parameter should be never nullptr.
This function was introduced in Qt 4.8.
See also disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method).
bool QObject::disconnect(const char *signal = nullptr, const QObject *receiver = nullptr, const char *method = nullptr) const
This function overloads disconnect().
Disconnects signal from method of receiver.
A signal-slot connection is removed when either of the objects involved are destroyed.
Note: This function is thread-safe.
bool QObject::disconnect(const QObject *receiver, const char *method = nullptr) const
This function overloads disconnect().
Disconnects all signals in this object from receiver's method.
A signal-slot connection is removed when either of the objects involved are destroyed.
[static] bool QObject::disconnect(const QMetaObject::Connection &connection)
Disconnect a connection.
If the connection is invalid or has already been disconnected, do nothing and return false.
See also connect().
[static] template <typename PointerToMemberFunction> bool QObject::disconnect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method)
This function overloads disconnect().
Disconnects signal in object sender from method in object receiver. Returns true if the connection is successfully broken; otherwise returns false.
A signal-slot connection is removed when either of the objects involved are destroyed.
disconnect() is typically used in three ways, as the following examples demonstrate.
Disconnect everything connected to an object's signals:
 disconnect(myObject, nullptr, nullptr, nullptr);
Disconnect everything connected to a specific signal:
 disconnect(myObject, &MyObject::mySignal(), nullptr, nullptr);
Disconnect a specific receiver:
 disconnect(myObject, nullptr, myReceiver, nullptr);
Disconnect a connection from one specific signal to a specific slot:
 QObject::disconnect(lineEdit, &QLineEdit::textChanged,
                  label,  &QLabel::setText);
nullptr may be used as a wildcard, meaning "any signal", "any receiving object", or "any slot in the receiving object", respectively.
The sender may never be nullptr. (You cannot disconnect signals from more than one object in a single call.)
If signal is nullptr, it disconnects receiver and method from any signal. If not, only the specified signal is disconnected.
If receiver is nullptr, it disconnects anything connected to signal. If not, slots in objects other than receiver are not disconnected.
If method is nullptr, it disconnects anything that is connected to receiver. If not, only slots named method will be disconnected, and all other slots are left alone. The method must be nullptr if receiver is left out, so you cannot disconnect a specifically-named slot on all objects.
Note: It is not possible to use this overload to disconnect signals connected to functors or lambda expressions. That is because it is not possible to compare them. Instead, use the overload that takes a QMetaObject::Connection
Note: This function is thread-safe.
See also connect().
[virtual protected] void QObject::disconnectNotify(const QMetaMethod &signal)
This virtual function is called when something has been disconnected from signal in this object.
See connectNotify() for an example of how to compare signal with a specific signal.
If all signals were disconnected from this object (e.g., the signal argument to disconnect() was nullptr), disconnectNotify() is only called once, and the signal will be an invalid QMetaMethod (QMetaMethod::isValid() returns false).
Warning: This function violates the object-oriented principle of modularity. However, it might be useful for optimizing access to expensive resources.
Warning: This function is called from the thread which performs the disconnection, which may be a different thread from the thread in which this object lives. This function may also be called with a QObject internal mutex locked. It is therefore not allowed to re-enter any of any QObject functions from your reimplementation and if you lock a mutex in your reimplementation, make sure that you don't call QObject functions with that mutex held in other places or it will result in a deadlock.
This function was introduced in Qt 5.0.
See also disconnect() and connectNotify().
void QObject::dumpObjectInfo() const
Dumps information about signal connections, etc. for this object to the debug output.
Note: before Qt 5.9, this function was not const.
See also dumpObjectTree().
void QObject::dumpObjectTree() const
Dumps a tree of children to the debug output.
Note: before Qt 5.9, this function was not const.
See also dumpObjectInfo().
QList<QByteArray> QObject::dynamicPropertyNames() const
Returns the names of all properties that were dynamically added to the object using setProperty().
This function was introduced in Qt 4.2.
[virtual] bool QObject::event(QEvent *e)
This virtual function receives events to an object and should return true if the event e was recognized and processed.
The event() function can be reimplemented to customize the behavior of an object.
Make sure you call the parent event class implementation for all the events you did not handle.
Example:
 class MyClass : public QWidget
 {
     Q_OBJECT

 public:
     MyClass(QWidget *parent = nullptr);
     ~MyClass();

     bool event(QEvent* ev) override
     {
         if (ev->type() == QEvent::PolishRequest) {
             // overwrite handling of PolishRequest if any
             doThings();
             return true;
         } else  if (ev->type() == QEvent::Show) {
             // complement handling of Show if any
             doThings2();
             QWidget::event(ev);
             return true;
         }
         // Make sure the rest of events are handled
         return QWidget::event(ev);
     }
 };
See also installEventFilter(), timerEvent(), QCoreApplication::sendEvent(), and QCoreApplication::postEvent().
[virtual] bool QObject::eventFilter(QObject *watched, QEvent *event)
Filters events if this object has been installed as an event filter for the watched object.
In your reimplementation of this function, if you want to filter the event out, i.e. stop it being handled further, return true; otherwise return false.
Example:
 class MainWindow : public QMainWindow
 {
 public:
     MainWindow();

 protected:
     bool eventFilter(QObject *obj, QEvent *ev) override;

 private:
     QTextEdit *textEdit;
 };

 MainWindow::MainWindow()
 {
     textEdit = new QTextEdit;
     setCentralWidget(textEdit);

     textEdit->installEventFilter(this);
 }

 bool MainWindow::eventFilter(QObject *obj, QEvent *event)
 {
     if (obj == textEdit) {
         if (event->type() == QEvent::KeyPress) {
             QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);
             qDebug() << "Ate key press" << keyEvent->key();
             return true;
         } else {
             return false;
         }
     } else {
         // pass the event on to the parent class
         return QMainWindow::eventFilter(obj, event);
     }
 }
Notice in the example above that unhandled events are passed to the base class's eventFilter() function, since the base class might have reimplemented eventFilter() for its own internal purposes.
Some events, such as QEvent::ShortcutOverride must be explicitly accepted (by calling accept() on them) in order to prevent propagation.
Warning: If you delete the receiver object in this function, be sure to return true. Otherwise, Qt will forward the event to the deleted object and the program might crash.
See also installEventFilter().
template <typename T> T QObject::findChild(const QString &name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
Returns the child of this object that can be cast into type T and that is called name, or nullptr if there is no such object. Omitting the name argument causes all object names to be matched. The search is performed recursively, unless options specifies the option FindDirectChildrenOnly.
If there is more than one child matching the search, the most direct ancestor is returned. If there are several direct ancestors, it is undefined which one will be returned. In that case, findChildren() should be used.
This example returns a child QPushButton of parentWidget named "button1", even if the button isn't a direct child of the parent:
 QPushButton *button = parentWidget->findChild<QPushButton *>("button1");
This example returns a QListWidget child of parentWidget:
 QListWidget *list = parentWidget->findChild<QListWidget *>();
This example returns a child QPushButton of parentWidget (its direct parent) named "button1":
 QPushButton *button = parentWidget->findChild<QPushButton *>("button1", Qt::FindDirectChildrenOnly);
This example returns a QListWidget child of parentWidget, its direct parent:
 QListWidget *list = parentWidget->findChild<QListWidget *>(QString(), Qt::FindDirectChildrenOnly);
See also findChildren().
template <typename T> QList<T> QObject::findChildren(const QString &name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
Returns all children of this object with the given name that can be cast to type T, or an empty list if there are no such objects. Omitting the name argument causes all object names to be matched. The search is performed recursively, unless options specifies the option FindDirectChildrenOnly.
The following example shows how to find a list of child QWidgets of the specified parentWidget named widgetname:
 QList<QWidget *> widgets = parentWidget.findChildren<QWidget *>("widgetname");
This example returns all QPushButtons that are children of parentWidget:
 QList<QPushButton *> allPButtons = parentWidget.findChildren<QPushButton *>();
This example returns all QPushButtons that are immediate children of parentWidget:
 QList<QPushButton *> childButtons = parentWidget.findChildren<QPushButton *>(QString(), Qt::FindDirectChildrenOnly);
See also findChild().
template <typename T> QList<T> QObject::findChildren(const QRegularExpression &re, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
This function overloads findChildren().
Returns the children of this object that can be cast to type T and that have names matching the regular expression re, or an empty list if there are no such objects. The search is performed recursively, unless options specifies the option FindDirectChildrenOnly.
This function was introduced in Qt 5.0.
bool QObject::inherits(const char *className) const
Returns true if this object is an instance of a class that inherits className or a QObject subclass that inherits className; otherwise returns false.
A class is considered to inherit itself.
Example:
 QTimer *timer = new QTimer;         // QTimer inherits QObject
 timer->inherits("QTimer");          // returns true
 timer->inherits("QObject");         // returns true
 timer->inherits("QAbstractButton"); // returns false

 // QVBoxLayout inherits QObject and QLayoutItem
 QVBoxLayout *layout = new QVBoxLayout;
 layout->inherits("QObject");        // returns true
 layout->inherits("QLayoutItem");    // returns true (even though QLayoutItem is not a QObject)
If you need to determine whether an object is an instance of a particular class for the purpose of casting it, consider using qobject_cast<Type *>(object) instead.
See also metaObject() and qobject_cast().
void QObject::installEventFilter(QObject *filterObj)
Installs an event filter filterObj on this object. For example:
 monitoredObj->installEventFilter(filterObj);
An event filter is an object that receives all events that are sent to this object. The filter can either stop the event or forward it to this object. The event filter filterObj receives events via its eventFilter() function. The eventFilter() function must return true if the event should be filtered, (i.e. stopped); otherwise it must return false.
If multiple event filters are installed on a single object, the filter that was installed last is activated first.
Here's a KeyPressEater class that eats the key presses of its monitored objects:
 class KeyPressEater : public QObject
 {
     Q_OBJECT
     ...

 protected:
     bool eventFilter(QObject *obj, QEvent *event) override;
 };

 bool KeyPressEater::eventFilter(QObject *obj, QEvent *event)
 {
     if (event->type() == QEvent::KeyPress) {
         QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);
         qDebug("Ate key press %d", keyEvent->key());
         return true;
     } else {
         // standard event processing
         return QObject::eventFilter(obj, event);
     }
 }
And here's how to install it on two widgets:
 KeyPressEater *keyPressEater = new KeyPressEater(this);
 QPushButton *pushButton = new QPushButton(this);
 QListView *listView = new QListView(this);

 pushButton->installEventFilter(keyPressEater);
 listView->installEventFilter(keyPressEater);
The QShortcut class, for example, uses this technique to intercept shortcut key presses.
Warning: If you delete the receiver object in your eventFilter() function, be sure to return true. If you return false, Qt sends the event to the deleted object and the program will crash.
Note that the filtering object must be in the same thread as this object. If filterObj is in a different thread, this function does nothing. If either filterObj or this object are moved to a different thread after calling this function, the event filter will not be called until both objects have the same thread affinity again (it is not removed).
See also removeEventFilter(), eventFilter(), and event().
[protected] bool QObject::isSignalConnected(const QMetaMethod &signal) const
Returns true if the signal is connected to at least one receiver, otherwise returns false.
signal must be a signal member of this object, otherwise the behaviour is undefined.
 static const QMetaMethod valueChangedSignal = QMetaMethod::fromSignal(&MyObject::valueChanged);
 if (isSignalConnected(valueChangedSignal)) {
     QByteArray data;
     data = get_the_value();       // expensive operation
     emit valueChanged(data);
 }
As the code snippet above illustrates, you can use this function to avoid emitting a signal that nobody listens to.
Warning: This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.
This function was introduced in Qt 5.0.
bool QObject::isWidgetType() const
Returns true if the object is a widget; otherwise returns false.
Calling this function is equivalent to calling inherits("QWidget"), except that it is much faster.
bool QObject::isWindowType() const
Returns true if the object is a window; otherwise returns false.
Calling this function is equivalent to calling inherits("QWindow"), except that it is much faster.
void QObject::killTimer(int id)
Kills the timer with timer identifier, id.
The timer identifier is returned by startTimer() when a timer event is started.
See also timerEvent() and startTimer().
[virtual] const QMetaObject *QObject::metaObject() const
Returns a pointer to the meta-object of this object.
A meta-object contains information about a class that inherits QObject, e.g. class name, superclass name, properties, signals and slots. Every QObject subclass that contains the Q_OBJECT macro will have a meta-object.
The meta-object information is required by the signal/slot connection mechanism and the property system. The inherits() function also makes use of the meta-object.
If you have no pointer to an actual object instance but still want to access the meta-object of a class, you can use staticMetaObject.
Example:
 QObject *obj = new QPushButton;
 obj->metaObject()->className();             // returns "QPushButton"

 QPushButton::staticMetaObject.className();  // returns "QPushButton"
See also staticMetaObject.
void QObject::moveToThread(QThread *targetThread)
Changes the thread affinity for this object and its children. The object cannot be moved if it has a parent. Event processing will continue in the targetThread.
To move an object to the main thread, use QApplication::instance() to retrieve a pointer to the current application, and then use QApplication::thread() to retrieve the thread in which the application lives. For example:
 myObject->moveToThread(QApplication::instance()->thread());
If targetThread is nullptr, all event processing for this object and its children stops, as they are no longer associated with any thread.
Note that all active timers for the object will be reset. The timers are first stopped in the current thread and restarted (with the same interval) in the targetThread. As a result, constantly moving an object between threads can postpone timer events indefinitely.
A QEvent::ThreadChange event is sent to this object just before the thread affinity is changed. You can handle this event to perform any special processing. Note that any new events that are posted to this object will be handled in the targetThread, provided it is not nullptr: when it is nullptr, no event processing for this object or its children can happen, as they are no longer associated with any thread.
Warning: This function is not thread-safe; the current thread must be same as the current thread affinity. In other words, this function can only "push" an object from the current thread to another thread, it cannot "pull" an object from any arbitrary thread to the current thread. There is one exception to this rule however: objects with no thread affinity can be "pulled" to the current thread.
See also thread().
QObject *QObject::parent() const
Returns a pointer to the parent object.
See also setParent() and children().
QVariant QObject::property(const char *name) const
Returns the value of the object's name property.
If no such property exists, the returned variant is invalid.
Information about all available properties is provided through the metaObject() and dynamicPropertyNames().
See also setProperty(), QVariant::isValid(), metaObject(), and dynamicPropertyNames().
[protected] int QObject::receivers(const char *signal) const
Returns the number of receivers connected to the signal.
Since both slots and signals can be used as receivers for signals, and the same connections can be made many times, the number of receivers is the same as the number of connections made from this signal.
When calling this function, you can use the SIGNAL() macro to pass a specific signal:
 if (receivers(SIGNAL(valueChanged(QByteArray))) > 0) {
     QByteArray data;
     get_the_value(&data);       // expensive operation
     emit valueChanged(data);
 }
Warning: This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.
See also isSignalConnected().
void QObject::removeEventFilter(QObject *obj)
Removes an event filter object obj from this object. The request is ignored if such an event filter has not been installed.
All event filters for this object are automatically removed when this object is destroyed.
It is always safe to remove an event filter, even during event filter activation (i.e. from the eventFilter() function).
See also installEventFilter(), eventFilter(), and event().
[protected] QObject *QObject::sender() const
Returns a pointer to the object that sent the signal, if called in a slot activated by a signal; otherwise it returns nullptr. The pointer is valid only during the execution of the slot that calls this function from this object's thread context.
The pointer returned by this function becomes invalid if the sender is destroyed, or if the slot is disconnected from the sender's signal.
Warning: This function violates the object-oriented principle of modularity. However, getting access to the sender might be useful when many signals are connected to a single slot.
Warning: As mentioned above, the return value of this function is not valid when the slot is called via a Qt::DirectConnection from a thread different from this object's thread. Do not use this function in this type of scenario.
See also senderSignalIndex().
[protected] int QObject::senderSignalIndex() const
Returns the meta-method index of the signal that called the currently executing slot, which is a member of the class returned by sender(). If called outside of a slot activated by a signal, -1 is returned.
For signals with default parameters, this function will always return the index with all parameters, regardless of which was used with connect(). For example, the signal destroyed(QObject *obj = \nullptr) will have two different indexes (with and without the parameter), but this function will always return the index with a parameter. This does not apply when overloading signals with different parameters.
Warning: This function violates the object-oriented principle of modularity. However, getting access to the signal index might be useful when many signals are connected to a single slot.
Warning: The return value of this function is not valid when the slot is called via a Qt::DirectConnection from a thread different from this object's thread. Do not use this function in this type of scenario.
This function was introduced in Qt 4.8.
See also sender(), QMetaObject::indexOfSignal(), and QMetaObject::method().
void QObject::setParent(QObject *parent)
Makes the object a child of parent.
See also parent() and children().
bool QObject::setProperty(const char *name, const QVariant &value)
Sets the value of the object's name property to value.
If the property is defined in the class using Q_PROPERTY then true is returned on success and false otherwise. If the property is not defined using Q_PROPERTY, and therefore not listed in the meta-object, it is added as a dynamic property and false is returned.
Information about all available properties is provided through the metaObject() and dynamicPropertyNames().
Dynamic properties can be queried again using property() and can be removed by setting the property value to an invalid QVariant. Changing the value of a dynamic property causes a QDynamicPropertyChangeEvent to be sent to the object.
Note: Dynamic properties starting with "_q_" are reserved for internal purposes.
See also property(), metaObject(), dynamicPropertyNames(), and QMetaProperty::write().
bool QObject::signalsBlocked() const
Returns true if signals are blocked; otherwise returns false.
Signals are not blocked by default.
See also blockSignals() and QSignalBlocker.
int QObject::startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer)
Starts a timer and returns a timer identifier, or returns zero if it could not start a timer.
A timer event will occur every interval milliseconds until killTimer() is called. If interval is 0, then the timer event occurs once every time there are no more window system events to process.
The virtual timerEvent() function is called with the QTimerEvent event parameter class when a timer event occurs. Reimplement this function to get timer events.
If multiple timers are running, the QTimerEvent::timerId() can be used to find out which timer was activated.
Example:
 class MyObject : public QObject
 {
     Q_OBJECT

 public:
     MyObject(QObject *parent = nullptr);

 protected:
     void timerEvent(QTimerEvent *event) override;
 };

 MyObject::MyObject(QObject *parent)
     : QObject(parent)
 {
     startTimer(50);     // 50-millisecond timer
     startTimer(1000);   // 1-second timer
     startTimer(60000);  // 1-minute timer

     using namespace std::chrono;
     startTimer(milliseconds(50));
     startTimer(seconds(1));
     startTimer(minutes(1));

     // since C++14 we can use std::chrono::duration literals, e.g.:
     startTimer(100ms);
     startTimer(5s);
     startTimer(2min);
     startTimer(1h);
 }

 void MyObject::timerEvent(QTimerEvent *event)
 {
     qDebug() << "Timer ID:" << event->timerId();
 }
Note that QTimer's accuracy depends on the underlying operating system and hardware. The timerType argument allows you to customize the accuracy of the timer. See Qt::TimerType for information on the different timer types. Most platforms support an accuracy of 20 milliseconds; some provide more. If Qt is unable to deliver the requested number of timer events, it will silently discard some.
The QTimer class provides a high-level programming interface with single-shot timers and timer signals instead of events. There is also a QBasicTimer class that is more lightweight than QTimer and less clumsy than using timer IDs directly.
See also timerEvent(), killTimer(), and QTimer::singleShot().
int QObject::startTimer(std::chrono::milliseconds time, Qt::TimerType timerType = Qt::CoarseTimer)
This is an overloaded function.
Starts a timer and returns a timer identifier, or returns zero if it could not start a timer.
A timer event will occur every time interval until killTimer() is called. If time is equal to std::chrono::duration::zero(), then the timer event occurs once every time there are no more window system events to process.
The virtual timerEvent() function is called with the QTimerEvent event parameter class when a timer event occurs. Reimplement this function to get timer events.
If multiple timers are running, the QTimerEvent::timerId() can be used to find out which timer was activated.
Example:
 class MyObject : public QObject
 {
     Q_OBJECT

 public:
     MyObject(QObject *parent = nullptr);

 protected:
     void timerEvent(QTimerEvent *event) override;
 };

 MyObject::MyObject(QObject *parent)
     : QObject(parent)
 {
     startTimer(50);     // 50-millisecond timer
     startTimer(1000);   // 1-second timer
     startTimer(60000);  // 1-minute timer

     using namespace std::chrono;
     startTimer(milliseconds(50));
     startTimer(seconds(1));
     startTimer(minutes(1));

     // since C++14 we can use std::chrono::duration literals, e.g.:
     startTimer(100ms);
     startTimer(5s);
     startTimer(2min);
     startTimer(1h);
 }

 void MyObject::timerEvent(QTimerEvent *event)
 {
     qDebug() << "Timer ID:" << event->timerId();
 }
Note that QTimer's accuracy depends on the underlying operating system and hardware. The timerType argument allows you to customize the accuracy of the timer. See Qt::TimerType for information on the different timer types. Most platforms support an accuracy of 20 milliseconds; some provide more. If Qt is unable to deliver the requested number of timer events, it will silently discard some.
The QTimer class provides a high-level programming interface with single-shot timers and timer signals instead of events. There is also a QBasicTimer class that is more lightweight than QTimer and less clumsy than using timer IDs directly.
This function was introduced in Qt 5.9.
See also timerEvent(), killTimer(), and QTimer::singleShot().
QThread *QObject::thread() const
Returns the thread in which the object lives.
See also moveToThread().
[virtual protected] void QObject::timerEvent(QTimerEvent *event)
This event handler can be reimplemented in a subclass to receive timer events for the object.
QTimer provides a higher-level interface to the timer functionality, and also more general information about timers. The timer event is passed in the event parameter.
See also startTimer(), killTimer(), and event().
[static] QString QObject::tr(const char *sourceText, const char *disambiguation = nullptr, int n = -1)
Returns a translated version of sourceText, optionally based on a disambiguation string and value of n for strings containing plurals; otherwise returns QString::fromUtf8(sourceText) if no appropriate translated string is available.
Example:
 void MainWindow::createActions()
 {
     QMenu *fileMenu = menuBar()->addMenu(tr("&File"));
     ...
If the same sourceText is used in different roles within the same context, an additional identifying string may be passed in disambiguation (nullptr by default). In Qt 4.4 and earlier, this was the preferred way to pass comments to translators.
Example:
 MyWindow::MyWindow()
 {
     QLabel *senderLabel = new QLabel(tr("Name:"));
     QLabel *recipientLabel = new QLabel(tr("Name:", "recipient"));
     ...
See Writing Source Code for Translation for a detailed description of Qt's translation mechanisms in general, and the Disambiguation section for information on disambiguation.
Warning: This method is reentrant only if all translators are installed before calling this method. Installing or removing translators while performing translations is not supported. Doing so will probably result in crashes or other undesirable behavior.
See also QCoreApplication::translate() and Internationalization with Qt.
Member Variable Documentation
const QMetaObject QObject::staticMetaObject
This variable stores the meta-object for the class.
A meta-object contains information about a class that inherits QObject, e.g. class name, superclass name, properties, signals and slots. Every class that contains the Q_OBJECT macro will also have a meta-object.
The meta-object information is required by the signal/slot connection mechanism and the property system. The inherits() function also makes use of the meta-object.
If you have a pointer to an object, you can use metaObject() to retrieve the meta-object associated with that object.
Example:
 QPushButton::staticMetaObject.className();  // returns "QPushButton"

 QObject *obj = new QPushButton;
 obj->metaObject()->className();             // returns "QPushButton"
See also metaObject().
Related Non-Members
template <typename T> T qobject_cast(QObject *object)
template <typename T> T qobject_cast(const QObject *object)
Returns the given object cast to type T if the object is of type T (or of a subclass); otherwise returns nullptr. If object is nullptr then it will also return nullptr.
The class T must inherit (directly or indirectly) QObject and be declared with the Q_OBJECT macro.
A class is considered to inherit itself.
Example:
 QObject *obj = new QTimer;          // QTimer inherits QObject

 QTimer *timer = qobject_cast<QTimer *>(obj);
 // timer == (QObject *)obj

 QAbstractButton *button = qobject_cast<QAbstractButton *>(obj);
 // button == nullptr
The qobject_cast() function behaves similarly to the standard C++ dynamic_cast(), with the advantages that it doesn't require RTTI support and it works across dynamic library boundaries.
qobject_cast() can also be used in conjunction with interfaces; see the Plug & Paint example for details.
Warning: If T isn't declared with the Q_OBJECT macro, this function's return value is undefined.
See also QObject::inherits().
typedef QObjectList
Synonym for QList<QObject *>.
template <typename T> QList<T> qFindChildren(const QObject *obj, const QRegExp &regExp)
This function overloads qFindChildren().
This function is equivalent to obj->findChildren<T>(regExp).
Note: This function was provided as a workaround for MSVC 6 which did not support member template functions. It is advised to use the other form in new code.
See also QObject::findChildren().
Macro Documentation
QT_NO_NARROWING_CONVERSIONS_IN_CONNECT
Defining this macro will disable narrowing and floating-point-to-integral conversions between the arguments carried by a signal and the arguments accepted by a slot, when the signal and the slot are connected using the PMF-based syntax.
This function was introduced in Qt 5.8.
See also QObject::connect.
Q_CLASSINFO(Name, Value)
This macro associates extra information to the class, which is available using QObject::metaObject(). Qt makes only limited use of this feature, in the Active Qt, Qt D-Bus and Qt QML.
The extra information takes the form of a Name string and a Value literal string.
Example:
 class MyClass : public QObject
 {
     Q_OBJECT
     Q_CLASSINFO("Author", "Pierre Gendron")
     Q_CLASSINFO("URL", "http://www.my-organization.qc.ca")

 public:
     ...
 };
See also QMetaObject::classInfo(), QAxFactory, Using Qt D-Bus Adaptors, and Extending QML.
Q_DISABLE_COPY(Class)
Disables the use of copy constructors and assignment operators for the given Class.
Instances of subclasses of QObject should not be thought of as values that can be copied or assigned, but as unique identities. This means that when you create your own subclass of QObject (director or indirect), you should not give it a copy constructor or an assignment operator. However, it may not enough to simply omit them from your class, because, if you mistakenly write some code that requires a copy constructor or an assignment operator (it's easy to do), your compiler will thoughtfully create it for you. You must do more.
The curious user will have seen that the Qt classes derived from QObject typically include this macro in a private section:
 class MyClass : public QObject
 {
 private:
     Q_DISABLE_COPY(MyClass)
 };
It declares a copy constructor and an assignment operator in the private section, so that if you use them by mistake, the compiler will report an error.
 class MyClass : public QObject
 {
 private:
     MyClass(const MyClass &) = delete;
     MyClass &operator=(const MyClass &) = delete;
 };
But even this might not catch absolutely every case. You might be tempted to do something like this:
 QWidget w = QWidget();
First of all, don't do that. Most compilers will generate code that uses the copy constructor, so the privacy violation error will be reported, but your C++ compiler is not required to generate code for this statement in a specific way. It could generate code using neither the copy constructor nor the assignment operator we made private. In that case, no error would be reported, but your application would probably crash when you called a member function of w.
See also Q_DISABLE_COPY_MOVE and Q_DISABLE_MOVE.
Q_DISABLE_COPY_MOVE(Class)
A convenience macro that disables the use of copy constructors, assignment operators, move constructors and move assignment operators for the given Class, combining Q_DISABLE_COPY and Q_DISABLE_MOVE.
This function was introduced in Qt 5.13.
See also Q_DISABLE_COPY and Q_DISABLE_MOVE.
Q_DISABLE_MOVE(Class)
Disables the use of move constructors and move assignment operators for the given Class.
This function was introduced in Qt 5.13.
See also Q_DISABLE_COPY and Q_DISABLE_COPY_MOVE.
Q_EMIT
Use this macro to replace the emit keyword for emitting signals, when you want to use Qt Signals and Slots with a 3rd party signal/slot mechanism.
The macro is normally used when no_keywords is specified with the CONFIG variable in the .pro file, but it can be used even when no_keywords is not specified.
Q_ENUM(...)
This macro registers an enum type with the meta-object system. It must be placed after the enum declaration in a class that has the Q_OBJECT or the Q_GADGET macro. For namespaces use Q_ENUM_NS() instead.
For example:
 class MyClass : public QObject
 {
     Q_OBJECT

 public:
     MyClass(QObject *parent = nullptr);
     ~MyClass();

     enum Priority { High, Low, VeryHigh, VeryLow };
     Q_ENUM(Priority)
     void setPriority(Priority priority);
     Priority priority() const;
 };
Enumerations that are declared with Q_ENUM have their QMetaEnum registered in the enclosing QMetaObject. You can also use QMetaEnum::fromType() to get the QMetaEnum.
Registered enumerations are automatically registered also to the Qt meta type system, making them known to QMetaType without the need to use Q_DECLARE_METATYPE(). This will enable useful features; for example, if used in a QVariant, you can convert them to strings. Likewise, passing them to QDebug will print out their names.
Mind that the enum values are stored as signed int in the meta object system. Registering enumerations with values outside the range of values valid for int will lead to overflows and potentially undefined behavior when accessing them through the meta object system. QML, for example, does access registered enumerations through the meta object system.
This function was introduced in Qt 5.5.
See also Qt's Property System.
Q_ENUM_NS(...)
This macro registers an enum type with the meta-object system. It must be placed after the enum declaration in a namespace that has the Q_NAMESPACE macro. It is the same as Q_ENUM but in a namespace.
Enumerations that are declared with Q_ENUM_NS have their QMetaEnum registered in the enclosing QMetaObject. You can also use QMetaEnum::fromType() to get the QMetaEnum.
Registered enumerations are automatically registered also to the Qt meta type system, making them known to QMetaType without the need to use Q_DECLARE_METATYPE(). This will enable useful features; for example, if used in a QVariant, you can convert them to strings. Likewise, passing them to QDebug will print out their names.
Mind that the enum values are stored as signed int in the meta object system. Registering enumerations with values outside the range of values valid for int will lead to overflows and potentially undefined behavior when accessing them through the meta object system. QML, for example, does access registered enumerations through the meta object system.
This function was introduced in Qt 5.8.
See also Qt's Property System.
Q_FLAG(...)
This macro registers a single flags type with the meta-object system. It is typically used in a class definition to declare that values of a given enum can be used as flags and combined using the bitwise OR operator. For namespaces use Q_FLAG_NS() instead.
The macro must be placed after the enum declaration. The declaration of the flags type is done using the Q_DECLARE_FLAGS() macro.
For example, in QItemSelectionModel, the SelectionFlags flag is declared in the following way:
 class QItemSelectionModel : public QObject
 {
     Q_OBJECT

 public:
     ...
     enum SelectionFlag {
         NoUpdate       = 0x0000,
         Clear          = 0x0001,
         Select         = 0x0002,
         Deselect       = 0x0004,
         Toggle         = 0x0008,
         Current        = 0x0010,
         Rows           = 0x0020,
         Columns        = 0x0040,
         SelectCurrent  = Select | Current,
         ToggleCurrent  = Toggle | Current,
         ClearAndSelect = Clear | Select
     };

     Q_DECLARE_FLAGS(SelectionFlags, SelectionFlag)
     Q_FLAG(SelectionFlags)
     ...
 }
Note: The Q_FLAG macro takes care of registering individual flag values with the meta-object system, so it is unnecessary to use Q_ENUM() in addition to this macro.
This function was introduced in Qt 5.5.
See also Qt's Property System.
Q_FLAG_NS(...)
This macro registers a single flags type with the meta-object system. It is used in a namespace that has the Q_NAMESPACE macro, to declare that values of a given enum can be used as flags and combined using the bitwise OR operator. It is the same as Q_FLAG but in a namespace.
The macro must be placed after the enum declaration.
Note: The Q_FLAG_NS macro takes care of registering individual flag values with the meta-object system, so it is unnecessary to use Q_ENUM_NS() in addition to this macro.
This function was introduced in Qt 5.8.
See also Qt's Property System.
Q_GADGET
The Q_GADGET macro is a lighter version of the Q_OBJECT macro for classes that do not inherit from QObject but still want to use some of the reflection capabilities offered by QMetaObject. Just like the Q_OBJECT macro, it must appear in the private section of a class definition.
Q_GADGETs can have Q_ENUM, Q_PROPERTY and Q_INVOKABLE, but they cannot have signals or slots.
Q_GADGET makes a class member, staticMetaObject, available. staticMetaObject is of type QMetaObject and provides access to the enums declared with Q_ENUMS.
Q_INTERFACES(...)
This macro tells Qt which interfaces the class implements. This is used when implementing plugins.
Example:
 class BasicToolsPlugin : public QObject,
                          public BrushInterface,
                          public ShapeInterface,
                          public FilterInterface
 {
     Q_OBJECT
     Q_PLUGIN_METADATA(IID "org.qt-project.Qt.Examples.PlugAndPaint.BrushInterface" FILE "basictools.json")
     Q_INTERFACES(BrushInterface ShapeInterface FilterInterface)

 public:
     ...
 };
See the Plug & Paint Basic Tools example for details.
See also Q_DECLARE_INTERFACE(), Q_PLUGIN_METADATA(), and How to Create Qt Plugins.
Q_INVOKABLE
Apply this macro to declarations of member functions to allow them to be invoked via the meta-object system. The macro is written before the return type, as shown in the following example:
 class Window : public QWidget
 {
     Q_OBJECT

 public:
     Window();
     void normalMethod();
     Q_INVOKABLE void invokableMethod();
 };
The invokableMethod() function is marked up using Q_INVOKABLE, causing it to be registered with the meta-object system and enabling it to be invoked using QMetaObject::invokeMethod(). Since normalMethod() function is not registered in this way, it cannot be invoked using QMetaObject::invokeMethod().
If an invokable member function returns a pointer to a QObject or a subclass of QObject and it is invoked from QML, special ownership rules apply. See Data Type Conversion Between QML and C++ for more information.
Q_NAMESPACE
The Q_NAMESPACE macro can be used to add QMetaObject capabilities to a namespace.
Q_NAMESPACEs can have Q_CLASSINFO, Q_ENUM_NS, Q_FLAG_NS, but they cannot have Q_ENUM, Q_FLAG, Q_PROPERTY, Q_INVOKABLE, signals nor slots.
Q_NAMESPACE makes an external variable, staticMetaObject, available. staticMetaObject is of type QMetaObject and provides access to the enums declared with Q_ENUM_NS/Q_FLAG_NS.
For example:
 namespace test {
 Q_NAMESPACE
 ...
This function was introduced in Qt 5.8.
See also Q_NAMESPACE_EXPORT.
Q_NAMESPACE_EXPORT(EXPORT_MACRO)
The Q_NAMESPACE_EXPORT macro can be used to add QMetaObject capabilities to a namespace.
It works exactly like the Q_NAMESPACE macro. However, the external staticMetaObject variable that gets defined in the namespace is declared with the supplied EXPORT_MACRO qualifier. This is useful if the object needs to be exported from a dynamic library.
For example:
 namespace test {
 Q_NAMESPACE_EXPORT(EXPORT_MACRO)
 ...
This function was introduced in Qt 5.14.
See also Q_NAMESPACE and Creating Shared Libraries.
Q_OBJECT
The Q_OBJECT macro must appear in the private section of a class definition that declares its own signals and slots or that uses other services provided by Qt's meta-object system.
For example:
 #include <QObject>

 class Counter : public QObject
 {
     Q_OBJECT

 public:
     Counter() { m_value = 0; }

     int value() const { return m_value; }

 public slots:
     void setValue(int value);

 signals:
     void valueChanged(int newValue);

 private:
     int m_value;
 };
Note: This macro requires the class to be a subclass of QObject. Use Q_GADGET instead of Q_OBJECT to enable the meta object system's support for enums in a class that is not a QObject subclass.
See also Meta-Object System, Signals and Slots, and Qt's Property System.
Q_PROPERTY(...)
This macro is used for declaring properties in classes that inherit QObject. Properties behave like class data members, but they have additional features accessible through the Meta-Object System.
 Q_PROPERTY(type name
            (READ getFunction [WRITE setFunction] |
             MEMBER memberName [(READ getFunction | WRITE setFunction)])
            [RESET resetFunction]
            [NOTIFY notifySignal]
            [REVISION int]
            [DESIGNABLE bool]
            [SCRIPTABLE bool]
            [STORED bool]
            [USER bool]
            [CONSTANT]
            [FINAL])
            [REQUIRED]
The property name and type and the READ function are required. The type can be any type supported by QVariant, or it can be a user-defined type. The other items are optional, but a WRITE function is common. The attributes default to true except USER, which defaults to false.
For example:
 Q_PROPERTY(QString title READ title WRITE setTitle USER true)
For more details about how to use this macro, and a more detailed example of its use, see the discussion on Qt's Property System.
See also Qt's Property System.
Q_REVISION
Apply this macro to declarations of member functions to tag them with a revision number in the meta-object system. The macro is written before the return type, as shown in the following example:
 class Window : public QWidget
 {
     Q_OBJECT
     Q_PROPERTY(int normalProperty READ normalProperty)
     Q_PROPERTY(int newProperty READ newProperty REVISION 1)

 public:
     Window();
     int normalProperty();
     int newProperty();
 public slots:
     void normalMethod();
     Q_REVISION(1) void newMethod();
 };
This is useful when using the meta-object system to dynamically expose objects to another API, as you can match the version expected by multiple versions of the other API. Consider the following simplified example:
     Window window;
     int expectedRevision = 0;
     const QMetaObject *windowMetaObject = window.metaObject();
     for (int i=0; i < windowMetaObject->methodCount(); i++)
         if (windowMetaObject->method(i).revision() <= expectedRevision)
             exposeMethod(windowMetaObject->method(i));
     for (int i=0; i < windowMetaObject->propertyCount(); i++)
         if (windowMetaObject->property(i).revision() <= expectedRevision)
             exposeProperty(windowMetaObject->property(i));
Using the same Window class as the previous example, the newProperty and newMethod would only be exposed in this code when the expected version is 1 or greater.
Since all methods are considered to be in revision 0 if untagged, a tag of Q_REVISION(0) is invalid and ignored.
This tag is not used by the meta-object system itself. Currently this is only used by the QtQml module.
For a more generic string tag, see QMetaMethod::tag()
See also QMetaMethod::revision().
Q_SET_OBJECT_NAME(Object)
This macro assigns Object the objectName "Object".
It doesn't matter whether Object is a pointer or not, the macro figures that out by itself.
This function was introduced in Qt 5.0.
See also QObject::objectName().
Q_SIGNAL
This is an additional macro that allows you to mark a single function as a signal. It can be quite useful, especially when you use a 3rd-party source code parser which doesn't understand a signals or Q_SIGNALS groups.
Use this macro to replace the signals keyword in class declarations, when you want to use Qt Signals and Slots with a 3rd party signal/slot mechanism.
The macro is normally used when no_keywords is specified with the CONFIG variable in the .pro file, but it can be used even when no_keywords is not specified.
Q_SIGNALS
Use this macro to replace the signals keyword in class declarations, when you want to use Qt Signals and Slots with a 3rd party signal/slot mechanism.
The macro is normally used when no_keywords is specified with the CONFIG variable in the .pro file, but it can be used even when no_keywords is not specified.
Q_SLOT
This is an additional macro that allows you to mark a single function as a slot. It can be quite useful, especially when you use a 3rd-party source code parser which doesn't understand a slots or Q_SLOTS groups.
Use this macro to replace the slots keyword in class declarations, when you want to use Qt Signals and Slots with a 3rd party signal/slot mechanism.
The macro is normally used when no_keywords is specified with the CONFIG variable in the .pro file, but it can be used even when no_keywords is not specified.
Q_SLOTS
Use this macro to replace the slots keyword in class declarations, when you want to use Qt Signals and Slots with a 3rd party signal/slot mechanism.
The macro is normally used when no_keywords is specified with the CONFIG variable in the .pro file, but it can be used even when no_keywords is not specified. 
 2020 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners.
The documentation provided herein is licensed under the terms of the GNU Free Documentation License version 1.3 as published by the Free Software Foundation.
Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners. 


Qt 5.15
Qt Widgets
C++ Classes
QWidget
Qt 5.15.1 Reference Documentation 
Contents
Public Types
Properties
Public Functions
Reimplemented Public Functions
Public Slots
Signals
Static Public Members
Protected Functions
Reimplemented Protected Functions
Protected Slots
Macros
Detailed Description
Top-Level and Child Widgets
Composite Widgets
Custom Widgets and Painting
Size Hints and Size Policies
Events
Groups of Functions and Properties
Widget Style Sheets
Transparency and Double Buffering
Creating Translucent Windows
Native Widgets vs Alien Widgets
QWidget Class
The QWidget class is the base class of all user interface objects. More...

Header:
#include <QWidget> 
qmake:
QT += widgets
Inherits:
QObject and QPaintDevice
Inherited By:
QAbstractButton, QAbstractSlider, QAbstractSpinBox, QCalendarWidget, QComboBox, QDesignerActionEditorInterface, QDesignerFormWindowInterface, QDesignerObjectInspectorInterface, QDesignerPropertyEditorInterface, QDesignerWidgetBoxInterface, QDesktopWidget, QDialog, QDialogButtonBox, QDockWidget, QFocusFrame, QFrame, QGroupBox, QKeySequenceEdit, QLineEdit, QMacCocoaViewContainer, QMacNativeWidget, QMainWindow, QMdiSubWindow, QMenu, QMenuBar, QOpenGLWidget, QProgressBar, QQuickWidget, QRubberBand, QSizeGrip, QSplashScreen, QSplitterHandle, QStatusBar, QSvgWidget, QTabBar, QTabWidget, QToolBar, and QWizardPage

List of all members, including inherited members
Obsolete members 
Public Types

enum 
RenderFlag { DrawWindowBackground, DrawChildren, IgnoreMask }
flags 
RenderFlags

Properties

acceptDrops : bool
accessibleDescription : QString
accessibleName : QString
autoFillBackground : bool
baseSize : QSize
childrenRect : const QRect
childrenRegion : const QRegion
contextMenuPolicy : Qt::ContextMenuPolicy
cursor : QCursor
enabled : bool
focus : const bool
focusPolicy : Qt::FocusPolicy
font : QFont
frameGeometry : const QRect
frameSize : const QSize
fullScreen : const bool
geometry : QRect
height : const int
inputMethodHints : Qt::InputMethodHints
isActiveWindow : const bool
layoutDirection : Qt::LayoutDirection
locale : QLocale
maximized : const bool
maximumHeight : int
maximumSize : QSize
maximumWidth : int
minimized : const bool
minimumHeight : int
minimumSize : QSize
minimumSizeHint : const QSize
minimumWidth : int
modal : const bool
mouseTracking : bool
normalGeometry : const QRect
palette : QPalette
pos : QPoint
rect : const QRect
size : QSize
sizeHint : const QSize
sizeIncrement : QSize
sizePolicy : QSizePolicy
statusTip : QString
styleSheet : QString
tabletTracking : bool
toolTip : QString
toolTipDuration : int
updatesEnabled : bool
visible : bool
whatsThis : QString
width : const int
windowFilePath : QString
windowFlags : Qt::WindowFlags
windowIcon : QIcon
windowModality : Qt::WindowModality
windowModified : bool
windowOpacity : double
windowTitle : QString
x : const int
y : const int

Public Functions


QWidget(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags())
virtual 
~QWidget()
bool 
acceptDrops() const
QString 
accessibleDescription() const
QString 
accessibleName() const
QList<QAction *> 
actions() const
void 
activateWindow()
void 
addAction(QAction *action)
void 
addActions(QList<QAction *> actions)
void 
adjustSize()
bool 
autoFillBackground() const
QPalette::ColorRole 
backgroundRole() const
QBackingStore *
backingStore() const
QSize 
baseSize() const
QWidget *
childAt(int x, int y) const
QWidget *
childAt(const QPoint &p) const
QRect 
childrenRect() const
QRegion 
childrenRegion() const
void 
clearFocus()
void 
clearMask()
QMargins 
contentsMargins() const
QRect 
contentsRect() const
Qt::ContextMenuPolicy 
contextMenuPolicy() const
QCursor 
cursor() const
WId 
effectiveWinId() const
void 
ensurePolished() const
Qt::FocusPolicy 
focusPolicy() const
QWidget *
focusProxy() const
QWidget *
focusWidget() const
const QFont &
font() const
QFontInfo 
fontInfo() const
QFontMetrics 
fontMetrics() const
QPalette::ColorRole 
foregroundRole() const
QRect 
frameGeometry() const
QSize 
frameSize() const
const QRect &
geometry() const
QPixmap 
grab(const QRect &rectangle = QRect(QPoint(0, 0), QSize(-1, -1)))
void 
grabGesture(Qt::GestureType gesture, Qt::GestureFlags flags = Qt::GestureFlags())
void 
grabKeyboard()
void 
grabMouse()
void 
grabMouse(const QCursor &cursor)
int 
grabShortcut(const QKeySequence &key, Qt::ShortcutContext context = Qt::WindowShortcut)
QGraphicsEffect *
graphicsEffect() const
QGraphicsProxyWidget *
graphicsProxyWidget() const
bool 
hasEditFocus() const
bool 
hasFocus() const
virtual bool 
hasHeightForWidth() const
bool 
hasMouseTracking() const
bool 
hasTabletTracking() const
int 
height() const
virtual int 
heightForWidth(int w) const
Qt::InputMethodHints 
inputMethodHints() const
virtual QVariant 
inputMethodQuery(Qt::InputMethodQuery query) const
void 
insertAction(QAction *before, QAction *action)
void 
insertActions(QAction *before, QList<QAction *> actions)
bool 
isActiveWindow() const
bool 
isAncestorOf(const QWidget *child) const
bool 
isEnabled() const
bool 
isEnabledTo(const QWidget *ancestor) const
bool 
isFullScreen() const
bool 
isHidden() const
bool 
isMaximized() const
bool 
isMinimized() const
bool 
isModal() const
bool 
isVisible() const
bool 
isVisibleTo(const QWidget *ancestor) const
bool 
isWindow() const
bool 
isWindowModified() const
QLayout *
layout() const
Qt::LayoutDirection 
layoutDirection() const
QLocale 
locale() const
QPoint 
mapFrom(const QWidget *parent, const QPoint &pos) const
QPoint 
mapFromGlobal(const QPoint &pos) const
QPoint 
mapFromParent(const QPoint &pos) const
QPoint 
mapTo(const QWidget *parent, const QPoint &pos) const
QPoint 
mapToGlobal(const QPoint &pos) const
QPoint 
mapToParent(const QPoint &pos) const
QRegion 
mask() const
int 
maximumHeight() const
QSize 
maximumSize() const
int 
maximumWidth() const
int 
minimumHeight() const
QSize 
minimumSize() const
virtual QSize 
minimumSizeHint() const
int 
minimumWidth() const
void 
move(const QPoint &)
void 
move(int x, int y)
QWidget *
nativeParentWidget() const
QWidget *
nextInFocusChain() const
QRect 
normalGeometry() const
void 
overrideWindowFlags(Qt::WindowFlags flags)
const QPalette &
palette() const
QWidget *
parentWidget() const
QPoint 
pos() const
QWidget *
previousInFocusChain() const
QRect 
rect() const
void 
releaseKeyboard()
void 
releaseMouse()
void 
releaseShortcut(int id)
void 
removeAction(QAction *action)
void 
render(QPaintDevice *target, const QPoint &targetOffset = QPoint(), const QRegion &sourceRegion = QRegion(), QWidget::RenderFlags renderFlags = RenderFlags(DrawWindowBackground | DrawChildren))
void 
render(QPainter *painter, const QPoint &targetOffset = QPoint(), const QRegion &sourceRegion = QRegion(), QWidget::RenderFlags renderFlags = RenderFlags(DrawWindowBackground | DrawChildren))
void 
repaint(int x, int y, int w, int h)
void 
repaint(const QRect &rect)
void 
repaint(const QRegion &rgn)
void 
resize(const QSize &)
void 
resize(int w, int h)
bool 
restoreGeometry(const QByteArray &geometry)
QByteArray 
saveGeometry() const
QScreen *
screen() const
void 
scroll(int dx, int dy)
void 
scroll(int dx, int dy, const QRect &r)
void 
setAcceptDrops(bool on)
void 
setAccessibleDescription(const QString &description)
void 
setAccessibleName(const QString &name)
void 
setAttribute(Qt::WidgetAttribute attribute, bool on = true)
void 
setAutoFillBackground(bool enabled)
void 
setBackgroundRole(QPalette::ColorRole role)
void 
setBaseSize(const QSize &)
void 
setBaseSize(int basew, int baseh)
void 
setContentsMargins(int left, int top, int right, int bottom)
void 
setContentsMargins(const QMargins &margins)
void 
setContextMenuPolicy(Qt::ContextMenuPolicy policy)
void 
setCursor(const QCursor &)
void 
setEditFocus(bool enable)
void 
setFixedHeight(int h)
void 
setFixedSize(const QSize &s)
void 
setFixedSize(int w, int h)
void 
setFixedWidth(int w)
void 
setFocus(Qt::FocusReason reason)
void 
setFocusPolicy(Qt::FocusPolicy policy)
void 
setFocusProxy(QWidget *w)
void 
setFont(const QFont &)
void 
setForegroundRole(QPalette::ColorRole role)
void 
setGeometry(const QRect &)
void 
setGeometry(int x, int y, int w, int h)
void 
setGraphicsEffect(QGraphicsEffect *effect)
void 
setInputMethodHints(Qt::InputMethodHints hints)
void 
setLayout(QLayout *layout)
void 
setLayoutDirection(Qt::LayoutDirection direction)
void 
setLocale(const QLocale &locale)
void 
setMask(const QBitmap &bitmap)
void 
setMask(const QRegion &region)
void 
setMaximumHeight(int maxh)
void 
setMaximumSize(const QSize &)
void 
setMaximumSize(int maxw, int maxh)
void 
setMaximumWidth(int maxw)
void 
setMinimumHeight(int minh)
void 
setMinimumSize(const QSize &)
void 
setMinimumSize(int minw, int minh)
void 
setMinimumWidth(int minw)
void 
setMouseTracking(bool enable)
void 
setPalette(const QPalette &)
void 
setParent(QWidget *parent)
void 
setParent(QWidget *parent, Qt::WindowFlags f)
void 
setShortcutAutoRepeat(int id, bool enable = true)
void 
setShortcutEnabled(int id, bool enable = true)
void 
setSizeIncrement(const QSize &)
void 
setSizeIncrement(int w, int h)
void 
setSizePolicy(QSizePolicy)
void 
setSizePolicy(QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical)
void 
setStatusTip(const QString &)
void 
setStyle(QStyle *style)
void 
setTabletTracking(bool enable)
void 
setToolTip(const QString &)
void 
setToolTipDuration(int msec)
void 
setUpdatesEnabled(bool enable)
void 
setWhatsThis(const QString &)
void 
setWindowFilePath(const QString &filePath)
void 
setWindowFlag(Qt::WindowType flag, bool on = true)
void 
setWindowFlags(Qt::WindowFlags type)
void 
setWindowIcon(const QIcon &icon)
void 
setWindowModality(Qt::WindowModality windowModality)
void 
setWindowOpacity(qreal level)
void 
setWindowRole(const QString &role)
void 
setWindowState(Qt::WindowStates windowState)
void 
setupUi(QWidget *widget)
QSize 
size() const
virtual QSize 
sizeHint() const
QSize 
sizeIncrement() const
QSizePolicy 
sizePolicy() const
void 
stackUnder(QWidget *w)
QString 
statusTip() const
QStyle *
style() const
QString 
styleSheet() const
bool 
testAttribute(Qt::WidgetAttribute attribute) const
QString 
toolTip() const
int 
toolTipDuration() const
bool 
underMouse() const
void 
ungrabGesture(Qt::GestureType gesture)
void 
unsetCursor()
void 
unsetLayoutDirection()
void 
unsetLocale()
void 
update(int x, int y, int w, int h)
void 
update(const QRect &rect)
void 
update(const QRegion &rgn)
void 
updateGeometry()
bool 
updatesEnabled() const
QRegion 
visibleRegion() const
QString 
whatsThis() const
int 
width() const
WId 
winId() const
QWidget *
window() const
QString 
windowFilePath() const
Qt::WindowFlags 
windowFlags() const
QWindow *
windowHandle() const
QIcon 
windowIcon() const
Qt::WindowModality 
windowModality() const
qreal 
windowOpacity() const
QString 
windowRole() const
Qt::WindowStates 
windowState() const
QString 
windowTitle() const
Qt::WindowType 
windowType() const
int 
x() const
int 
y() const

Reimplemented Public Functions

virtual QPaintEngine *
paintEngine() const override

Public Slots

bool 
close()
void 
hide()
void 
lower()
void 
raise()
void 
repaint()
void 
setDisabled(bool disable)
void 
setEnabled(bool)
void 
setFocus()
void 
setHidden(bool hidden)
void 
setStyleSheet(const QString &styleSheet)
virtual void 
setVisible(bool visible)
void 
setWindowModified(bool)
void 
setWindowTitle(const QString &)
void 
show()
void 
showFullScreen()
void 
showMaximized()
void 
showMinimized()
void 
showNormal()
void 
update()

Signals

void 
customContextMenuRequested(const QPoint &pos)
void 
windowIconChanged(const QIcon &icon)
void 
windowTitleChanged(const QString &title)

Static Public Members

QWidget *
createWindowContainer(QWindow *window, QWidget *parent = nullptr, Qt::WindowFlags flags = Qt::WindowFlags())
QWidget *
find(WId id)
QWidget *
keyboardGrabber()
QWidget *
mouseGrabber()
void 
setTabOrder(QWidget *first, QWidget *second)

Protected Functions

virtual void 
actionEvent(QActionEvent *event)
virtual void 
changeEvent(QEvent *event)
virtual void 
closeEvent(QCloseEvent *event)
virtual void 
contextMenuEvent(QContextMenuEvent *event)
void 
create(WId window = 0, bool initializeWindow = true, bool destroyOldWindow = true)
void 
destroy(bool destroyWindow = true, bool destroySubWindows = true)
virtual void 
dragEnterEvent(QDragEnterEvent *event)
virtual void 
dragLeaveEvent(QDragLeaveEvent *event)
virtual void 
dragMoveEvent(QDragMoveEvent *event)
virtual void 
dropEvent(QDropEvent *event)
virtual void 
enterEvent(QEvent *event)
virtual void 
focusInEvent(QFocusEvent *event)
bool 
focusNextChild()
virtual bool 
focusNextPrevChild(bool next)
virtual void 
focusOutEvent(QFocusEvent *event)
bool 
focusPreviousChild()
virtual void 
hideEvent(QHideEvent *event)
virtual void 
inputMethodEvent(QInputMethodEvent *event)
virtual void 
keyPressEvent(QKeyEvent *event)
virtual void 
keyReleaseEvent(QKeyEvent *event)
virtual void 
leaveEvent(QEvent *event)
virtual void 
mouseDoubleClickEvent(QMouseEvent *event)
virtual void 
mouseMoveEvent(QMouseEvent *event)
virtual void 
mousePressEvent(QMouseEvent *event)
virtual void 
mouseReleaseEvent(QMouseEvent *event)
virtual void 
moveEvent(QMoveEvent *event)
virtual bool 
nativeEvent(const QByteArray &eventType, void *message, long *result)
virtual void 
paintEvent(QPaintEvent *event)
virtual void 
resizeEvent(QResizeEvent *event)
virtual void 
showEvent(QShowEvent *event)
virtual void 
tabletEvent(QTabletEvent *event)
virtual void 
wheelEvent(QWheelEvent *event)

Reimplemented Protected Functions

virtual bool 
event(QEvent *event) override
virtual void 
initPainter(QPainter *painter) const override
virtual int 
metric(QPaintDevice::PaintDeviceMetric m) const override

Protected Slots

void 
updateMicroFocus()

Macros


QWIDGETSIZE_MAX

Detailed Description
The widget is the atom of the user interface: it receives mouse, keyboard and other events from the window system, and paints a representation of itself on the screen. Every widget is rectangular, and they are sorted in a Z-order. A widget is clipped by its parent and by the widgets in front of it.
A widget that is not embedded in a parent widget is called a window. Usually, windows have a frame and a title bar, although it is also possible to create windows without such decoration using suitable window flags). In Qt, QMainWindow and the various subclasses of QDialog are the most common window types.
Every widget's constructor accepts one or two standard arguments:
QWidget *parent = nullptr is the parent of the new widget. If it is nullptr (the default), the new widget will be a window. If not, it will be a child of parent, and be constrained by parent's geometry (unless you specify Qt::Window as window flag).
Qt::WindowFlags f = { } (where available) sets the window flags; the default is suitable for almost all widgets, but to get, for example, a window without a window system frame, you must use special flags.
QWidget has many member functions, but some of them have little direct functionality; for example, QWidget has a font property, but never uses this itself. There are many subclasses which provide real functionality, such as QLabel, QPushButton, QListWidget, and QTabWidget. 
Top-Level and Child Widgets
A widget without a parent widget is always an independent window (top-level widget). For these widgets, setWindowTitle() and setWindowIcon() set the title bar and icon respectively.
Non-window widgets are child widgets, displayed within their parent widgets. Most widgets in Qt are mainly useful as child widgets. For example, it is possible to display a button as a top-level window, but most people prefer to put their buttons inside other widgets, such as QDialog.

The diagram above shows a QGroupBox widget being used to hold various child widgets in a layout provided by QGridLayout. The QLabel child widgets have been outlined to indicate their full sizes.
If you want to use a QWidget to hold child widgets you will usually want to add a layout to the parent QWidget. See Layout Management for more information. 
Composite Widgets
When a widget is used as a container to group a number of child widgets, it is known as a composite widget. These can be created by constructing a widget with the required visual properties - a QFrame, for example - and adding child widgets to it, usually managed by a layout. The above diagram shows such a composite widget that was created using Qt Designer.
Composite widgets can also be created by subclassing a standard widget, such as QWidget or QFrame, and adding the necessary layout and child widgets in the constructor of the subclass. Many of the examples provided with Qt use this approach, and it is also covered in the Qt Tutorials. 
Custom Widgets and Painting
Since QWidget is a subclass of QPaintDevice, subclasses can be used to display custom content that is composed using a series of painting operations with an instance of the QPainter class. This approach contrasts with the canvas-style approach used by the Graphics View Framework where items are added to a scene by the application and are rendered by the framework itself.
Each widget performs all painting operations from within its paintEvent() function. This is called whenever the widget needs to be redrawn, either as a result of some external change or when requested by the application.
The Analog Clock example shows how a simple widget can handle paint events. 
Size Hints and Size Policies
When implementing a new widget, it is almost always useful to reimplement sizeHint() to provide a reasonable default size for the widget and to set the correct size policy with setSizePolicy().
By default, composite widgets which do not provide a size hint will be sized according to the space requirements of their child widgets.
The size policy lets you supply good default behavior for the layout management system, so that other widgets can contain and manage yours easily. The default size policy indicates that the size hint represents the preferred size of the widget, and this is often good enough for many widgets.
Note: The size of top-level widgets are constrained to 2/3 of the desktop's height and width. You can resize() the widget manually if these bounds are inadequate. 
Events
Widgets respond to events that are typically caused by user actions. Qt delivers events to widgets by calling specific event handler functions with instances of QEvent subclasses containing information about each event.
If your widget only contains child widgets, you probably do not need to implement any event handlers. If you want to detect a mouse click in a child widget call the child's underMouse() function inside the widget's mousePressEvent().
The Scribble example implements a wider set of events to handle mouse movement, button presses, and window resizing.
You will need to supply the behavior and content for your own widgets, but here is a brief overview of the events that are relevant to QWidget, starting with the most common ones:
paintEvent() is called whenever the widget needs to be repainted. Every widget displaying custom content must implement it. Painting using a QPainter can only take place in a paintEvent() or a function called by a paintEvent().
resizeEvent() is called when the widget has been resized.
mousePressEvent() is called when a mouse button is pressed while the mouse cursor is inside the widget, or when the widget has grabbed the mouse using grabMouse(). Pressing the mouse without releasing it is effectively the same as calling grabMouse().
mouseReleaseEvent() is called when a mouse button is released. A widget receives mouse release events when it has received the corresponding mouse press event. This means that if the user presses the mouse inside your widget, then drags the mouse somewhere else before releasing the mouse button, your widget receives the release event. There is one exception: if a popup menu appears while the mouse button is held down, this popup immediately steals the mouse events.
mouseDoubleClickEvent() is called when the user double-clicks in the widget. If the user double-clicks, the widget receives a mouse press event, a mouse release event, (a mouse click event,) a second mouse press, this event and finally a second mouse release event. (Some mouse move events may also be received if the mouse is not held steady during this operation.) It is not possible to distinguish a click from a double-click until the second click arrives. (This is one reason why most GUI books recommend that double-clicks be an extension of single-clicks, rather than trigger a different action.)
Widgets that accept keyboard input need to reimplement a few more event handlers:
keyPressEvent() is called whenever a key is pressed, and again when a key has been held down long enough for it to auto-repeat. The Tab and Shift+Tab keys are only passed to the widget if they are not used by the focus-change mechanisms. To force those keys to be processed by your widget, you must reimplement QWidget::event().
focusInEvent() is called when the widget gains keyboard focus (assuming you have called setFocusPolicy()). Well-behaved widgets indicate that they own the keyboard focus in a clear but discreet way.
focusOutEvent() is called when the widget loses keyboard focus.
You may be required to also reimplement some of the less common event handlers:
mouseMoveEvent() is called whenever the mouse moves while a mouse button is held down. This can be useful during drag and drop operations. If you call setMouseTracking(true), you get mouse move events even when no buttons are held down. (See also the Drag and Drop guide.)
keyReleaseEvent() is called whenever a key is released and while it is held down (if the key is auto-repeating). In that case, the widget will receive a pair of key release and key press event for every repeat. The Tab and Shift+Tab keys are only passed to the widget if they are not used by the focus-change mechanisms. To force those keys to be processed by your widget, you must reimplement QWidget::event().
wheelEvent() is called whenever the user turns the mouse wheel while the widget has the focus.
enterEvent() is called when the mouse enters the widget's screen space. (This excludes screen space owned by any of the widget's children.)
leaveEvent() is called when the mouse leaves the widget's screen space. If the mouse enters a child widget it will not cause a leaveEvent().
moveEvent() is called when the widget has been moved relative to its parent.
closeEvent() is called when the user closes the widget (or when close() is called).
There are also some rather obscure events described in the documentation for QEvent::Type. To handle these events, you need to reimplement event() directly.
The default implementation of event() handles Tab and Shift+Tab (to move the keyboard focus), and passes on most of the other events to one of the more specialized handlers above.
Events and the mechanism used to deliver them are covered in The Event System. 
Groups of Functions and Properties

Context
Functions and Properties
Window functions
show(), hide(), raise(), lower(), close().
Top-level windows
windowModified, windowTitle, windowIcon, isActiveWindow, activateWindow(), minimized, showMinimized(), maximized, showMaximized(), fullScreen, showFullScreen(), showNormal().
Window contents
update(), repaint(), scroll().
Geometry
pos, x(), y(), rect, size, width(), height(), move(), resize(), sizePolicy, sizeHint(), minimumSizeHint(), updateGeometry(), layout(), frameGeometry, geometry, childrenRect, childrenRegion, adjustSize(), mapFromGlobal(), mapToGlobal(), mapFromParent(), mapToParent(), maximumSize, minimumSize, sizeIncrement, baseSize, setFixedSize()
Mode
visible, isVisibleTo(), enabled, isEnabledTo(), modal, isWindow(), mouseTracking, updatesEnabled, visibleRegion().
Look and feel
style(), setStyle(), styleSheet, cursor, font, palette, backgroundRole(), setBackgroundRole(), fontInfo(), fontMetrics().
Keyboard focus functions
focus, focusPolicy, setFocus(), clearFocus(), setTabOrder(), setFocusProxy(), focusNextChild(), focusPreviousChild().
Mouse and keyboard grabbing
grabMouse(), releaseMouse(), grabKeyboard(), releaseKeyboard(), mouseGrabber(), keyboardGrabber().
Event handlers
event(), mousePressEvent(), mouseReleaseEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), keyPressEvent(), keyReleaseEvent(), focusInEvent(), focusOutEvent(), wheelEvent(), enterEvent(), leaveEvent(), paintEvent(), moveEvent(), resizeEvent(), closeEvent(), dragEnterEvent(), dragMoveEvent(), dragLeaveEvent(), dropEvent(), childEvent(), showEvent(), hideEvent(), customEvent(). changeEvent(),
System functions
parentWidget(), window(), setParent(), winId(), find(), metric().
Context menu
contextMenuPolicy, contextMenuEvent(), customContextMenuRequested(), actions()
Interactive help
setToolTip(), setWhatsThis()

Widget Style Sheets
In addition to the standard widget styles for each platform, widgets can also be styled according to rules specified in a style sheet. This feature enables you to customize the appearance of specific widgets to provide visual cues to users about their purpose. For example, a button could be styled in a particular way to indicate that it performs a destructive action.
The use of widget style sheets is described in more detail in the Qt Style Sheets document. 
Transparency and Double Buffering
Since Qt 4.0, QWidget automatically double-buffers its painting, so there is no need to write double-buffering code in paintEvent() to avoid flicker.
Since Qt 4.1, the contents of parent widgets are propagated by default to each of their children as long as Qt::WA_PaintOnScreen is not set. Custom widgets can be written to take advantage of this feature by updating irregular regions (to create non-rectangular child widgets), or painting with colors that have less than full alpha component. The following diagram shows how attributes and properties of a custom widget can be fine-tuned to achieve different effects.

In the above diagram, a semi-transparent rectangular child widget with an area removed is constructed and added to a parent widget (a QLabel showing a pixmap). Then, different properties and widget attributes are set to achieve different effects:
The left widget has no additional properties or widget attributes set. This default state suits most custom widgets using transparency, are irregularly-shaped, or do not paint over their entire area with an opaque brush.
The center widget has the autoFillBackground property set. This property is used with custom widgets that rely on the widget to supply a default background, and do not paint over their entire area with an opaque brush.
The right widget has the Qt::WA_OpaquePaintEvent widget attribute set. This indicates that the widget will paint over its entire area with opaque colors. The widget's area will initially be uninitialized, represented in the diagram with a red diagonal grid pattern that shines through the overpainted area. The Qt::WA_OpaquePaintArea attribute is useful for widgets that need to paint their own specialized contents quickly and do not need a default filled background.
To rapidly update custom widgets with simple background colors, such as real-time plotting or graphing widgets, it is better to define a suitable background color (using setBackgroundRole() with the QPalette::Window role), set the autoFillBackground property, and only implement the necessary drawing functionality in the widget's paintEvent().
To rapidly update custom widgets that constantly paint over their entire areas with opaque content, e.g., video streaming widgets, it is better to set the widget's Qt::WA_OpaquePaintEvent, avoiding any unnecessary overhead associated with repainting the widget's background.
If a widget has both the Qt::WA_OpaquePaintEvent widget attribute and the autoFillBackground property set, the Qt::WA_OpaquePaintEvent attribute takes precedence. Depending on your requirements, you should choose either one of them.
Since Qt 4.1, the contents of parent widgets are also propagated to standard Qt widgets. This can lead to some unexpected results if the parent widget is decorated in a non-standard way, as shown in the diagram below.

The scope for customizing the painting behavior of standard Qt widgets, without resorting to subclassing, is slightly less than that possible for custom widgets. Usually, the desired appearance of a standard widget can be achieved by setting its autoFillBackground property. 
Creating Translucent Windows
Since Qt 4.5, it has been possible to create windows with translucent regions on window systems that support compositing.
To enable this feature in a top-level widget, set its Qt::WA_TranslucentBackground attribute with setAttribute() and ensure that its background is painted with non-opaque colors in the regions you want to be partially transparent.
Platform notes:
X11: This feature relies on the use of an X server that supports ARGB visuals and a compositing window manager.
Windows: The widget needs to have the Qt::FramelessWindowHint window flag set for the translucency to work. 
Native Widgets vs Alien Widgets
Introduced in Qt 4.4, alien widgets are widgets unknown to the windowing system. They do not have a native window handle associated with them. This feature significantly speeds up widget painting, resizing, and removes flicker.
Should you require the old behavior with native windows, you can choose one of the following options:
Use the QT_USE_NATIVE_WINDOWS=1 in your environment.
Set the Qt::AA_NativeWindows attribute on your application. All widgets will be native widgets.
Set the Qt::WA_NativeWindow attribute on widgets: The widget itself and all of its ancestors will become native (unless Qt::WA_DontCreateNativeAncestors is set).
Call QWidget::winId to enforce a native window (this implies 3).
Set the Qt::WA_PaintOnScreen attribute to enforce a native window (this implies 3).
See also QEvent, QPainter, QGridLayout, and QBoxLayout.
Member Type Documentation
enum QWidget::RenderFlag
flags QWidget::RenderFlags
This enum describes how to render the widget when calling QWidget::render().

Constant
Value
Description
QWidget::DrawWindowBackground
0x1
If you enable this option, the widget's background is rendered into the target even if autoFillBackground is not set. By default, this option is enabled.
QWidget::DrawChildren
0x2
If you enable this option, the widget's children are rendered recursively into the target. By default, this option is enabled.
QWidget::IgnoreMask
0x4
If you enable this option, the widget's QWidget::mask() is ignored when rendering into the target. By default, this option is disabled.

This enum was introduced or modified in Qt 4.3.
The RenderFlags type is a typedef for QFlags<RenderFlag>. It stores an OR combination of RenderFlag values.
Property Documentation
acceptDrops : bool
This property holds whether drop events are enabled for this widget
Setting this property to true announces to the system that this widget may be able to accept drop events.
If the widget is the desktop (windowType() == Qt::Desktop), this may fail if another application is using the desktop; you can call acceptDrops() to test if this occurs.
Warning: Do not modify this property in a drag and drop event handler.
By default, this property is false.
Access functions:

bool 
acceptDrops() const
void 
setAcceptDrops(bool on)

See also Drag and Drop.
accessibleDescription : QString
This property holds the widget's description as seen by assistive technologies
The accessible description of a widget should convey what a widget does. While the accessibleName should be a short and consise string (e.g. Save), the description should give more context, such as Saves the current document.
This property has to be localized.
By default, this property contains an empty string and Qt falls back to using the tool tip to provide this information.
Access functions:

QString 
accessibleDescription() const
void 
setAccessibleDescription(const QString &description)

See also QWidget::accessibleName and QAccessibleInterface::text().
accessibleName : QString
This property holds the widget's name as seen by assistive technologies
This is the primary name by which assistive technology such as screen readers announce this widget. For most widgets setting this property is not required. For example for QPushButton the button's text will be used.
It is important to set this property when the widget does not provide any text. For example a button that only contains an icon needs to set this property to work with screen readers. The name should be short and equivalent to the visual information conveyed by the widget.
This property has to be localized.
By default, this property contains an empty string.
Access functions:

QString 
accessibleName() const
void 
setAccessibleName(const QString &name)

See also QWidget::accessibleDescription and QAccessibleInterface::text().
autoFillBackground : bool
This property holds whether the widget background is filled automatically
If enabled, this property will cause Qt to fill the background of the widget before invoking the paint event. The color used is defined by the QPalette::Window color role from the widget's palette.
In addition, Windows are always filled with QPalette::Window, unless the WA_OpaquePaintEvent or WA_NoSystemBackground attributes are set.
This property cannot be turned off (i.e., set to false) if a widget's parent has a static gradient for its background.
Warning: Use this property with caution in conjunction with Qt Style Sheets. When a widget has a style sheet with a valid background or a border-image, this property is automatically disabled.
By default, this property is false.
This property was introduced in Qt 4.1.
Access functions:

bool 
autoFillBackground() const
void 
setAutoFillBackground(bool enabled)

See also Qt::WA_OpaquePaintEvent, Qt::WA_NoSystemBackground, and Transparency and Double Buffering.
baseSize : QSize
This property holds the base size of the widget
The base size is used to calculate a proper widget size if the widget defines sizeIncrement().
By default, for a newly-created widget, this property contains a size with zero width and height.
Access functions:

QSize 
baseSize() const
void 
setBaseSize(const QSize &)
void 
setBaseSize(int basew, int baseh)

See also setSizeIncrement().
childrenRect : const QRect
This property holds the bounding rectangle of the widget's children
Hidden children are excluded.
By default, for a widget with no children, this property contains a rectangle with zero width and height located at the origin.
Access functions:

QRect 
childrenRect() const

See also childrenRegion() and geometry().
childrenRegion : const QRegion
This property holds the combined region occupied by the widget's children
Hidden children are excluded.
By default, for a widget with no children, this property contains an empty region.
Access functions:

QRegion 
childrenRegion() const

See also childrenRect(), geometry(), and mask().
contextMenuPolicy : Qt::ContextMenuPolicy
how the widget shows a context menu
The default value of this property is Qt::DefaultContextMenu, which means the contextMenuEvent() handler is called. Other values are Qt::NoContextMenu, Qt::PreventContextMenu, Qt::ActionsContextMenu, and Qt::CustomContextMenu. With Qt::CustomContextMenu, the signal customContextMenuRequested() is emitted.
Access functions:

Qt::ContextMenuPolicy 
contextMenuPolicy() const
void 
setContextMenuPolicy(Qt::ContextMenuPolicy policy)

See also contextMenuEvent(), customContextMenuRequested(), and actions().
cursor : QCursor
This property holds the cursor shape for this widget
The mouse cursor will assume this shape when it's over this widget. See the list of predefined cursor objects for a range of useful shapes.
An editor widget might use an I-beam cursor:
 setCursor(Qt::IBeamCursor);
If no cursor has been set, or after a call to unsetCursor(), the parent's cursor is used.
By default, this property contains a cursor with the Qt::ArrowCursor shape.
Some underlying window implementations will reset the cursor if it leaves a widget even if the mouse is grabbed. If you want to have a cursor set for all widgets, even when outside the window, consider QGuiApplication::setOverrideCursor().
Access functions:

QCursor 
cursor() const
void 
setCursor(const QCursor &)
void 
unsetCursor()

See also QGuiApplication::setOverrideCursor().
enabled : bool
This property holds whether the widget is enabled
In general an enabled widget handles keyboard and mouse events; a disabled widget does not. An exception is made with QAbstractButton.
Some widgets display themselves differently when they are disabled. For example a button might draw its label grayed out. If your widget needs to know when it becomes enabled or disabled, you can use the changeEvent() with type QEvent::EnabledChange.
Disabling a widget implicitly disables all its children. Enabling respectively enables all child widgets unless they have been explicitly disabled. It it not possible to explicitly enable a child widget which is not a window while its parent widget remains disabled.
By default, this property is true.
Access functions:

bool 
isEnabled() const
void 
setEnabled(bool)

See also isEnabledTo(), QKeyEvent, QMouseEvent, and changeEvent().
focus : const bool
This property holds whether this widget (or its focus proxy) has the keyboard input focus
By default, this property is false.
Note: Obtaining the value of this property for a widget is effectively equivalent to checking whether QApplication::focusWidget() refers to the widget.
Access functions:

bool 
hasFocus() const

See also setFocus(), clearFocus(), setFocusPolicy(), and QApplication::focusWidget().
focusPolicy : Qt::FocusPolicy
This property holds the way the widget accepts keyboard focus
The policy is Qt::TabFocus if the widget accepts keyboard focus by tabbing, Qt::ClickFocus if the widget accepts focus by clicking, Qt::StrongFocus if it accepts both, and Qt::NoFocus (the default) if it does not accept focus at all.
You must enable keyboard focus for a widget if it processes keyboard events. This is normally done from the widget's constructor. For instance, the QLineEdit constructor calls setFocusPolicy(Qt::StrongFocus).
If the widget has a focus proxy, then the focus policy will be propagated to it.
Access functions:

Qt::FocusPolicy 
focusPolicy() const
void 
setFocusPolicy(Qt::FocusPolicy policy)

See also focusInEvent(), focusOutEvent(), keyPressEvent(), keyReleaseEvent(), and enabled.
font : QFont
This property holds the font currently set for the widget
This property describes the widget's requested font. The font is used by the widget's style when rendering standard components, and is available as a means to ensure that custom widgets can maintain consistency with the native platform's look and feel. It's common that different platforms, or different styles, define different fonts for an application.
When you assign a new font to a widget, the properties from this font are combined with the widget's default font to form the widget's final font. You can call fontInfo() to get a copy of the widget's final font. The final font is also used to initialize QPainter's font.
The default depends on the system environment. QApplication maintains a system/theme font which serves as a default for all widgets. There may also be special font defaults for certain types of widgets. You can also define default fonts for widgets yourself by passing a custom font and the name of a widget to QApplication::setFont(). Finally, the font is matched against Qt's font database to find the best match.
QWidget propagates explicit font properties from parent to child. If you change a specific property on a font and assign that font to a widget, that property will propagate to all the widget's children, overriding any system defaults for that property. Note that fonts by default don't propagate to windows (see isWindow()) unless the Qt::WA_WindowPropagation attribute is enabled.
QWidget's font propagation is similar to its palette propagation.
The current style, which is used to render the content of all standard Qt widgets, is free to choose to use the widget font, or in some cases, to ignore it (partially, or completely). In particular, certain styles like GTK style, Mac style, and Windows Vista style, apply special modifications to the widget font to match the platform's native look and feel. Because of this, assigning properties to a widget's font is not guaranteed to change the appearance of the widget. Instead, you may choose to apply a styleSheet.
Note: If Qt Style Sheets are used on the same widget as setFont(), style sheets will take precedence if the settings conflict.
Access functions:

const QFont &
font() const
void 
setFont(const QFont &)

See also fontInfo() and fontMetrics().
frameGeometry : const QRect
geometry of the widget relative to its parent including any window frame
See the Window Geometry documentation for an overview of geometry issues with windows.
By default, this property contains a value that depends on the user's platform and screen geometry.
Access functions:

QRect 
frameGeometry() const

See also geometry(), x(), y(), and pos().
frameSize : const QSize
This property holds the size of the widget including any window frame
By default, this property contains a value that depends on the user's platform and screen geometry.
Access functions:

QSize 
frameSize() const

fullScreen : const bool
This property holds whether the widget is shown in full screen mode
A widget in full screen mode occupies the whole screen area and does not display window decorations, such as a title bar.
By default, this property is false.
Access functions:

bool 
isFullScreen() const

See also windowState(), minimized, and maximized.
geometry : QRect
This property holds the geometry of the widget relative to its parent and excluding the window frame
When changing the geometry, the widget, if visible, receives a move event (moveEvent()) and/or a resize event (resizeEvent()) immediately. If the widget is not currently visible, it is guaranteed to receive appropriate events before it is shown.
The size component is adjusted if it lies outside the range defined by minimumSize() and maximumSize().
Warning: Calling setGeometry() inside resizeEvent() or moveEvent() can lead to infinite recursion.
See the Window Geometry documentation for an overview of geometry issues with windows.
By default, this property contains a value that depends on the user's platform and screen geometry.
Access functions:

const QRect &
geometry() const
void 
setGeometry(int x, int y, int w, int h)
void 
setGeometry(const QRect &)

See also frameGeometry(), rect(), move(), resize(), moveEvent(), resizeEvent(), minimumSize(), and maximumSize().
height : const int
This property holds the height of the widget excluding any window frame
See the Window Geometry documentation for an overview of geometry issues with windows.
Note: Do not use this function to find the height of a screen on a multiple screen desktop. Read this note for details.
By default, this property contains a value that depends on the user's platform and screen geometry.
Access functions:

int 
height() const

See also geometry, width, and size.
inputMethodHints : Qt::InputMethodHints
What input method specific hints the widget has.
This is only relevant for input widgets. It is used by the input method to retrieve hints as to how the input method should operate. For example, if the Qt::ImhFormattedNumbersOnly flag is set, the input method may change its visual components to reflect that only numbers can be entered.
Warning: Some widgets require certain flags in order to work as intended. To set a flag, do w->setInputMethodHints(w->inputMethodHints()|f) instead of w->setInputMethodHints(f).
Note: The flags are only hints, so the particular input method implementation is free to ignore them. If you want to be sure that a certain type of characters are entered, you should also set a QValidator on the widget.
The default value is Qt::ImhNone.
This property was introduced in Qt 4.6.
Access functions:

Qt::InputMethodHints 
inputMethodHints() const
void 
setInputMethodHints(Qt::InputMethodHints hints)

See also inputMethodQuery().
isActiveWindow : const bool
This property holds whether this widget's window is the active window
The active window is the window that contains the widget that has keyboard focus (The window may still have focus if it has no widgets or none of its widgets accepts keyboard focus).
When popup windows are visible, this property is true for both the active window and for the popup.
By default, this property is false.
Access functions:

bool 
isActiveWindow() const

See also activateWindow() and QApplication::activeWindow().
layoutDirection : Qt::LayoutDirection
This property holds the layout direction for this widget
By default, this property is set to Qt::LeftToRight.
When the layout direction is set on a widget, it will propagate to the widget's children, but not to a child that is a window and not to a child for which setLayoutDirection() has been explicitly called. Also, child widgets added after setLayoutDirection() has been called for the parent do not inherit the parent's layout direction.
This method no longer affects text layout direction since Qt 4.7.
Access functions:

Qt::LayoutDirection 
layoutDirection() const
void 
setLayoutDirection(Qt::LayoutDirection direction)
void 
unsetLayoutDirection()

See also QApplication::layoutDirection.
locale : QLocale
This property holds the widget's locale
As long as no special locale has been set, this is either the parent's locale or (if this widget is a top level widget), the default locale.
If the widget displays dates or numbers, these should be formatted using the widget's locale.
This property was introduced in Qt 4.3.
Access functions:

QLocale 
locale() const
void 
setLocale(const QLocale &locale)
void 
unsetLocale()

See also QLocale and QLocale::setDefault().
maximized : const bool
This property holds whether this widget is maximized
This property is only relevant for windows.
Note: Due to limitations on some window systems, this does not always report the expected results (e.g., if the user on X11 maximizes the window via the window manager, Qt has no way of distinguishing this from any other resize). This is expected to improve as window manager protocols evolve.
By default, this property is false.
Access functions:

bool 
isMaximized() const

See also windowState(), showMaximized(), visible, show(), hide(), showNormal(), and minimized.
maximumHeight : int
This property holds the widget's maximum height in pixels
This property corresponds to the height held by the maximumSize property.
By default, this property contains a value of 16777215.
Note: The definition of the QWIDGETSIZE_MAX macro limits the maximum size of widgets.
Access functions:

int 
maximumHeight() const
void 
setMaximumHeight(int maxh)

See also maximumSize and maximumWidth.
maximumSize : QSize
This property holds the widget's maximum size in pixels
The widget cannot be resized to a larger size than the maximum widget size.
By default, this property contains a size in which both width and height have values of 16777215.
Note: The definition of the QWIDGETSIZE_MAX macro limits the maximum size of widgets.
Access functions:

QSize 
maximumSize() const
void 
setMaximumSize(const QSize &)
void 
setMaximumSize(int maxw, int maxh)

See also maximumWidth, maximumHeight, minimumSize, and sizeIncrement.
maximumWidth : int
This property holds the widget's maximum width in pixels
This property corresponds to the width held by the maximumSize property.
By default, this property contains a value of 16777215.
Note: The definition of the QWIDGETSIZE_MAX macro limits the maximum size of widgets.
Access functions:

int 
maximumWidth() const
void 
setMaximumWidth(int maxw)

See also maximumSize and maximumHeight.
minimized : const bool
This property holds whether this widget is minimized (iconified)
This property is only relevant for windows.
By default, this property is false.
Access functions:

bool 
isMinimized() const

See also showMinimized(), visible, show(), hide(), showNormal(), and maximized.
minimumHeight : int
This property holds the widget's minimum height in pixels
This property corresponds to the height held by the minimumSize property.
By default, this property has a value of 0.
Access functions:

int 
minimumHeight() const
void 
setMinimumHeight(int minh)

See also minimumSize and minimumWidth.
minimumSize : QSize
This property holds the widget's minimum size
The widget cannot be resized to a smaller size than the minimum widget size. The widget's size is forced to the minimum size if the current size is smaller.
The minimum size set by this function will override the minimum size defined by QLayout. In order to unset the minimum size, use a value of QSize(0, 0).
By default, this property contains a size with zero width and height.
Access functions:

QSize 
minimumSize() const
void 
setMinimumSize(const QSize &)
void 
setMinimumSize(int minw, int minh)

See also minimumWidth, minimumHeight, maximumSize, and sizeIncrement.
minimumSizeHint : const QSize
This property holds the recommended minimum size for the widget
If the value of this property is an invalid size, no minimum size is recommended.
The default implementation of minimumSizeHint() returns an invalid size if there is no layout for this widget, and returns the layout's minimum size otherwise. Most built-in widgets reimplement minimumSizeHint().
QLayout will never resize a widget to a size smaller than the minimum size hint unless minimumSize() is set or the size policy is set to QSizePolicy::Ignore. If minimumSize() is set, the minimum size hint will be ignored.
Access functions:

virtual QSize 
minimumSizeHint() const

See also QSize::isValid(), resize(), setMinimumSize(), and sizePolicy().
minimumWidth : int
This property holds the widget's minimum width in pixels
This property corresponds to the width held by the minimumSize property.
By default, this property has a value of 0.
Access functions:

int 
minimumWidth() const
void 
setMinimumWidth(int minw)

See also minimumSize and minimumHeight.
modal : const bool
This property holds whether the widget is a modal widget
This property only makes sense for windows. A modal widget prevents widgets in all other windows from getting any input.
By default, this property is false.
Access functions:

bool 
isModal() const

See also isWindow(), windowModality, and QDialog.
mouseTracking : bool
This property holds whether mouse tracking is enabled for the widget
If mouse tracking is disabled (the default), the widget only receives mouse move events when at least one mouse button is pressed while the mouse is being moved.
If mouse tracking is enabled, the widget receives mouse move events even if no buttons are pressed.
Access functions:

bool 
hasMouseTracking() const
void 
setMouseTracking(bool enable)

See also mouseMoveEvent().
normalGeometry : const QRect
This property holds the geometry of the widget as it will appear when shown as a normal (not maximized or full screen) top-level widget
For child widgets this property always holds an empty rectangle.
By default, this property contains an empty rectangle.
Access functions:

QRect 
normalGeometry() const

See also QWidget::windowState() and QWidget::geometry.
palette : QPalette
This property holds the widget's palette
This property describes the widget's palette. The palette is used by the widget's style when rendering standard components, and is available as a means to ensure that custom widgets can maintain consistency with the native platform's look and feel. It's common that different platforms, or different styles, have different palettes.
When you assign a new palette to a widget, the color roles from this palette are combined with the widget's default palette to form the widget's final palette. The palette entry for the widget's background role is used to fill the widget's background (see QWidget::autoFillBackground), and the foreground role initializes QPainter's pen.
The default depends on the system environment. QApplication maintains a system/theme palette which serves as a default for all widgets. There may also be special palette defaults for certain types of widgets (e.g., on Windows Vista, all classes that derive from QMenuBar have a special default palette). You can also define default palettes for widgets yourself by passing a custom palette and the name of a widget to QApplication::setPalette(). Finally, the style always has the option of polishing the palette as it's assigned (see QStyle::polish()).
QWidget propagates explicit palette roles from parent to child. If you assign a brush or color to a specific role on a palette and assign that palette to a widget, that role will propagate to all the widget's children, overriding any system defaults for that role. Note that palettes by default don't propagate to windows (see isWindow()) unless the Qt::WA_WindowPropagation attribute is enabled.
QWidget's palette propagation is similar to its font propagation.
The current style, which is used to render the content of all standard Qt widgets, is free to choose colors and brushes from the widget palette, or in some cases, to ignore the palette (partially, or completely). In particular, certain styles like GTK style, Mac style, and Windows Vista style, depend on third party APIs to render the content of widgets, and these styles typically do not follow the palette. Because of this, assigning roles to a widget's palette is not guaranteed to change the appearance of the widget. Instead, you may choose to apply a styleSheet.
Warning: Do not use this function in conjunction with Qt Style Sheets. When using style sheets, the palette of a widget can be customized using the "color", "background-color", "selection-color", "selection-background-color" and "alternate-background-color".
Access functions:

const QPalette &
palette() const
void 
setPalette(const QPalette &)

See also QGuiApplication::palette(), QWidget::font(), and Qt Style Sheets.
pos : QPoint
This property holds the position of the widget within its parent widget
If the widget is a window, the position is that of the widget on the desktop, including its frame.
When changing the position, the widget, if visible, receives a move event (moveEvent()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.
By default, this property contains a position that refers to the origin.
Warning: Calling move() or setGeometry() inside moveEvent() can lead to infinite recursion.
See the Window Geometry documentation for an overview of geometry issues with windows.
Access functions:

QPoint 
pos() const
void 
move(int x, int y)
void 
move(const QPoint &)

See also frameGeometry, size, x(), and y().
rect : const QRect
This property holds the internal geometry of the widget excluding any window frame
The rect property equals QRect(0, 0, width(), height()).
See the Window Geometry documentation for an overview of geometry issues with windows.
By default, this property contains a value that depends on the user's platform and screen geometry.
Access functions:

QRect 
rect() const

See also size.
size : QSize
This property holds the size of the widget excluding any window frame
If the widget is visible when it is being resized, it receives a resize event (resizeEvent()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.
The size is adjusted if it lies outside the range defined by minimumSize() and maximumSize().
By default, this property contains a value that depends on the user's platform and screen geometry.
Warning: Calling resize() or setGeometry() inside resizeEvent() can lead to infinite recursion.
Note: Setting the size to QSize(0, 0) will cause the widget to not appear on screen. This also applies to windows.
Access functions:

QSize 
size() const
void 
resize(int w, int h)
void 
resize(const QSize &)

See also pos, geometry, minimumSize, maximumSize, resizeEvent(), and adjustSize().
sizeHint : const QSize
This property holds the recommended size for the widget
If the value of this property is an invalid size, no size is recommended.
The default implementation of sizeHint() returns an invalid size if there is no layout for this widget, and returns the layout's preferred size otherwise.
Access functions:

virtual QSize 
sizeHint() const

See also QSize::isValid(), minimumSizeHint(), sizePolicy(), setMinimumSize(), and updateGeometry().
sizeIncrement : QSize
This property holds the size increment of the widget
When the user resizes the window, the size will move in steps of sizeIncrement().width() pixels horizontally and sizeIncrement.height() pixels vertically, with baseSize() as the basis. Preferred widget sizes are for non-negative integers i and j:
 width = baseSize().width() + i * sizeIncrement().width();
 height = baseSize().height() + j * sizeIncrement().height();
Note that while you can set the size increment for all widgets, it only affects windows.
By default, this property contains a size with zero width and height.
Warning: The size increment has no effect under Windows, and may be disregarded by the window manager on X11.
Access functions:

QSize 
sizeIncrement() const
void 
setSizeIncrement(const QSize &)
void 
setSizeIncrement(int w, int h)

See also size, minimumSize, and maximumSize.
sizePolicy : QSizePolicy
This property holds the default layout behavior of the widget
If there is a QLayout that manages this widget's children, the size policy specified by that layout is used. If there is no such QLayout, the result of this function is used.
The default policy is Preferred/Preferred, which means that the widget can be freely resized, but prefers to be the size sizeHint() returns. Button-like widgets set the size policy to specify that they may stretch horizontally, but are fixed vertically. The same applies to lineedit controls (such as QLineEdit, QSpinBox or an editable QComboBox) and other horizontally orientated widgets (such as QProgressBar). QToolButton's are normally square, so they allow growth in both directions. Widgets that support different directions (such as QSlider, QScrollBar or QHeader) specify stretching in the respective direction only. Widgets that can provide scroll bars (usually subclasses of QScrollArea) tend to specify that they can use additional space, and that they can make do with less than sizeHint().
Access functions:

QSizePolicy 
sizePolicy() const
void 
setSizePolicy(QSizePolicy)
void 
setSizePolicy(QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical)

See also sizeHint(), QLayout, QSizePolicy, and updateGeometry().
statusTip : QString
This property holds the widget's status tip
By default, this property contains an empty string.
Access functions:

QString 
statusTip() const
void 
setStatusTip(const QString &)

See also toolTip and whatsThis.
styleSheet : QString
This property holds the widget's style sheet
The style sheet contains a textual description of customizations to the widget's style, as described in the Qt Style Sheets document.
Since Qt 4.5, Qt style sheets fully supports macOS.
Warning: Qt style sheets are currently not supported for custom QStyle subclasses. We plan to address this in some future release.
This property was introduced in Qt 4.2.
Access functions:

QString 
styleSheet() const
void 
setStyleSheet(const QString &styleSheet)

See also setStyle(), QApplication::styleSheet, and Qt Style Sheets.
tabletTracking : bool
This property holds whether tablet tracking is enabled for the widget
If tablet tracking is disabled (the default), the widget only receives tablet move events when the stylus is in contact with the tablet, or at least one stylus button is pressed, while the stylus is being moved.
If tablet tracking is enabled, the widget receives tablet move events even while hovering in proximity. This is useful for monitoring position as well as the auxiliary properties such as rotation and tilt, and providing feedback in the UI.
This property was introduced in Qt 5.9.
Access functions:

bool 
hasTabletTracking() const
void 
setTabletTracking(bool enable)

See also tabletEvent().
toolTip : QString
This property holds the widget's tooltip
Note that by default tooltips are only shown for widgets that are children of the active window. You can change this behavior by setting the attribute Qt::WA_AlwaysShowToolTips on the window, not on the widget with the tooltip.
If you want to control a tooltip's behavior, you can intercept the event() function and catch the QEvent::ToolTip event (e.g., if you want to customize the area for which the tooltip should be shown).
By default, this property contains an empty string.
Access functions:

QString 
toolTip() const
void 
setToolTip(const QString &)

See also QToolTip, statusTip, and whatsThis.
toolTipDuration : int
This property holds the widget's tooltip duration
Specifies how long time the tooltip will be displayed, in milliseconds. If the value is -1 (default) the duration is calculated depending on the length of the tooltip.
This property was introduced in Qt 5.2.
Access functions:

int 
toolTipDuration() const
void 
setToolTipDuration(int msec)

See also toolTip.
updatesEnabled : bool
This property holds whether updates are enabled
An updates enabled widget receives paint events and has a system background; a disabled widget does not. This also implies that calling update() and repaint() has no effect if updates are disabled.
By default, this property is true.
setUpdatesEnabled() is normally used to disable updates for a short period of time, for instance to avoid screen flicker during large changes. In Qt, widgets normally do not generate screen flicker, but on X11 the server might erase regions on the screen when widgets get hidden before they can be replaced by other widgets. Disabling updates solves this.
Example:
 setUpdatesEnabled(false);
 bigVisualChanges();
 setUpdatesEnabled(true);
Disabling a widget implicitly disables all its children. Enabling a widget enables all child widgets except top-level widgets or those that have been explicitly disabled. Re-enabling updates implicitly calls update() on the widget.
Access functions:

bool 
updatesEnabled() const
void 
setUpdatesEnabled(bool enable)

See also paintEvent().
visible : bool
This property holds whether the widget is visible
Calling setVisible(true) or show() sets the widget to visible status if all its parent widgets up to the window are visible. If an ancestor is not visible, the widget won't become visible until all its ancestors are shown. If its size or position has changed, Qt guarantees that a widget gets move and resize events just before it is shown. If the widget has not been resized yet, Qt will adjust the widget's size to a useful default using adjustSize().
Calling setVisible(false) or hide() hides a widget explicitly. An explicitly hidden widget will never become visible, even if all its ancestors become visible, unless you show it.
A widget receives show and hide events when its visibility status changes. Between a hide and a show event, there is no need to waste CPU cycles preparing or displaying information to the user. A video application, for example, might simply stop generating new frames.
A widget that happens to be obscured by other windows on the screen is considered to be visible. The same applies to iconified windows and windows that exist on another virtual desktop (on platforms that support this concept). A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g. a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again.
You almost never have to reimplement the setVisible() function. If you need to change some settings before a widget is shown, use showEvent() instead. If you need to do some delayed initialization use the Polish event delivered to the event() function.
Access functions:

bool 
isVisible() const
virtual void 
setVisible(bool visible)

See also show(), hide(), isHidden(), isVisibleTo(), isMinimized(), showEvent(), and hideEvent().
whatsThis : QString
This property holds the widget's What's This help text.
By default, this property contains an empty string.
Access functions:

QString 
whatsThis() const
void 
setWhatsThis(const QString &)

See also QWhatsThis, QWidget::toolTip, and QWidget::statusTip.
width : const int
This property holds the width of the widget excluding any window frame
See the Window Geometry documentation for an overview of geometry issues with windows.
Note: Do not use this function to find the width of a screen on a multiple screen desktop. Read this note for details.
By default, this property contains a value that depends on the user's platform and screen geometry.
Access functions:

int 
width() const

See also geometry, height, and size.
windowFilePath : QString
This property holds the file path associated with a widget
This property only makes sense for windows. It associates a file path with a window. If you set the file path, but have not set the window title, Qt sets the window title to the file name of the specified path, obtained using QFileInfo::fileName().
If the window title is set at any point, then the window title takes precedence and will be shown instead of the file path string.
Additionally, on macOS, this has an added benefit that it sets the proxy icon for the window, assuming that the file path exists.
If no file path is set, this property contains an empty string.
By default, this property contains an empty string.
This property was introduced in Qt 4.4.
Access functions:

QString 
windowFilePath() const
void 
setWindowFilePath(const QString &filePath)

See also windowTitle and windowIcon.
windowFlags : Qt::WindowFlags
Window flags are a combination of a type (e.g. Qt::Dialog) and zero or more hints to the window system (e.g. Qt::FramelessWindowHint).
If the widget had type Qt::Widget or Qt::SubWindow and becomes a window (Qt::Window, Qt::Dialog, etc.), it is put at position (0, 0) on the desktop. If the widget is a window and becomes a Qt::Widget or Qt::SubWindow, it is put at position (0, 0) relative to its parent widget.
Note: This function calls setParent() when changing the flags for a window, causing the widget to be hidden. You must call show() to make the widget visible again..
Access functions:

Qt::WindowFlags 
windowFlags() const
void 
setWindowFlags(Qt::WindowFlags type)

See also windowType(), setWindowFlag(), and Window Flags Example.
windowIcon : QIcon
This property holds the widget's icon
This property only makes sense for windows. If no icon has been set, windowIcon() returns the application icon (QApplication::windowIcon()).
Note: On macOS, window icons represent the active document, and will not be displayed unless a file path has also been set using setWindowFilePath.
Access functions:

QIcon 
windowIcon() const
void 
setWindowIcon(const QIcon &icon)

Notifier signal:

void 
windowIconChanged(const QIcon &icon)

See also windowTitle and setWindowFilePath.
windowModality : Qt::WindowModality
This property holds which windows are blocked by the modal widget
This property only makes sense for windows. A modal widget prevents widgets in other windows from getting input. The value of this property controls which windows are blocked when the widget is visible. Changing this property while the window is visible has no effect; you must hide() the widget first, then show() it again.
By default, this property is Qt::NonModal.
This property was introduced in Qt 4.1.
Access functions:

Qt::WindowModality 
windowModality() const
void 
setWindowModality(Qt::WindowModality windowModality)

See also isWindow(), QWidget::modal, and QDialog.
windowModified : bool
This property holds whether the document shown in the window has unsaved changes
A modified window is a window whose content has changed but has not been saved to disk. This flag will have different effects varied by the platform. On macOS the close button will have a modified look; on other platforms, the window title will have an '*' (asterisk).
The window title must contain a "[*]" placeholder, which indicates where the '*' should appear. Normally, it should appear right after the file name (e.g., "document1.txt[*] - Text Editor"). If the window isn't modified, the placeholder is simply removed.
Note that if a widget is set as modified, all its ancestors will also be set as modified. However, if you call setWindowModified(false) on a widget, this will not propagate to its parent because other children of the parent might have been modified.
Access functions:

bool 
isWindowModified() const
void 
setWindowModified(bool)

See also windowTitle, Application Example, SDI Example, and MDI Example.
windowOpacity : double
This property holds the level of opacity for the window.
The valid range of opacity is from 1.0 (completely opaque) to 0.0 (completely transparent).
By default the value of this property is 1.0.
This feature is available on Embedded Linux, macOS, Windows, and X11 platforms that support the Composite extension.
Note: On X11 you need to have a composite manager running, and the X11 specific _NET_WM_WINDOW_OPACITY atom needs to be supported by the window manager you are using.
Warning: Changing this property from opaque to transparent might issue a paint event that needs to be processed before the window is displayed correctly. This affects mainly the use of QScreen::grabWindow(). Also note that semi-transparent windows update and resize significantly slower than opaque windows.
Access functions:

qreal 
windowOpacity() const
void 
setWindowOpacity(qreal level)

See also setMask().
windowTitle : QString
This property holds the window title (caption)
This property only makes sense for top-level widgets, such as windows and dialogs. If no caption has been set, the title is based of the windowFilePath. If neither of these is set, then the title is an empty string.
If you use the windowModified mechanism, the window title must contain a "[*]" placeholder, which indicates where the '*' should appear. Normally, it should appear right after the file name (e.g., "document1.txt[*] - Text Editor"). If the windowModified property is false (the default), the placeholder is simply removed.
On some desktop platforms (including Windows and Unix), the application name (from QGuiApplication::applicationDisplayName) is added at the end of the window title, if set. This is done by the QPA plugin, so it is shown to the user, but isn't part of the windowTitle string.
Access functions:

QString 
windowTitle() const
void 
setWindowTitle(const QString &)

Notifier signal:

void 
windowTitleChanged(const QString &title)

See also windowIcon, windowModified, and windowFilePath.
x : const int
This property holds the x coordinate of the widget relative to its parent including any window frame
See the Window Geometry documentation for an overview of geometry issues with windows.
By default, this property has a value of 0.
Access functions:

int 
x() const

See also frameGeometry, y, and pos.
y : const int
This property holds the y coordinate of the widget relative to its parent and including any window frame
See the Window Geometry documentation for an overview of geometry issues with windows.
By default, this property has a value of 0.
Access functions:

int 
y() const

See also frameGeometry, x, and pos.
Member Function Documentation
QWidget::QWidget(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags())
Constructs a widget which is a child of parent, with widget flags set to f.
If parent is nullptr, the new widget becomes a window. If parent is another widget, this widget becomes a child window inside parent. The new widget is deleted when its parent is deleted.
The widget flags argument, f, is normally 0, but it can be set to customize the frame of a window (i.e. parent must be nullptr). To customize the frame, use a value composed from the bitwise OR of any of the window flags.
If you add a child widget to an already visible widget you must explicitly show the child to make it visible.
Note that the X11 version of Qt may not be able to deliver all combinations of style flags on all systems. This is because on X11, Qt can only ask the window manager, and the window manager can override the application's settings. On Windows, Qt can set whatever flags you want.
See also windowFlags.
[slot] bool QWidget::close()
Closes this widget. Returns true if the widget was closed; otherwise returns false.
First it sends the widget a QCloseEvent. The widget is hidden if it accepts the close event. If it ignores the event, nothing happens. The default implementation of QWidget::closeEvent() accepts the close event.
If the widget has the Qt::WA_DeleteOnClose flag, the widget is also deleted. A close events is delivered to the widget no matter if the widget is visible or not.
The QApplication::lastWindowClosed() signal is emitted when the last visible primary window (i.e. window with no parent) with the Qt::WA_QuitOnClose attribute set is closed. By default this attribute is set for all widgets except transient windows such as splash screens, tool windows, and popup menus.
[signal] void QWidget::customContextMenuRequested(const QPoint &pos)
This signal is emitted when the widget's contextMenuPolicy is Qt::CustomContextMenu, and the user has requested a context menu on the widget. The position pos is the position of the context menu event that the widget receives. Normally this is in widget coordinates. The exception to this rule is QAbstractScrollArea and its subclasses that map the context menu event to coordinates of the viewport().
See also mapToGlobal(), QMenu, and contextMenuPolicy.
[slot] void QWidget::hide()
Hides the widget. This function is equivalent to setVisible(false).
Note: If you are working with QDialog or its subclasses and you invoke the show() function after this function, the dialog will be displayed in its original position.
See also hideEvent(), isHidden(), show(), setVisible(), isVisible(), and close().
[slot] void QWidget::lower()
Lowers the widget to the bottom of the parent widget's stack.
After this call the widget will be visually behind (and therefore obscured by) any overlapping sibling widgets.
See also raise() and stackUnder().
[slot] void QWidget::raise()
Raises this widget to the top of the parent widget's stack.
After this call the widget will be visually in front of any overlapping sibling widgets.
Note: When using activateWindow(), you can call this function to ensure that the window is stacked on top.
See also lower() and stackUnder().
[slot] void QWidget::repaint()
Repaints the widget directly by calling paintEvent() immediately, unless updates are disabled or the widget is hidden.
We suggest only using repaint() if you need an immediate repaint, for example during animation. In almost all circumstances update() is better, as it permits Qt to optimize for speed and minimize flicker.
Warning: If you call repaint() in a function which may itself be called from paintEvent(), you may get infinite recursion. The update() function never causes recursion.
See also update(), paintEvent(), and setUpdatesEnabled().
[slot] void QWidget::setDisabled(bool disable)
Disables widget input events if disable is true; otherwise enables input events.
See the enabled documentation for more information.
See also isEnabledTo(), QKeyEvent, QMouseEvent, and changeEvent().
[slot] void QWidget::setFocus()
This is an overloaded function.
Gives the keyboard input focus to this widget (or its focus proxy) if this widget or one of its parents is the active window.
[slot] void QWidget::setHidden(bool hidden)
Convenience function, equivalent to setVisible(!hidden).
See also isHidden().
[slot] void QWidget::show()
Shows the widget and its child widgets.
This is equivalent to calling showFullScreen(), showMaximized(), or setVisible(true), depending on the platform's default behavior for the window flags.
See also raise(), showEvent(), hide(), setVisible(), showMinimized(), showMaximized(), showNormal(), isVisible(), and windowFlags().
[slot] void QWidget::showFullScreen()
Shows the widget in full-screen mode.
Calling this function only affects windows.
To return from full-screen mode, call showNormal().
Full-screen mode works fine under Windows, but has certain problems under X. These problems are due to limitations of the ICCCM protocol that specifies the communication between X11 clients and the window manager. ICCCM simply does not understand the concept of non-decorated full-screen windows. Therefore, the best we can do is to request a borderless window and place and resize it to fill the entire screen. Depending on the window manager, this may or may not work. The borderless window is requested using MOTIF hints, which are at least partially supported by virtually all modern window managers.
An alternative would be to bypass the window manager entirely and create a window with the Qt::X11BypassWindowManagerHint flag. This has other severe problems though, like totally broken keyboard focus and very strange effects on desktop changes or when the user raises other windows.
X11 window managers that follow modern post-ICCCM specifications support full-screen mode properly.
See also showNormal(), showMaximized(), show(), hide(), and isVisible().
[slot] void QWidget::showMaximized()
Shows the widget maximized.
Calling this function only affects windows.
On X11, this function may not work properly with certain window managers. See the Window Geometry documentation for an explanation.
See also setWindowState(), showNormal(), showMinimized(), show(), hide(), and isVisible().
[slot] void QWidget::showMinimized()
Shows the widget minimized, as an icon.
Calling this function only affects windows.
See also showNormal(), showMaximized(), show(), hide(), isVisible(), and isMinimized().
[slot] void QWidget::showNormal()
Restores the widget after it has been maximized or minimized.
Calling this function only affects windows.
See also setWindowState(), showMinimized(), showMaximized(), show(), hide(), and isVisible().
[slot] void QWidget::update()
Updates the widget unless updates are disabled or the widget is hidden.
This function does not cause an immediate repaint; instead it schedules a paint event for processing when Qt returns to the main event loop. This permits Qt to optimize for more speed and less flicker than a call to repaint() does.
Calling update() several times normally results in just one paintEvent() call.
Qt normally erases the widget's area before the paintEvent() call. If the Qt::WA_OpaquePaintEvent widget attribute is set, the widget is responsible for painting all its pixels with an opaque color.
See also repaint(), paintEvent(), setUpdatesEnabled(), and Analog Clock Example.
[protected slot] void QWidget::updateMicroFocus()
Updates the widget's micro focus.
[signal] void QWidget::windowIconChanged(const QIcon &icon)
This signal is emitted when the window's icon has changed, with the new icon as an argument.
Note: Notifier signal for property windowIcon. 
This function was introduced in Qt 5.2.
[signal] void QWidget::windowTitleChanged(const QString &title)
This signal is emitted when the window's title has changed, with the new title as an argument.
Note: Notifier signal for property windowTitle. 
This function was introduced in Qt 5.2.
[virtual] QWidget::~QWidget()
Destroys the widget.
All this widget's children are deleted first. The application exits if this widget is the main widget.
[virtual protected] void QWidget::actionEvent(QActionEvent *event)
This event handler is called with the given event whenever the widget's actions are changed.
See also addAction(), insertAction(), removeAction(), actions(), and QActionEvent.
QList<QAction *> QWidget::actions() const
Returns the (possibly empty) list of this widget's actions.
See also contextMenuPolicy, insertAction(), and removeAction().
void QWidget::activateWindow()
Sets the top-level widget containing this widget to be the active window.
An active window is a visible top-level window that has the keyboard input focus.
This function performs the same operation as clicking the mouse on the title bar of a top-level window. On X11, the result depends on the Window Manager. If you want to ensure that the window is stacked on top as well you should also call raise(). Note that the window must be visible, otherwise activateWindow() has no effect.
On Windows, if you are calling this when the application is not currently the active one then it will not make it the active window. It will change the color of the taskbar entry to indicate that the window has changed in some way. This is because Microsoft does not allow an application to interrupt what the user is currently doing in another application.
See also isActiveWindow(), window(), show(), and QWindowsWindowFunctions::setWindowActivationBehavior().
void QWidget::addAction(QAction *action)
Appends the action action to this widget's list of actions.
All QWidgets have a list of QActions, however they can be represented graphically in many different ways. The default use of the QAction list (as returned by actions()) is to create a context QMenu.
A QWidget should only have one of each action and adding an action it already has will not cause the same action to be in the widget twice.
The ownership of action is not transferred to this QWidget.
See also removeAction(), insertAction(), actions(), and QMenu.
void QWidget::addActions(QList<QAction *> actions)
Appends the actions actions to this widget's list of actions.
See also removeAction(), QMenu, and addAction().
void QWidget::adjustSize()
Adjusts the size of the widget to fit its contents.
This function uses sizeHint() if it is valid, i.e., the size hint's width and height are >= 0. Otherwise, it sets the size to the children rectangle that covers all child widgets (the union of all child widget rectangles).
For windows, the screen size is also taken into account. If the sizeHint() is less than (200, 100) and the size policy is expanding, the window will be at least (200, 100). The maximum size of a window is 2/3 of the screen's width and height.
See also sizeHint() and childrenRect().
QPalette::ColorRole QWidget::backgroundRole() const
Returns the background role of the widget.
The background role defines the brush from the widget's palette that is used to render the background.
If no explicit background role is set, the widget inherts its parent widget's background role.
See also setBackgroundRole() and foregroundRole().
QBackingStore *QWidget::backingStore() const
Returns the QBackingStore this widget will be drawn into.
This function was introduced in Qt 5.0.
[virtual protected] void QWidget::changeEvent(QEvent *event)
This event handler can be reimplemented to handle state changes.
The state being changed in this event can be retrieved through the event supplied.
Change events include: QEvent::ToolBarChange, QEvent::ActivationChange, QEvent::EnabledChange, QEvent::FontChange, QEvent::StyleChange, QEvent::PaletteChange, QEvent::WindowTitleChange, QEvent::IconTextChange, QEvent::ModifiedChange, QEvent::MouseTrackingChange, QEvent::ParentChange, QEvent::WindowStateChange, QEvent::LanguageChange, QEvent::LocaleChange, QEvent::LayoutDirectionChange, QEvent::ReadOnlyChange.
QWidget *QWidget::childAt(int x, int y) const
Returns the visible child widget at the position (x, y) in the widget's coordinate system. If there is no visible child widget at the specified position, the function returns nullptr.
QWidget *QWidget::childAt(const QPoint &p) const
This is an overloaded function.
Returns the visible child widget at point p in the widget's own coordinate system.
void QWidget::clearFocus()
Takes keyboard input focus from the widget.
If the widget has active focus, a focus out event is sent to this widget to tell it that it has lost the focus.
This widget must enable focus setting in order to get the keyboard input focus, i.e. it must call setFocusPolicy().
See also hasFocus(), setFocus(), focusInEvent(), focusOutEvent(), setFocusPolicy(), and QApplication::focusWidget().
void QWidget::clearMask()
Removes any mask set by setMask().
See also setMask().
[virtual protected] void QWidget::closeEvent(QCloseEvent *event)
This event handler is called with the given event when Qt receives a window close request for a top-level widget from the window system.
By default, the event is accepted and the widget is closed. You can reimplement this function to change the way the widget responds to window close requests. For example, you can prevent the window from closing by calling ignore() on all events.
Main window applications typically use reimplementations of this function to check whether the user's work has been saved and ask for permission before closing. For example, the Application Example uses a helper function to determine whether or not to close the window:
 void MainWindow::closeEvent(QCloseEvent *event)
 {
     if (maybeSave()) {
         writeSettings();
         event->accept();
     } else {
         event->ignore();
     }
 }
See also event(), hide(), close(), QCloseEvent, and Application Example.
QMargins QWidget::contentsMargins() const
The contentsMargins function returns the widget's contents margins.
This function was introduced in Qt 4.6.
See also setContentsMargins() and contentsRect().
QRect QWidget::contentsRect() const
Returns the area inside the widget's margins.
See also setContentsMargins() and contentsMargins().
[virtual protected] void QWidget::contextMenuEvent(QContextMenuEvent *event)
This event handler, for event event, can be reimplemented in a subclass to receive widget context menu events.
The handler is called when the widget's contextMenuPolicy is Qt::DefaultContextMenu.
The default implementation ignores the context event. See the QContextMenuEvent documentation for more details.
See also event(), QContextMenuEvent, and customContextMenuRequested().
[protected] void QWidget::create(WId window = 0, bool initializeWindow = true, bool destroyOldWindow = true)
Creates a new widget window.
The parameters window, initializeWindow, and destroyOldWindow are ignored in Qt 5. Please use QWindow::fromWinId() to create a QWindow wrapping a foreign window and pass it to QWidget::createWindowContainer() instead.
See also createWindowContainer() and QWindow::fromWinId().
[static] QWidget *QWidget::createWindowContainer(QWindow *window, QWidget *parent = nullptr, Qt::WindowFlags flags = Qt::WindowFlags())
Creates a QWidget that makes it possible to embed window into a QWidget-based application.
The window container is created as a child of parent and with window flags flags.
Once the window has been embedded into the container, the container will control the window's geometry and visibility. Explicit calls to QWindow::setGeometry(), QWindow::show() or QWindow::hide() on an embedded window is not recommended.
The container takes over ownership of window. The window can be removed from the window container with a call to QWindow::setParent().
The window container is attached as a native child window to the toplevel window it is a child of. When a window container is used as a child of a QAbstractScrollArea or QMdiArea, it will create a native window for every widget in its parent chain to allow for proper stacking and clipping in this use case. Creating a native window for the window container also allows for proper stacking and clipping. This must be done before showing the window container. Applications with many native child windows may suffer from performance issues.
The window container has a number of known limitations:
Stacking order; The embedded window will stack on top of the widget hierarchy as an opaque box. The stacking order of multiple overlapping window container instances is undefined.
Rendering Integration; The window container does not interoperate with QGraphicsProxyWidget, QWidget::render() or similar functionality.
Focus Handling; It is possible to let the window container instance have any focus policy and it will delegate focus to the window via a call to QWindow::requestActivate(). However, returning to the normal focus chain from the QWindow instance will be up to the QWindow instance implementation itself. For instance, when entering a Qt Quick based window with tab focus, it is quite likely that further tab presses will only cycle inside the QML application. Also, whether QWindow::requestActivate() actually gives the window focus, is platform dependent.
Using many window container instances in a QWidget-based application can greatly hurt the overall performance of the application.
[protected] void QWidget::destroy(bool destroyWindow = true, bool destroySubWindows = true)
Frees up window system resources. Destroys the widget window if destroyWindow is true.
destroy() calls itself recursively for all the child widgets, passing destroySubWindows for the destroyWindow parameter. To have more control over destruction of subwidgets, destroy subwidgets selectively first.
This function is usually called from the QWidget destructor.
[virtual protected] void QWidget::dragEnterEvent(QDragEnterEvent *event)
This event handler is called when a drag is in progress and the mouse enters this widget. The event is passed in the event parameter.
If the event is ignored, the widget won't receive any drag move events.
See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.
See also QDrag and QDragEnterEvent.
[virtual protected] void QWidget::dragLeaveEvent(QDragLeaveEvent *event)
This event handler is called when a drag is in progress and the mouse leaves this widget. The event is passed in the event parameter.
See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.
See also QDrag and QDragLeaveEvent.
[virtual protected] void QWidget::dragMoveEvent(QDragMoveEvent *event)
This event handler is called if a drag is in progress, and when any of the following conditions occur: the cursor enters this widget, the cursor moves within this widget, or a modifier key is pressed on the keyboard while this widget has the focus. The event is passed in the event parameter.
See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.
See also QDrag and QDragMoveEvent.
[virtual protected] void QWidget::dropEvent(QDropEvent *event)
This event handler is called when the drag is dropped on this widget. The event is passed in the event parameter.
See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.
See also QDrag and QDropEvent.
WId QWidget::effectiveWinId() const
Returns the effective window system identifier of the widget, i.e. the native parent's window system identifier.
If the widget is native, this function returns the native widget ID. Otherwise, the window ID of the first native parent widget, i.e., the top-level widget that contains this widget, is returned.
Note: We recommend that you do not store this value as it is likely to change at run-time.
This function was introduced in Qt 4.4.
See also nativeParentWidget().
void QWidget::ensurePolished() const
Ensures that the widget and its children have been polished by QStyle (i.e., have a proper font and palette).
QWidget calls this function after it has been fully constructed but before it is shown the very first time. You can call this function if you want to ensure that the widget is polished before doing an operation, e.g., the correct font size might be needed in the widget's sizeHint() reimplementation. Note that this function is called from the default implementation of sizeHint().
Polishing is useful for final initialization that must happen after all constructors (from base classes as well as from subclasses) have been called.
If you need to change some settings when a widget is polished, reimplement event() and handle the QEvent::Polish event type.
Note: The function is declared const so that it can be called from other const functions (e.g., sizeHint()).
See also event().
[virtual protected] void QWidget::enterEvent(QEvent *event)
This event handler can be reimplemented in a subclass to receive widget enter events which are passed in the event parameter.
An event is sent to the widget when the mouse cursor enters the widget.
See also leaveEvent(), mouseMoveEvent(), and event().
[override virtual protected] bool QWidget::event(QEvent *event)
Reimplements: QObject::event(QEvent *e).
This is the main event handler; it handles event event. You can reimplement this function in a subclass, but we recommend using one of the specialized event handlers instead.
Key press and release events are treated differently from other events. event() checks for Tab and Shift+Tab and tries to move the focus appropriately. If there is no widget to move the focus to (or the key press is not Tab or Shift+Tab), event() calls keyPressEvent().
Mouse and tablet event handling is also slightly special: only when the widget is enabled, event() will call the specialized handlers such as mousePressEvent(); otherwise it will discard the event.
This function returns true if the event was recognized, otherwise it returns false. If the recognized event was accepted (see QEvent::accepted), any further processing such as event propagation to the parent widget stops.
See also closeEvent(), focusInEvent(), focusOutEvent(), enterEvent(), keyPressEvent(), keyReleaseEvent(), leaveEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), mousePressEvent(), mouseReleaseEvent(), moveEvent(), paintEvent(), resizeEvent(), QObject::event(), and QObject::timerEvent().
[static] QWidget *QWidget::find(WId id)
Returns a pointer to the widget with window identifer/handle id.
The window identifier type depends on the underlying window system, see qwindowdefs.h for the actual definition. If there is no widget with this identifier, nullptr is returned.
[virtual protected] void QWidget::focusInEvent(QFocusEvent *event)
This event handler can be reimplemented in a subclass to receive keyboard focus events (focus received) for the widget. The event is passed in the event parameter
A widget normally must setFocusPolicy() to something other than Qt::NoFocus in order to receive focus events. (Note that the application programmer can call setFocus() on any widget, even those that do not normally accept focus.)
The default implementation updates the widget (except for windows that do not specify a focusPolicy()).
See also focusOutEvent(), setFocusPolicy(), keyPressEvent(), keyReleaseEvent(), event(), and QFocusEvent.
[protected] bool QWidget::focusNextChild()
Finds a new widget to give the keyboard focus to, as appropriate for Tab, and returns true if it can find a new widget, or false if it can't.
See also focusPreviousChild().
[virtual protected] bool QWidget::focusNextPrevChild(bool next)
Finds a new widget to give the keyboard focus to, as appropriate for Tab and Shift+Tab, and returns true if it can find a new widget, or false if it can't.
If next is true, this function searches forward, if next is false, it searches backward.
Sometimes, you will want to reimplement this function. For example, a web browser might reimplement it to move its "current active link" forward or backward, and call focusNextPrevChild() only when it reaches the last or first link on the "page".
Child widgets call focusNextPrevChild() on their parent widgets, but only the window that contains the child widgets decides where to redirect focus. By reimplementing this function for an object, you thus gain control of focus traversal for all child widgets.
See also focusNextChild() and focusPreviousChild().
[virtual protected] void QWidget::focusOutEvent(QFocusEvent *event)
This event handler can be reimplemented in a subclass to receive keyboard focus events (focus lost) for the widget. The events is passed in the event parameter.
A widget normally must setFocusPolicy() to something other than Qt::NoFocus in order to receive focus events. (Note that the application programmer can call setFocus() on any widget, even those that do not normally accept focus.)
The default implementation updates the widget (except for windows that do not specify a focusPolicy()).
See also focusInEvent(), setFocusPolicy(), keyPressEvent(), keyReleaseEvent(), event(), and QFocusEvent.
[protected] bool QWidget::focusPreviousChild()
Finds a new widget to give the keyboard focus to, as appropriate for Shift+Tab, and returns true if it can find a new widget, or false if it can't.
See also focusNextChild().
QWidget *QWidget::focusProxy() const
Returns the focus proxy, or nullptr if there is no focus proxy.
See also setFocusProxy().
QWidget *QWidget::focusWidget() const
Returns the last child of this widget that setFocus had been called on. For top level widgets this is the widget that will get focus in case this window gets activated
This is not the same as QApplication::focusWidget(), which returns the focus widget in the currently active window.
QFontInfo QWidget::fontInfo() const
Returns the font info for the widget's current font. Equivalent to QFontInfo(widget->font()).
See also font(), fontMetrics(), and setFont().
QFontMetrics QWidget::fontMetrics() const
Returns the font metrics for the widget's current font. Equivalent to QFontMetrics(widget->font()).
See also font(), fontInfo(), and setFont().
QPalette::ColorRole QWidget::foregroundRole() const
Returns the foreground role.
The foreground role defines the color from the widget's palette that is used to draw the foreground.
If no explicit foreground role is set, the function returns a role that contrasts with the background role.
See also setForegroundRole() and backgroundRole().
QPixmap QWidget::grab(const QRect &rectangle = QRect(QPoint(0, 0), QSize(-1, -1)))
Renders the widget into a pixmap restricted by the given rectangle. If the widget has any children, then they are also painted in the appropriate positions.
If a rectangle with an invalid size is specified (the default), the entire widget is painted.
Note: This function can be invoked via the meta-object system and from QML. See Q_INVOKABLE.
This function was introduced in Qt 5.0.
See also render() and QPixmap.
void QWidget::grabGesture(Qt::GestureType gesture, Qt::GestureFlags flags = Qt::GestureFlags())
Subscribes the widget to a given gesture with specific flags.
This function was introduced in Qt 4.6.
See also ungrabGesture() and QGestureEvent.
void QWidget::grabKeyboard()
Grabs the keyboard input.
This widget receives all keyboard events until releaseKeyboard() is called; other widgets get no keyboard events at all. Mouse events are not affected. Use grabMouse() if you want to grab that.
The focus widget is not affected, except that it doesn't receive any keyboard events. setFocus() moves the focus as usual, but the new focus widget receives keyboard events only after releaseKeyboard() is called.
If a different widget is currently grabbing keyboard input, that widget's grab is released first.
See also releaseKeyboard(), grabMouse(), releaseMouse(), and focusWidget().
void QWidget::grabMouse()
Grabs the mouse input.
This widget receives all mouse events until releaseMouse() is called; other widgets get no mouse events at all. Keyboard events are not affected. Use grabKeyboard() if you want to grab that.
Warning: Bugs in mouse-grabbing applications very often lock the terminal. Use this function with extreme caution, and consider using the -nograb command line option while debugging.
It is almost never necessary to grab the mouse when using Qt, as Qt grabs and releases it sensibly. In particular, Qt grabs the mouse when a mouse button is pressed and keeps it until the last button is released.
Note: Only visible widgets can grab mouse input. If isVisible() returns false for a widget, that widget cannot call grabMouse().
Note: On Windows, grabMouse() only works when the mouse is inside a window owned by the process. On macOS, grabMouse() only works when the mouse is inside the frame of that widget.
See also releaseMouse(), grabKeyboard(), and releaseKeyboard().
void QWidget::grabMouse(const QCursor &cursor)
This function overloads grabMouse().
Grabs the mouse input and changes the cursor shape.
The cursor will assume shape cursor (for as long as the mouse focus is grabbed) and this widget will be the only one to receive mouse events until releaseMouse() is called().
Warning: Grabbing the mouse might lock the terminal.
Note: See the note in QWidget::grabMouse().
See also releaseMouse(), grabKeyboard(), releaseKeyboard(), and setCursor().
int QWidget::grabShortcut(const QKeySequence &key, Qt::ShortcutContext context = Qt::WindowShortcut)
Adds a shortcut to Qt's shortcut system that watches for the given key sequence in the given context. If the context is Qt::ApplicationShortcut, the shortcut applies to the application as a whole. Otherwise, it is either local to this widget, Qt::WidgetShortcut, or to the window itself, Qt::WindowShortcut.
If the same key sequence has been grabbed by several widgets, when the key sequence occurs a QEvent::Shortcut event is sent to all the widgets to which it applies in a non-deterministic order, but with the ``ambiguous'' flag set to true.
Warning: You should not normally need to use this function; instead create QActions with the shortcut key sequences you require (if you also want equivalent menu options and toolbar buttons), or create QShortcuts if you just need key sequences. Both QAction and QShortcut handle all the event filtering for you, and provide signals which are triggered when the user triggers the key sequence, so are much easier to use than this low-level function.
See also releaseShortcut() and setShortcutEnabled().
QGraphicsEffect *QWidget::graphicsEffect() const
The graphicsEffect function returns a pointer to the widget's graphics effect.
If the widget has no graphics effect, nullptr is returned.
This function was introduced in Qt 4.6.
See also setGraphicsEffect().
QGraphicsProxyWidget *QWidget::graphicsProxyWidget() const
Returns the proxy widget for the corresponding embedded widget in a graphics view; otherwise returns nullptr.
This function was introduced in Qt 4.5.
See also QGraphicsProxyWidget::createProxyForChildWidget() and QGraphicsScene::addWidget().
bool QWidget::hasEditFocus() const
Returns true if this widget currently has edit focus; otherwise false.
This feature is only available in Qt for Embedded Linux.
See also setEditFocus() and QApplication::navigationMode().
[virtual] bool QWidget::hasHeightForWidth() const
Returns true if the widget's preferred height depends on its width; otherwise returns false.
This function was introduced in Qt 5.0.
[virtual] int QWidget::heightForWidth(int w) const
Returns the preferred height for this widget, given the width w.
If this widget has a layout, the default implementation returns the layout's preferred height. if there is no layout, the default implementation returns -1 indicating that the preferred height does not depend on the width.
[virtual protected] void QWidget::hideEvent(QHideEvent *event)
This event handler can be reimplemented in a subclass to receive widget hide events. The event is passed in the event parameter.
Hide events are sent to widgets immediately after they have been hidden.
Note: A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g. a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again. After receiving a spontaneous hide event, a widget is still considered visible in the sense of isVisible().
See also visible, event(), and QHideEvent.
[override virtual protected] void QWidget::initPainter(QPainter *painter) const
Initializes the painter pen, background and font to the same as the given widget's. This function is called automatically when the painter is opened on a QWidget.
[virtual protected] void QWidget::inputMethodEvent(QInputMethodEvent *event)
This event handler, for event event, can be reimplemented in a subclass to receive Input Method composition events. This handler is called when the state of the input method changes.
Note that when creating custom text editing widgets, the Qt::WA_InputMethodEnabled window attribute must be set explicitly (using the setAttribute() function) in order to receive input method events.
The default implementation calls event->ignore(), which rejects the Input Method event. See the QInputMethodEvent documentation for more details.
See also event() and QInputMethodEvent.
[virtual] QVariant QWidget::inputMethodQuery(Qt::InputMethodQuery query) const
This method is only relevant for input widgets. It is used by the input method to query a set of properties of the widget to be able to support complex input method operations as support for surrounding text and reconversions.
query specifies which property is queried.
See also inputMethodEvent(), QInputMethodEvent, QInputMethodQueryEvent, and inputMethodHints.
void QWidget::insertAction(QAction *before, QAction *action)
Inserts the action action to this widget's list of actions, before the action before. It appends the action if before is nullptr or before is not a valid action for this widget.
A QWidget should only have one of each action.
See also removeAction(), addAction(), QMenu, contextMenuPolicy, and actions().
void QWidget::insertActions(QAction *before, QList<QAction *> actions)
Inserts the actions actions to this widget's list of actions, before the action before. It appends the action if before is nullptr or before is not a valid action for this widget.
A QWidget can have at most one of each action.
See also removeAction(), QMenu, insertAction(), and contextMenuPolicy.
bool QWidget::isAncestorOf(const QWidget *child) const
Returns true if this widget is a parent, (or grandparent and so on to any level), of the given child, and both widgets are within the same window; otherwise returns false.
bool QWidget::isEnabledTo(const QWidget *ancestor) const
Returns true if this widget would become enabled if ancestor is enabled; otherwise returns false.
This is the case if neither the widget itself nor every parent up to but excluding ancestor has been explicitly disabled.
isEnabledTo(0) returns false if this widget or any if its ancestors was explicitly disabled.
The word ancestor here means a parent widget within the same window.
Therefore isEnabledTo(0) stops at this widget's window, unlike isEnabled() which also takes parent windows into considerations.
See also setEnabled() and enabled.
bool QWidget::isHidden() const
Returns true if the widget is hidden, otherwise returns false.
A hidden widget will only become visible when show() is called on it. It will not be automatically shown when the parent is shown.
To check visibility, use !isVisible() instead (notice the exclamation mark).
isHidden() implies !isVisible(), but a widget can be not visible and not hidden at the same time. This is the case for widgets that are children of widgets that are not visible.
Widgets are hidden if:
they were created as independent windows,
they were created as children of visible widgets,
hide() or setVisible(false) was called.
bool QWidget::isVisibleTo(const QWidget *ancestor) const
Returns true if this widget would become visible if ancestor is shown; otherwise returns false.
The true case occurs if neither the widget itself nor any parent up to but excluding ancestor has been explicitly hidden.
This function will still return true if the widget is obscured by other windows on the screen, but could be physically visible if it or they were to be moved.
isVisibleTo(0) is identical to isVisible().
See also show(), hide(), and isVisible().
bool QWidget::isWindow() const
Returns true if the widget is an independent window, otherwise returns false.
A window is a widget that isn't visually the child of any other widget and that usually has a frame and a window title.
A window can have a parent widget. It will then be grouped with its parent and deleted when the parent is deleted, minimized when the parent is minimized etc. If supported by the window manager, it will also have a common taskbar entry with its parent.
QDialog and QMainWindow widgets are by default windows, even if a parent widget is specified in the constructor. This behavior is specified by the Qt::Window flag.
See also window(), isModal(), and parentWidget().
[virtual protected] void QWidget::keyPressEvent(QKeyEvent *event)
This event handler, for event event, can be reimplemented in a subclass to receive key press events for the widget.
A widget must call setFocusPolicy() to accept focus initially and have focus in order to receive a key press event.
If you reimplement this handler, it is very important that you call the base class implementation if you do not act upon the key.
The default implementation closes popup widgets if the user presses the key sequence for QKeySequence::Cancel (typically the Escape key). Otherwise the event is ignored, so that the widget's parent can interpret it.
Note that QKeyEvent starts with isAccepted() == true, so you do not need to call QKeyEvent::accept() - just do not call the base class implementation if you act upon the key.
See also keyReleaseEvent(), setFocusPolicy(), focusInEvent(), focusOutEvent(), event(), QKeyEvent, and Tetrix Example.
[virtual protected] void QWidget::keyReleaseEvent(QKeyEvent *event)
This event handler, for event event, can be reimplemented in a subclass to receive key release events for the widget.
A widget must accept focus initially and have focus in order to receive a key release event.
If you reimplement this handler, it is very important that you call the base class implementation if you do not act upon the key.
The default implementation ignores the event, so that the widget's parent can interpret it.
Note that QKeyEvent starts with isAccepted() == true, so you do not need to call QKeyEvent::accept() - just do not call the base class implementation if you act upon the key.
See also keyPressEvent(), QEvent::ignore(), setFocusPolicy(), focusInEvent(), focusOutEvent(), event(), and QKeyEvent.
[static] QWidget *QWidget::keyboardGrabber()
Returns the widget that is currently grabbing the keyboard input.
If no widget in this application is currently grabbing the keyboard, nullptr is returned.
See also grabMouse() and mouseGrabber().
QLayout *QWidget::layout() const
Returns the layout manager that is installed on this widget, or nullptr if no layout manager is installed.
The layout manager sets the geometry of the widget's children that have been added to the layout.
See also setLayout(), sizePolicy(), and Layout Management.
[virtual protected] void QWidget::leaveEvent(QEvent *event)
This event handler can be reimplemented in a subclass to receive widget leave events which are passed in the event parameter.
A leave event is sent to the widget when the mouse cursor leaves the widget.
See also enterEvent(), mouseMoveEvent(), and event().
QPoint QWidget::mapFrom(const QWidget *parent, const QPoint &pos) const
Translates the widget coordinate pos from the coordinate system of parent to this widget's coordinate system. The parent must not be nullptr and must be a parent of the calling widget.
See also mapTo(), mapFromParent(), mapFromGlobal(), and underMouse().
QPoint QWidget::mapFromGlobal(const QPoint &pos) const
Translates the global screen coordinate pos to widget coordinates.
See also mapToGlobal(), mapFrom(), and mapFromParent().
QPoint QWidget::mapFromParent(const QPoint &pos) const
Translates the parent widget coordinate pos to widget coordinates.
Same as mapFromGlobal() if the widget has no parent.
See also mapToParent(), mapFrom(), mapFromGlobal(), and underMouse().
QPoint QWidget::mapTo(const QWidget *parent, const QPoint &pos) const
Translates the widget coordinate pos to the coordinate system of parent. The parent must not be nullptr and must be a parent of the calling widget.
See also mapFrom(), mapToParent(), mapToGlobal(), and underMouse().
QPoint QWidget::mapToGlobal(const QPoint &pos) const
Translates the widget coordinate pos to global screen coordinates. For example, mapToGlobal(QPoint(0,0)) would give the global coordinates of the top-left pixel of the widget.
See also mapFromGlobal(), mapTo(), and mapToParent().
QPoint QWidget::mapToParent(const QPoint &pos) const
Translates the widget coordinate pos to a coordinate in the parent widget.
Same as mapToGlobal() if the widget has no parent.
See also mapFromParent(), mapTo(), mapToGlobal(), and underMouse().
QRegion QWidget::mask() const
Returns the mask currently set on a widget. If no mask is set the return value will be an empty region.
See also setMask(), clearMask(), QRegion::isEmpty(), and Shaped Clock Example.
[override virtual protected] int QWidget::metric(QPaintDevice::PaintDeviceMetric m) const
Reimplements: QPaintDevice::metric(QPaintDevice::PaintDeviceMetric metric) const.
Internal implementation of the virtual QPaintDevice::metric() function.
m is the metric to get.
[virtual protected] void QWidget::mouseDoubleClickEvent(QMouseEvent *event)
This event handler, for event event, can be reimplemented in a subclass to receive mouse double click events for the widget.
The default implementation calls mousePressEvent().
Note: The widget will also receive mouse press and mouse release events in addition to the double click event. And if another widget that overlaps this widget disappears in response to press or release events, then this widget will only receive the double click event. It is up to the developer to ensure that the application interprets these events correctly.
See also mousePressEvent(), mouseReleaseEvent(), mouseMoveEvent(), event(), and QMouseEvent.
[static] QWidget *QWidget::mouseGrabber()
Returns the widget that is currently grabbing the mouse input.
If no widget in this application is currently grabbing the mouse, nullptr is returned.
See also grabMouse() and keyboardGrabber().
[virtual protected] void QWidget::mouseMoveEvent(QMouseEvent *event)
This event handler, for event event, can be reimplemented in a subclass to receive mouse move events for the widget.
If mouse tracking is switched off, mouse move events only occur if a mouse button is pressed while the mouse is being moved. If mouse tracking is switched on, mouse move events occur even if no mouse button is pressed.
QMouseEvent::pos() reports the position of the mouse cursor, relative to this widget. For press and release events, the position is usually the same as the position of the last mouse move event, but it might be different if the user's hand shakes. This is a feature of the underlying window system, not Qt.
If you want to show a tooltip immediately, while the mouse is moving (e.g., to get the mouse coordinates with QMouseEvent::pos() and show them as a tooltip), you must first enable mouse tracking as described above. Then, to ensure that the tooltip is updated immediately, you must call QToolTip::showText() instead of setToolTip() in your implementation of mouseMoveEvent().
See also setMouseTracking(), mousePressEvent(), mouseReleaseEvent(), mouseDoubleClickEvent(), event(), QMouseEvent, and Scribble Example.
[virtual protected] void QWidget::mousePressEvent(QMouseEvent *event)
This event handler, for event event, can be reimplemented in a subclass to receive mouse press events for the widget.
If you create new widgets in the mousePressEvent() the mouseReleaseEvent() may not end up where you expect, depending on the underlying window system (or X11 window manager), the widgets' location and maybe more.
The default implementation implements the closing of popup widgets when you click outside the window. For other widget types it does nothing.
See also mouseReleaseEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), event(), QMouseEvent, and Scribble Example.
[virtual protected] void QWidget::mouseReleaseEvent(QMouseEvent *event)
This event handler, for event event, can be reimplemented in a subclass to receive mouse release events for the widget.
See also mousePressEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), event(), QMouseEvent, and Scribble Example.
void QWidget::move(int x, int y)
This is an overloaded function.
This corresponds to move(QPoint(x, y)).
Note: Setter function for property pos. 
[virtual protected] void QWidget::moveEvent(QMoveEvent *event)
This event handler can be reimplemented in a subclass to receive widget move events which are passed in the event parameter. When the widget receives this event, it is already at the new position.
The old position is accessible through QMoveEvent::oldPos().
See also resizeEvent(), event(), move(), and QMoveEvent.
[virtual protected] bool QWidget::nativeEvent(const QByteArray &eventType, void *message, long *result)
This special event handler can be reimplemented in a subclass to receive native platform events identified by eventType which are passed in the message parameter.
In your reimplementation of this function, if you want to stop the event being handled by Qt, return true and set result. The result parameter has meaning only on Windows. If you return false, this native event is passed back to Qt, which translates the event into a Qt event and sends it to the widget.
Note: Events are only delivered to this event handler if the widget has a native window handle.
Note: This function superseedes the event filter functions x11Event(), winEvent() and macEvent() of Qt 4.

Platform
Event Type Identifier
Message Type
Result Type
Windows
"windows_generic_MSG"
MSG *
LRESULT
macOS
"NSEvent"
NSEvent *

XCB
"xcb_generic_event_t"
xcb_generic_event_t *

See also QAbstractNativeEventFilter.
QWidget *QWidget::nativeParentWidget() const
Returns the native parent for this widget, i.e. the next ancestor widget that has a system identifier, or nullptr if it does not have any native parent.
This function was introduced in Qt 4.4.
See also effectiveWinId().
QWidget *QWidget::nextInFocusChain() const
Returns the next widget in this widget's focus chain.
See also previousInFocusChain().
void QWidget::overrideWindowFlags(Qt::WindowFlags flags)
Sets the window flags for the widget to flags, without telling the window system.
Warning: Do not call this function unless you really know what you're doing.
See also setWindowFlags().
[override virtual] QPaintEngine *QWidget::paintEngine() const
Reimplements: QPaintDevice::paintEngine() const.
Returns the widget's paint engine.
Note that this function should not be called explicitly by the user, since it's meant for reimplementation purposes only. The function is called by Qt internally, and the default implementation may not always return a valid pointer.
[virtual protected] void QWidget::paintEvent(QPaintEvent *event)
This event handler can be reimplemented in a subclass to receive paint events passed in event.
A paint event is a request to repaint all or part of a widget. It can happen for one of the following reasons:
repaint() or update() was invoked,
the widget was obscured and has now been uncovered, or
many other reasons.
Many widgets can simply repaint their entire surface when asked to, but some slow widgets need to optimize by painting only the requested region: QPaintEvent::region(). This speed optimization does not change the result, as painting is clipped to that region during event processing. QListView and QTableView do this, for example.
Qt also tries to speed up painting by merging multiple paint events into one. When update() is called several times or the window system sends several paint events, Qt merges these events into one event with a larger region (see QRegion::united()). The repaint() function does not permit this optimization, so we suggest using update() whenever possible.
When the paint event occurs, the update region has normally been erased, so you are painting on the widget's background.
The background can be set using setBackgroundRole() and setPalette().
Since Qt 4.0, QWidget automatically double-buffers its painting, so there is no need to write double-buffering code in paintEvent() to avoid flicker.
Note: Generally, you should refrain from calling update() or repaint() inside a paintEvent(). For example, calling update() or repaint() on children inside a paintEvent() results in undefined behavior; the child may or may not get a paint event.
Warning: If you are using a custom paint engine without Qt's backingstore, Qt::WA_PaintOnScreen must be set. Otherwise, QWidget::paintEngine() will never be called; the backingstore will be used instead.
See also event(), repaint(), update(), QPainter, QPixmap, QPaintEvent, and Analog Clock Example.
QWidget *QWidget::parentWidget() const
Returns the parent of this widget, or nullptr if it does not have any parent widget.
QWidget *QWidget::previousInFocusChain() const
The previousInFocusChain function returns the previous widget in this widget's focus chain.
This function was introduced in Qt 4.6.
See also nextInFocusChain().
void QWidget::releaseKeyboard()
Releases the keyboard grab.
See also grabKeyboard(), grabMouse(), and releaseMouse().
void QWidget::releaseMouse()
Releases the mouse grab.
See also grabMouse(), grabKeyboard(), and releaseKeyboard().
void QWidget::releaseShortcut(int id)
Removes the shortcut with the given id from Qt's shortcut system. The widget will no longer receive QEvent::Shortcut events for the shortcut's key sequence (unless it has other shortcuts with the same key sequence).
Warning: You should not normally need to use this function since Qt's shortcut system removes shortcuts automatically when their parent widget is destroyed. It is best to use QAction or QShortcut to handle shortcuts, since they are easier to use than this low-level function. Note also that this is an expensive operation.
See also grabShortcut() and setShortcutEnabled().
void QWidget::removeAction(QAction *action)
Removes the action action from this widget's list of actions.
See also insertAction(), actions(), and insertAction().
void QWidget::render(QPaintDevice *target, const QPoint &targetOffset = QPoint(), const QRegion &sourceRegion = QRegion(), QWidget::RenderFlags renderFlags = RenderFlags(DrawWindowBackground | DrawChildren))
Renders the sourceRegion of this widget into the target using renderFlags to determine how to render. Rendering starts at targetOffset in the target. For example:
 QPixmap pixmap(widget->size());
 widget->render(&pixmap);
If sourceRegion is a null region, this function will use QWidget::rect() as the region, i.e. the entire widget.
Ensure that you call QPainter::end() for the target device's active painter (if any) before rendering. For example:
 QPainter painter(this);
 ...
 painter.end();
 myWidget->render(this);
Note: To obtain the contents of a QOpenGLWidget, use QOpenGLWidget::grabFramebuffer() instead.
Note: To obtain the contents of a QGLWidget (deprecated), use QGLWidget::grabFrameBuffer() or QGLWidget::renderPixmap() instead.
This function was introduced in Qt 4.3.
void QWidget::render(QPainter *painter, const QPoint &targetOffset = QPoint(), const QRegion &sourceRegion = QRegion(), QWidget::RenderFlags renderFlags = RenderFlags(DrawWindowBackground | DrawChildren))
This is an overloaded function.
Renders the widget into the painter's QPainter::device().
Transformations and settings applied to the painter will be used when rendering.
Note: The painter must be active. On macOS the widget will be rendered into a QPixmap and then drawn by the painter.
See also QPainter::device().
void QWidget::repaint(int x, int y, int w, int h)
This is an overloaded function.
This version repaints a rectangle (x, y, w, h) inside the widget.
If w is negative, it is replaced with width() - x, and if h is negative, it is replaced width height() - y.
void QWidget::repaint(const QRect &rect)
This is an overloaded function.
This version repaints a rectangle rect inside the widget.
void QWidget::repaint(const QRegion &rgn)
This is an overloaded function.
This version repaints a region rgn inside the widget.
void QWidget::resize(int w, int h)
This is an overloaded function.
This corresponds to resize(QSize(w, h)).
Note: Setter function for property size. 
[virtual protected] void QWidget::resizeEvent(QResizeEvent *event)
This event handler can be reimplemented in a subclass to receive widget resize events which are passed in the event parameter. When resizeEvent() is called, the widget already has its new geometry. The old size is accessible through QResizeEvent::oldSize().
The widget will be erased and receive a paint event immediately after processing the resize event. No drawing need be (or should be) done inside this handler.
See also moveEvent(), event(), resize(), QResizeEvent, paintEvent(), and Scribble Example.
bool QWidget::restoreGeometry(const QByteArray &geometry)
Restores the geometry and state of top-level widgets stored in the byte array geometry. Returns true on success; otherwise returns false.
If the restored geometry is off-screen, it will be modified to be inside the available screen geometry.
To restore geometry saved using QSettings, you can use code like this:
 QSettings settings("MyCompany", "MyApp");
 myWidget->restoreGeometry(settings.value("myWidget/geometry").toByteArray());
See the Window Geometry documentation for an overview of geometry issues with windows.
Use QMainWindow::restoreState() to restore the geometry and the state of toolbars and dock widgets.
This function was introduced in Qt 4.2.
See also saveGeometry(), QSettings, QMainWindow::saveState(), and QMainWindow::restoreState().
QByteArray QWidget::saveGeometry() const
Saves the current geometry and state for top-level widgets.
To save the geometry when the window closes, you can implement a close event like this:
 void MyWidget::closeEvent(QCloseEvent *event)
 {
     QSettings settings("MyCompany", "MyApp");
     settings.setValue("geometry", saveGeometry());
     QWidget::closeEvent(event);
 }
See the Window Geometry documentation for an overview of geometry issues with windows.
Use QMainWindow::saveState() to save the geometry and the state of toolbars and dock widgets.
This function was introduced in Qt 4.2.
See also restoreGeometry(), QMainWindow::saveState(), and QMainWindow::restoreState().
QScreen *QWidget::screen() const
Returns the screen the widget is on.
This function was introduced in Qt 5.14.
See also windowHandle().
void QWidget::scroll(int dx, int dy)
Scrolls the widget including its children dx pixels to the right and dy downward. Both dx and dy may be negative.
After scrolling, the widgets will receive paint events for the areas that need to be repainted. For widgets that Qt knows to be opaque, this is only the newly exposed parts. For example, if an opaque widget is scrolled 8 pixels to the left, only an 8-pixel wide stripe at the right edge needs updating.
Since widgets propagate the contents of their parents by default, you need to set the autoFillBackground property, or use setAttribute() to set the Qt::WA_OpaquePaintEvent attribute, to make a widget opaque.
For widgets that use contents propagation, a scroll will cause an update of the entire scroll area.
See also Transparency and Double Buffering.
void QWidget::scroll(int dx, int dy, const QRect &r)
This is an overloaded function.
This version only scrolls r and does not move the children of the widget.
If r is empty or invalid, the result is undefined.
See also QScrollArea.
void QWidget::setAttribute(Qt::WidgetAttribute attribute, bool on = true)
Sets the attribute attribute on this widget if on is true; otherwise clears the attribute.
See also testAttribute().
void QWidget::setBackgroundRole(QPalette::ColorRole role)
Sets the background role of the widget to role.
The background role defines the brush from the widget's palette that is used to render the background.
If role is QPalette::NoRole, then the widget inherits its parent's background role.
Note that styles are free to choose any color from the palette. You can modify the palette or set a style sheet if you don't achieve the result you want with setBackgroundRole().
See also backgroundRole() and foregroundRole().
void QWidget::setBaseSize(int basew, int baseh)
This is an overloaded function.
This corresponds to setBaseSize(QSize(basew, baseh)). Sets the widgets base size to width basew and height baseh.
Note: Setter function for property baseSize. 
void QWidget::setContentsMargins(int left, int top, int right, int bottom)
Sets the margins around the contents of the widget to have the sizes left, top, right, and bottom. The margins are used by the layout system, and may be used by subclasses to specify the area to draw in (e.g. excluding the frame).
Changing the margins will trigger a resizeEvent().
See also contentsRect() and contentsMargins().
void QWidget::setContentsMargins(const QMargins &margins)
This is an overloaded function.
The setContentsMargins function sets the margins around the widget's contents.
Sets the margins around the contents of the widget to have the sizes determined by margins. The margins are used by the layout system, and may be used by subclasses to specify the area to draw in (e.g. excluding the frame).
Changing the margins will trigger a resizeEvent().
This function was introduced in Qt 4.6.
See also contentsRect() and contentsMargins().
void QWidget::setEditFocus(bool enable)
If enable is true, make this widget have edit focus, in which case Qt::Key_Up and Qt::Key_Down will be delivered to the widget normally; otherwise, Qt::Key_Up and Qt::Key_Down are used to change focus.
This feature is only available in Qt for Embedded Linux.
See also hasEditFocus() and QApplication::navigationMode().
void QWidget::setFixedHeight(int h)
Sets both the minimum and maximum heights of the widget to h without changing the widths. Provided for convenience.
See also sizeHint(), minimumSize(), maximumSize(), and setFixedSize().
void QWidget::setFixedSize(const QSize &s)
Sets both the minimum and maximum sizes of the widget to s, thereby preventing it from ever growing or shrinking.
This will override the default size constraints set by QLayout.
To remove constraints, set the size to QWIDGETSIZE_MAX.
Alternatively, if you want the widget to have a fixed size based on its contents, you can call QLayout::setSizeConstraint(QLayout::SetFixedSize);
See also maximumSize and minimumSize.
void QWidget::setFixedSize(int w, int h)
This is an overloaded function.
Sets the width of the widget to w and the height to h.
void QWidget::setFixedWidth(int w)
Sets both the minimum and maximum width of the widget to w without changing the heights. Provided for convenience.
See also sizeHint(), minimumSize(), maximumSize(), and setFixedSize().
void QWidget::setFocus(Qt::FocusReason reason)
Gives the keyboard input focus to this widget (or its focus proxy) if this widget or one of its parents is the active window. The reason argument will be passed into any focus event sent from this function, it is used to give an explanation of what caused the widget to get focus. If the window is not active, the widget will be given the focus when the window becomes active.
First, a focus about to change event is sent to the focus widget (if any) to tell it that it is about to lose the focus. Then focus is changed, a focus out event is sent to the previous focus item and a focus in event is sent to the new item to tell it that it just received the focus. (Nothing happens if the focus in and focus out widgets are the same.)
Note: On embedded platforms, setFocus() will not cause an input panel to be opened by the input method. If you want this to happen, you have to send a QEvent::RequestSoftwareInputPanel event to the widget yourself.
setFocus() gives focus to a widget regardless of its focus policy, but does not clear any keyboard grab (see grabKeyboard()).
Be aware that if the widget is hidden, it will not accept focus until it is shown.
Warning: If you call setFocus() in a function which may itself be called from focusOutEvent() or focusInEvent(), you may get an infinite recursion.
See also hasFocus(), clearFocus(), focusInEvent(), focusOutEvent(), setFocusPolicy(), focusWidget(), QApplication::focusWidget(), grabKeyboard(), grabMouse(), Keyboard Focus in Widgets, and QEvent::RequestSoftwareInputPanel.
void QWidget::setFocusProxy(QWidget *w)
Sets the widget's focus proxy to widget w. If w is nullptr, the function resets this widget to have no focus proxy.
Some widgets can "have focus", but create a child widget, such as QLineEdit, to actually handle the focus. In this case, the widget can set the line edit to be its focus proxy.
setFocusProxy() sets the widget which will actually get focus when "this widget" gets it. If there is a focus proxy, setFocus() and hasFocus() operate on the focus proxy. If "this widget" is the focus widget, then setFocusProxy() moves focus to the new focus proxy.
See also focusProxy().
void QWidget::setForegroundRole(QPalette::ColorRole role)
Sets the foreground role of the widget to role.
The foreground role defines the color from the widget's palette that is used to draw the foreground.
If role is QPalette::NoRole, the widget uses a foreground role that contrasts with the background role.
Note that styles are free to choose any color from the palette. You can modify the palette or set a style sheet if you don't achieve the result you want with setForegroundRole().
See also foregroundRole() and backgroundRole().
void QWidget::setGeometry(int x, int y, int w, int h)
This is an overloaded function.
This corresponds to setGeometry(QRect(x, y, w, h)).
Note: Setter function for property geometry. 
void QWidget::setGraphicsEffect(QGraphicsEffect *effect)
The setGraphicsEffect function is for setting the widget's graphics effect.
Sets effect as the widget's effect. If there already is an effect installed on this widget, QWidget will delete the existing effect before installing the new effect.
If effect is the installed effect on a different widget, setGraphicsEffect() will remove the effect from the widget and install it on this widget.
QWidget takes ownership of effect.
Note: This function will apply the effect on itself and all its children.
Note: Graphics effects are not supported for OpenGL-based widgets, such as QGLWidget, QOpenGLWidget and QQuickWidget.
This function was introduced in Qt 4.6.
See also graphicsEffect().
void QWidget::setLayout(QLayout *layout)
Sets the layout manager for this widget to layout.
If there already is a layout manager installed on this widget, QWidget won't let you install another. You must first delete the existing layout manager (returned by layout()) before you can call setLayout() with the new layout.
If layout is the layout manager on a different widget, setLayout() will reparent the layout and make it the layout manager for this widget.
Example:
     QVBoxLayout *layout = new QVBoxLayout;
     layout->addWidget(formWidget);
     setLayout(layout);
An alternative to calling this function is to pass this widget to the layout's constructor.
The QWidget will take ownership of layout.
See also layout() and Layout Management.
void QWidget::setMask(const QBitmap &bitmap)
Causes only the pixels of the widget for which bitmap has a corresponding 1 bit to be visible. If the region includes pixels outside the rect() of the widget, window system controls in that area may or may not be visible, depending on the platform.
Note that this effect can be slow if the region is particularly complex.
The following code shows how an image with an alpha channel can be used to generate a mask for a widget:
     QLabel topLevelLabel;
     QPixmap pixmap(":/images/tux.png");
     topLevelLabel.setPixmap(pixmap);
     topLevelLabel.setMask(pixmap.mask());
The label shown by this code is masked using the image it contains, giving the appearance that an irregularly-shaped image is being drawn directly onto the screen.
Masked widgets receive mouse events only on their visible portions.
See also mask(), clearMask(), windowOpacity(), and Shaped Clock Example.
void QWidget::setMask(const QRegion &region)
This is an overloaded function.
Causes only the parts of the widget which overlap region to be visible. If the region includes pixels outside the rect() of the widget, window system controls in that area may or may not be visible, depending on the platform.
Note that this effect can be slow if the region is particularly complex.
See also windowOpacity.
void QWidget::setMaximumSize(int maxw, int maxh)
This is an overloaded function.
This function corresponds to setMaximumSize(QSize(maxw, maxh)). Sets the maximum width to maxw and the maximum height to maxh.
Note: Setter function for property maximumSize. 
void QWidget::setMinimumSize(int minw, int minh)
This is an overloaded function.
This function corresponds to setMinimumSize(QSize(minw, minh)). Sets the minimum width to minw and the minimum height to minh.
Note: Setter function for property minimumSize. 
void QWidget::setParent(QWidget *parent)
Sets the parent of the widget to parent, and resets the window flags. The widget is moved to position (0, 0) in its new parent.
If the new parent widget is in a different window, the reparented widget and its children are appended to the end of the tab chain of the new parent widget, in the same internal order as before. If one of the moved widgets had keyboard focus, setParent() calls clearFocus() for that widget.
If the new parent widget is in the same window as the old parent, setting the parent doesn't change the tab order or keyboard focus.
If the "new" parent widget is the old parent widget, this function does nothing.
Note: The widget becomes invisible as part of changing its parent, even if it was previously visible. You must call show() to make the widget visible again.
Warning: It is very unlikely that you will ever need this function. If you have a widget that changes its content dynamically, it is far easier to use QStackedWidget.
See also setWindowFlags().
void QWidget::setParent(QWidget *parent, Qt::WindowFlags f)
This is an overloaded function.
This function also takes widget flags, f as an argument.
void QWidget::setShortcutAutoRepeat(int id, bool enable = true)
If enable is true, auto repeat of the shortcut with the given id is enabled; otherwise it is disabled.
This function was introduced in Qt 4.2.
See also grabShortcut() and releaseShortcut().
void QWidget::setShortcutEnabled(int id, bool enable = true)
If enable is true, the shortcut with the given id is enabled; otherwise the shortcut is disabled.
Warning: You should not normally need to use this function since Qt's shortcut system enables/disables shortcuts automatically as widgets become hidden/visible and gain or lose focus. It is best to use QAction or QShortcut to handle shortcuts, since they are easier to use than this low-level function.
See also grabShortcut() and releaseShortcut().
void QWidget::setSizeIncrement(int w, int h)
This is an overloaded function.
Sets the x (width) size increment to w and the y (height) size increment to h.
Note: Setter function for property sizeIncrement. 
void QWidget::setSizePolicy(QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical)
This is an overloaded function.
Sets the size policy of the widget to horizontal and vertical, with standard stretch and no height-for-width.
Note: Setter function for property sizePolicy. 
See also QSizePolicy::QSizePolicy().
void QWidget::setStyle(QStyle *style)
Sets the widget's GUI style to style. The ownership of the style object is not transferred.
If no style is set, the widget uses the application's style, QApplication::style() instead.
Setting a widget's style has no effect on existing or future child widgets.
Warning: This function is particularly useful for demonstration purposes, where you want to show Qt's styling capabilities. Real applications should avoid it and use one consistent GUI style instead.
Warning: Qt style sheets are currently not supported for custom QStyle subclasses. We plan to address this in some future release.
See also style(), QStyle, QApplication::style(), and QApplication::setStyle().
[static] void QWidget::setTabOrder(QWidget *first, QWidget *second)
Puts the second widget after the first widget in the focus order.
It effectively removes the second widget from its focus chain and inserts it after the first widget.
Note that since the tab order of the second widget is changed, you should order a chain like this:
 setTabOrder(a, b); // a to b
 setTabOrder(b, c); // a to b to c
 setTabOrder(c, d); // a to b to c to d
not like this:
 // WRONG
 setTabOrder(c, d); // c to d
 setTabOrder(a, b); // a to b AND c to d
 setTabOrder(b, c); // a to b to c, but not c to d
If first or second has a focus proxy, setTabOrder() correctly substitutes the proxy.
Note: Since Qt 5.10: A widget that has a child as focus proxy is understood as a compound widget. When setting a tab order between one or two compound widgets, the local tab order inside each will be preserved. This means that if both widgets are compound widgets, the resulting tab order will be from the last child inside first, to the first child inside second.
See also setFocusPolicy(), setFocusProxy(), and Keyboard Focus in Widgets.
void QWidget::setWindowFlag(Qt::WindowType flag, bool on = true)
Sets the window flag flag on this widget if on is true; otherwise clears the flag.
This function was introduced in Qt 5.9.
See also setWindowFlags(), windowFlags(), and windowType().
void QWidget::setWindowRole(const QString &role)
Sets the window's role to role. This only makes sense for windows on X11.
See also windowRole().
void QWidget::setWindowState(Qt::WindowStates windowState)
Sets the window state to windowState. The window state is a OR'ed combination of Qt::WindowState: Qt::WindowMinimized, Qt::WindowMaximized, Qt::WindowFullScreen, and Qt::WindowActive.
If the window is not visible (i.e. isVisible() returns false), the window state will take effect when show() is called. For visible windows, the change is immediate. For example, to toggle between full-screen and normal mode, use the following code:
 w->setWindowState(w->windowState() ^ Qt::WindowFullScreen);
In order to restore and activate a minimized window (while preserving its maximized and/or full-screen state), use the following:
 w->setWindowState((w->windowState() & ~Qt::WindowMinimized) | Qt::WindowActive);
Calling this function will hide the widget. You must call show() to make the widget visible again.
Note: On some window systems Qt::WindowActive is not immediate, and may be ignored in certain cases.
When the window state changes, the widget receives a changeEvent() of type QEvent::WindowStateChange.
See also Qt::WindowState and windowState().
void QWidget::setupUi(QWidget *widget)
Sets up the user interface for the specified widget.
Note: This function is available with widgets that derive from user interface descriptions created using uic.
See also Using a Designer UI File in Your C++ Application.
[virtual protected] void QWidget::showEvent(QShowEvent *event)
This event handler can be reimplemented in a subclass to receive widget show events which are passed in the event parameter.
Non-spontaneous show events are sent to widgets immediately before they are shown. The spontaneous show events of windows are delivered afterwards.
Note: A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g. a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again. After receiving a spontaneous hide event, a widget is still considered visible in the sense of isVisible().
See also visible, event(), and QShowEvent.
void QWidget::stackUnder(QWidget *w)
Places the widget under w in the parent widget's stack.
To make this work, the widget itself and w must be siblings.
See also raise() and lower().
QStyle *QWidget::style() const
See also QWidget::setStyle(), QApplication::setStyle(), and QApplication::style().
[virtual protected] void QWidget::tabletEvent(QTabletEvent *event)
This event handler, for event event, can be reimplemented in a subclass to receive tablet events for the widget.
If you reimplement this handler, it is very important that you ignore() the event if you do not handle it, so that the widget's parent can interpret it.
The default implementation ignores the event.
If tablet tracking is switched off, tablet move events only occur if the stylus is in contact with the tablet, or at least one stylus button is pressed, while the stylus is being moved. If tablet tracking is switched on, tablet move events occur even while the stylus is hovering in proximity of the tablet, with no buttons pressed.
See also QEvent::ignore(), QEvent::accept(), event(), setTabletTracking(), and QTabletEvent.
bool QWidget::testAttribute(Qt::WidgetAttribute attribute) const
Returns true if attribute attribute is set on this widget; otherwise returns false.
See also setAttribute().
bool QWidget::underMouse() const
Returns true if the widget is under the mouse cursor; otherwise returns false.
This value is not updated properly during drag and drop operations.
See also enterEvent() and leaveEvent().
void QWidget::ungrabGesture(Qt::GestureType gesture)
Unsubscribes the widget from a given gesture type
This function was introduced in Qt 4.6.
See also grabGesture() and QGestureEvent.
void QWidget::update(int x, int y, int w, int h)
This is an overloaded function.
This version updates a rectangle (x, y, w, h) inside the widget.
void QWidget::update(const QRect &rect)
This is an overloaded function.
This version updates a rectangle rect inside the widget.
void QWidget::update(const QRegion &rgn)
This is an overloaded function.
This version repaints a region rgn inside the widget.
void QWidget::updateGeometry()
Notifies the layout system that this widget has changed and may need to change geometry.
Call this function if the sizeHint() or sizePolicy() have changed.
For explicitly hidden widgets, updateGeometry() is a no-op. The layout system will be notified as soon as the widget is shown.
QRegion QWidget::visibleRegion() const
Returns the unobscured region where paint events can occur.
For visible widgets, this is an approximation of the area not covered by other widgets; otherwise, this is an empty region.
The repaint() function calls this function if necessary, so in general you do not need to call it.
[virtual protected] void QWidget::wheelEvent(QWheelEvent *event)
This event handler, for event event, can be reimplemented in a subclass to receive wheel events for the widget.
If you reimplement this handler, it is very important that you ignore() the event if you do not handle it, so that the widget's parent can interpret it.
The default implementation ignores the event.
See also QEvent::ignore(), QEvent::accept(), event(), and QWheelEvent.
WId QWidget::winId() const
Returns the window system identifier of the widget.
Portable in principle, but if you use it you are probably about to do something non-portable. Be careful.
If a widget is non-native (alien) and winId() is invoked on it, that widget will be provided a native handle.
This value may change at run-time. An event with type QEvent::WinIdChange will be sent to the widget following a change in window system identifier.
See also find().
QWidget *QWidget::window() const
Returns the window for this widget, i.e. the next ancestor widget that has (or could have) a window-system frame.
If the widget is a window, the widget itself is returned.
Typical usage is changing the window title:
 aWidget->window()->setWindowTitle("New Window Title");
See also isWindow().
QWindow *QWidget::windowHandle() const
If this is a native widget, return the associated QWindow. Otherwise return null.
Native widgets include toplevel widgets, QGLWidget, and child widgets on which winId() was called.
This function was introduced in Qt 5.0.
See also winId() and screen().
QString QWidget::windowRole() const
Returns the window's role, or an empty string.
See also setWindowRole(), windowIcon, and windowTitle.
Qt::WindowStates QWidget::windowState() const
Returns the current window state. The window state is a OR'ed combination of Qt::WindowState: Qt::WindowMinimized, Qt::WindowMaximized, Qt::WindowFullScreen, and Qt::WindowActive.
See also Qt::WindowState and setWindowState().
Qt::WindowType QWidget::windowType() const
Returns the window type of this widget. This is identical to windowFlags() & Qt::WindowType_Mask.
See also windowFlags.
Macro Documentation
QWIDGETSIZE_MAX
Defines the maximum size for a QWidget object.
The largest allowed size for a widget is QSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX), i.e. QSize (16777215,16777215).
See also QWidget::setMaximumSize(). 
 2020 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners.
The documentation provided herein is licensed under the terms of the GNU Free Documentation License version 1.3 as published by the Free Software Foundation.
Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners. 

